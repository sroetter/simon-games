<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Foosball - Simon's Game Gallery</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            min-height: 100vh; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white; overflow: hidden;
        }
        .header {
            text-align: center; margin-bottom: 10px;
        }
        .header h1 { font-size: 36px; color: #ffd700; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); }
        .scoreboard {
            display: flex; align-items: center; gap: 40px;
            font-size: 28px; font-weight: bold; margin-bottom: 10px;
        }
        .score-red { color: #ff4444; }
        .score-blue { color: #4488ff; }
        .score-divider { color: #ffd700; font-size: 24px; }
        #gameCanvas {
            border: 6px solid #8B4513;
            border-radius: 8px;
            box-shadow: 0 0 40px rgba(0,0,0,0.5), inset 0 0 20px rgba(0,0,0,0.3);
            cursor: none;
        }
        .controls-info {
            display: flex; gap: 60px; margin-top: 15px; font-size: 13px; color: #aaa;
        }
        .controls-info div { text-align: center; }
        .controls-info h3 { color: #ffd700; margin-bottom: 5px; font-size: 14px; }
        .menu-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); display: flex; align-items: center;
            justify-content: center; z-index: 10;
        }
        .menu-box {
            background: linear-gradient(135deg, #1a472a 0%, #2d5a3f 100%);
            border: 4px solid #ffd700; border-radius: 20px; padding: 40px;
            text-align: center; max-width: 500px;
        }
        .menu-box h2 { font-size: 42px; color: #ffd700; margin-bottom: 10px; }
        .menu-box p { color: #ccc; margin-bottom: 30px; font-size: 16px; }
        .menu-btn {
            display: block; width: 100%; padding: 15px 30px; margin: 10px 0;
            font-size: 20px; font-weight: bold; border: none; border-radius: 10px;
            cursor: pointer; transition: transform 0.2s, box-shadow 0.2s;
        }
        .menu-btn:hover { transform: scale(1.05); box-shadow: 0 5px 20px rgba(0,0,0,0.3); }
        .btn-2p { background: linear-gradient(135deg, #ff4444, #cc0000); color: white; }
        .btn-ai { background: linear-gradient(135deg, #4488ff, #0044cc); color: white; }
        .btn-back { background: linear-gradient(135deg, #888, #555); color: white; margin-top: 20px; font-size: 16px; padding: 10px 20px; }
        .goal-flash { animation: goalFlash 0.5s ease-in-out 3; }
        @keyframes goalFlash {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
        .hidden { display: none; }
    </style>
</head>
<body>
    <div class="menu-overlay" id="menu">
        <div class="menu-box">
            <h2>Foosball</h2>
            <p>Table soccer action! Control your rods to score goals.</p>
            <button class="menu-btn btn-2p" onclick="startGame(false)">2 Player</button>
            <button class="menu-btn btn-ai" onclick="startGame(true)">vs Computer</button>
            <a href="index.html"><button class="menu-btn btn-back">Back to Gallery</button></a>
        </div>
    </div>

    <div class="header">
        <h1>Foosball</h1>
    </div>
    <div class="scoreboard">
        <span class="score-red" id="scoreRed">0</span>
        <span class="score-divider">-</span>
        <span class="score-blue" id="scoreBlue">0</span>
    </div>
    <canvas id="gameCanvas" width="900" height="500"></canvas>
    <div class="controls-info">
        <div>
            <h3>Red Player (Left)</h3>
            <p>W/S: Move rod up/down<br>A/D: Select rod<br>Q: Kick</p>
        </div>
        <div>
            <h3>Blue Player (Right)</h3>
            <p>Arrow Up/Down: Move rod<br>Left/Right: Select rod<br>Enter: Kick</p>
        </div>
    </div>

    <canvas id="sfxCanvas" class="hidden" width="1" height="1"></canvas>

    <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const W = canvas.width;
    const H = canvas.height;

    // Sound effects using AudioContext
    let audioCtx = null;
    function initAudio() {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
    function playSound(freq, duration, type = 'square', vol = 0.15) {
        if (!audioCtx) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = type;
        osc.frequency.value = freq;
        gain.gain.setValueAtTime(vol, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + duration);
    }
    function playKick() { playSound(200, 0.1, 'square', 0.2); playSound(100, 0.15, 'triangle', 0.15); }
    function playBounce() { playSound(400, 0.05, 'sine', 0.1); }
    function playGoal() {
        playSound(523, 0.15, 'square', 0.2);
        setTimeout(() => playSound(659, 0.15, 'square', 0.2), 150);
        setTimeout(() => playSound(784, 0.3, 'square', 0.25), 300);
    }
    function playRodSwitch() { playSound(800, 0.03, 'sine', 0.05); }

    // Game state
    let vsAI = false;
    let gameRunning = false;
    let scoreRed = 0;
    let scoreBlue = 0;
    const WIN_SCORE = 7;

    // Table dimensions
    const WALL_THICK = 20;
    const GOAL_WIDTH = 120;
    const GOAL_DEPTH = 30;
    const GOAL_TOP = (H - GOAL_WIDTH) / 2;
    const GOAL_BOTTOM = GOAL_TOP + GOAL_WIDTH;

    // Ball
    let ball = { x: W/2, y: H/2, vx: 0, vy: 0, r: 8, speed: 5 };

    // Rod definitions: x position, number of players, color side
    // Red (left): goalie, defense, midfield, attack
    // Blue (right): attack, midfield, defense, goalie
    const ROD_WIDTH = 10;
    const PLAYER_W = 12;
    const PLAYER_H = 36;

    const redRodDefs = [
        { x: 60,  count: 1, name: 'GK' },
        { x: 150, count: 2, name: 'DEF' },
        { x: 300, count: 5, name: 'MID' },
        { x: 420, count: 3, name: 'ATK' },
    ];
    const blueRodDefs = [
        { x: W - 420, count: 3, name: 'ATK' },
        { x: W - 300, count: 5, name: 'MID' },
        { x: W - 150, count: 2, name: 'DEF' },
        { x: W - 60,  count: 1, name: 'GK' },
    ];

    function createRods(defs, color) {
        return defs.map(d => {
            const spacing = (H - WALL_THICK * 2) / (d.count + 1);
            const players = [];
            for (let i = 0; i < d.count; i++) {
                players.push({ baseY: WALL_THICK + spacing * (i + 1) });
            }
            return {
                x: d.x, players, color, offsetY: 0, name: d.name,
                kickAngle: 0, kicking: false, kickDir: 1
            };
        });
    }

    let redRods, blueRods;
    let redSelected = 2; // start on midfield
    let blueSelected = 1;

    // Input
    const keys = {};
    document.addEventListener('keydown', e => {
        initAudio();
        keys[e.key] = true;
        if (e.key === 'a' || e.key === 'A') { redSelected = Math.max(0, redSelected - 1); playRodSwitch(); }
        if (e.key === 'd' || e.key === 'D') { redSelected = Math.min(3, redSelected + 1); playRodSwitch(); }
        if (e.key === 'ArrowLeft') { blueSelected = Math.max(0, blueSelected - 1); playRodSwitch(); e.preventDefault(); }
        if (e.key === 'ArrowRight') { blueSelected = Math.min(3, blueSelected + 1); playRodSwitch(); e.preventDefault(); }
        if (e.key === 'q' || e.key === 'Q') triggerKick(redRods[redSelected]);
        if (e.key === 'Enter') { if (!vsAI) triggerKick(blueRods[blueSelected]); e.preventDefault(); }
        if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key)) e.preventDefault();
    });
    document.addEventListener('keyup', e => { keys[e.key] = false; });

    function triggerKick(rod) {
        if (!rod.kicking) {
            rod.kicking = true;
            rod.kickAngle = 0;
            rod.kickDir = 1;
            playKick();
        }
    }

    function resetBall(direction) {
        ball.x = W / 2;
        ball.y = H / 2;
        ball.vx = direction * (3 + Math.random() * 2);
        ball.vy = (Math.random() - 0.5) * 4;
    }

    function initGame() {
        redRods = createRods(redRodDefs, 'red');
        blueRods = createRods(blueRodDefs, 'blue');
        scoreRed = 0;
        scoreBlue = 0;
        redSelected = 2;
        blueSelected = 1;
        updateScore();
        resetBall(Math.random() < 0.5 ? 1 : -1);
    }

    function updateScore() {
        document.getElementById('scoreRed').textContent = scoreRed;
        document.getElementById('scoreBlue').textContent = scoreBlue;
    }

    // AI logic
    let aiTimer = 0;
    let aiTargetRod = 1;
    function updateAI() {
        aiTimer++;

        // Pick the rod closest to the ball on blue side
        let bestRod = 0;
        let bestDist = Infinity;
        for (let i = 0; i < blueRods.length; i++) {
            const dist = Math.abs(blueRods[i].x - ball.x);
            if (dist < bestDist) { bestDist = dist; bestRod = i; }
        }
        // Occasionally switch to closest rod
        if (aiTimer % 15 === 0) {
            if (blueSelected !== bestRod) {
                blueSelected = bestRod;
            }
        }

        const rod = blueRods[blueSelected];
        // Move rod to track ball y position
        const rodCenterY = rod.players.reduce((s, p) => s + p.baseY + rod.offsetY, 0) / rod.players.length;
        const diff = ball.y - rodCenterY;
        const moveSpeed = 3.5;
        if (Math.abs(diff) > 10) {
            rod.offsetY += diff > 0 ? moveSpeed : -moveSpeed;
        }

        // Clamp rod movement
        clampRod(rod);

        // Kick when ball is near
        if (ball.vx > 0 || Math.abs(ball.x - rod.x) < 60) {
            for (const p of rod.players) {
                const py = p.baseY + rod.offsetY;
                if (Math.abs(ball.x - rod.x) < 30 && Math.abs(ball.y - py) < PLAYER_H / 2 + ball.r) {
                    if (!rod.kicking && Math.random() < 0.4) {
                        triggerKick(rod);
                    }
                }
            }
        }
    }

    function clampRod(rod) {
        let minY = Infinity, maxY = -Infinity;
        for (const p of rod.players) {
            const py = p.baseY + rod.offsetY;
            minY = Math.min(minY, py - PLAYER_H / 2);
            maxY = Math.max(maxY, py + PLAYER_H / 2);
        }
        if (minY < WALL_THICK) rod.offsetY += (WALL_THICK - minY);
        if (maxY > H - WALL_THICK) rod.offsetY -= (maxY - (H - WALL_THICK));
    }

    // Physics
    function update() {
        if (!gameRunning) return;

        // Rod movement - Red
        const moveSpeed = 5;
        const rod = redRods[redSelected];
        if (keys['w'] || keys['W']) rod.offsetY -= moveSpeed;
        if (keys['s'] || keys['S']) rod.offsetY += moveSpeed;
        clampRod(rod);

        // Rod movement - Blue (human)
        if (!vsAI) {
            const brod = blueRods[blueSelected];
            if (keys['ArrowUp']) brod.offsetY -= moveSpeed;
            if (keys['ArrowDown']) brod.offsetY += moveSpeed;
            clampRod(brod);
        } else {
            updateAI();
        }

        // Update kick animations
        [...redRods, ...blueRods].forEach(r => {
            if (r.kicking) {
                r.kickAngle += 15 * r.kickDir;
                if (r.kickAngle >= 90) {
                    r.kickDir = -1;
                }
                if (r.kickAngle <= 0) {
                    r.kicking = false;
                    r.kickAngle = 0;
                    r.kickDir = 1;
                }
            }
        });

        // Ball physics
        ball.x += ball.vx;
        ball.y += ball.vy;

        // Friction
        ball.vx *= 0.999;
        ball.vy *= 0.999;

        // Wall bounces (top/bottom)
        if (ball.y - ball.r < WALL_THICK) {
            ball.y = WALL_THICK + ball.r;
            ball.vy = Math.abs(ball.vy);
            playBounce();
        }
        if (ball.y + ball.r > H - WALL_THICK) {
            ball.y = H - WALL_THICK - ball.r;
            ball.vy = -Math.abs(ball.vy);
            playBounce();
        }

        // Side walls and goals
        const inGoalY = ball.y > GOAL_TOP && ball.y < GOAL_BOTTOM;

        // Left side
        if (ball.x - ball.r < WALL_THICK) {
            if (inGoalY) {
                if (ball.x < -GOAL_DEPTH) {
                    // Blue scores!
                    scoreBlue++;
                    updateScore();
                    playGoal();
                    checkWin();
                    resetBall(-1);
                    return;
                }
                // Bounce off goal back wall handled by x < -GOAL_DEPTH
                if (ball.y - ball.r < GOAL_TOP + 5) { ball.vy = Math.abs(ball.vy); playBounce(); }
                if (ball.y + ball.r > GOAL_BOTTOM - 5) { ball.vy = -Math.abs(ball.vy); playBounce(); }
            } else {
                ball.x = WALL_THICK + ball.r;
                ball.vx = Math.abs(ball.vx);
                playBounce();
            }
        }

        // Right side
        if (ball.x + ball.r > W - WALL_THICK) {
            if (inGoalY) {
                if (ball.x > W + GOAL_DEPTH) {
                    // Red scores!
                    scoreRed++;
                    updateScore();
                    playGoal();
                    checkWin();
                    resetBall(1);
                    return;
                }
                if (ball.y - ball.r < GOAL_TOP + 5) { ball.vy = Math.abs(ball.vy); playBounce(); }
                if (ball.y + ball.r > GOAL_BOTTOM - 5) { ball.vy = -Math.abs(ball.vy); playBounce(); }
            } else {
                ball.x = W - WALL_THICK - ball.r;
                ball.vx = -Math.abs(ball.vx);
                playBounce();
            }
        }

        // Player collision
        [...redRods, ...blueRods].forEach(r => {
            const isRed = r.color === 'red';
            r.players.forEach(p => {
                const py = p.baseY + r.offsetY;
                const px = r.x;

                // Player hitbox
                const hw = PLAYER_W / 2 + (r.kicking ? 8 : 0);
                const hh = PLAYER_H / 2;

                if (ball.x + ball.r > px - hw && ball.x - ball.r < px + hw &&
                    ball.y + ball.r > py - hh && ball.y - ball.r < py + hh) {

                    // Determine hit direction
                    const kickBoost = r.kicking ? 3 : 0;
                    const baseSpeed = 4 + kickBoost;

                    if (isRed) {
                        ball.vx = Math.abs(baseSpeed) + Math.abs(ball.vx) * 0.3;
                        ball.x = px + hw + ball.r;
                    } else {
                        ball.vx = -(Math.abs(baseSpeed) + Math.abs(ball.vx) * 0.3);
                        ball.x = px - hw - ball.r;
                    }

                    // Add spin based on where ball hits player
                    const hitPos = (ball.y - py) / hh;
                    ball.vy = hitPos * 4 + (r.kicking ? hitPos * 3 : 0);

                    // Speed cap
                    const maxSpeed = 12;
                    const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
                    if (speed > maxSpeed) {
                        ball.vx = (ball.vx / speed) * maxSpeed;
                        ball.vy = (ball.vy / speed) * maxSpeed;
                    }

                    playBounce();
                }
            });
        });

        // If ball is basically stopped, give it a nudge
        if (Math.abs(ball.vx) < 0.3 && Math.abs(ball.vy) < 0.3) {
            ball.vx = (Math.random() - 0.5) * 3;
            ball.vy = (Math.random() - 0.5) * 2;
        }
    }

    function checkWin() {
        if (scoreRed >= WIN_SCORE || scoreBlue >= WIN_SCORE) {
            gameRunning = false;
            setTimeout(() => {
                const winner = scoreRed >= WIN_SCORE ? 'Red' : 'Blue';
                showMenu(`${winner} Wins!`);
            }, 1000);
        }
    }

    function showMenu(message) {
        const menu = document.getElementById('menu');
        menu.classList.remove('hidden');
        if (message) {
            menu.querySelector('h2').textContent = message;
            menu.querySelector('p').textContent = 'Play again?';
        } else {
            menu.querySelector('h2').textContent = 'Foosball';
            menu.querySelector('p').textContent = 'Table soccer action! Control your rods to score goals.';
        }
    }

    function startGame(ai) {
        initAudio();
        vsAI = ai;
        document.getElementById('menu').classList.add('hidden');
        initGame();
        gameRunning = true;
    }

    // Drawing
    function drawTable() {
        // Green felt
        ctx.fillStyle = '#1a6b3c';
        ctx.fillRect(0, 0, W, H);

        // Darker green pattern
        ctx.fillStyle = '#15592f';
        for (let i = 0; i < W; i += 60) {
            ctx.fillRect(i, 0, 30, H);
        }

        // Center line
        ctx.strokeStyle = 'rgba(255,255,255,0.3)';
        ctx.lineWidth = 2;
        ctx.setLineDash([10, 10]);
        ctx.beginPath();
        ctx.moveTo(W / 2, WALL_THICK);
        ctx.lineTo(W / 2, H - WALL_THICK);
        ctx.stroke();
        ctx.setLineDash([]);

        // Center circle
        ctx.beginPath();
        ctx.arc(W / 2, H / 2, 50, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(255,255,255,0.3)';
        ctx.lineWidth = 2;
        ctx.stroke();

        // Center dot
        ctx.beginPath();
        ctx.arc(W / 2, H / 2, 4, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255,255,255,0.5)';
        ctx.fill();

        // Walls
        ctx.fillStyle = '#5a2d0c';
        // Top wall
        ctx.fillRect(0, 0, W, WALL_THICK);
        // Bottom wall
        ctx.fillRect(0, H - WALL_THICK, W, WALL_THICK);
        // Left wall (with goal gap)
        ctx.fillRect(0, 0, WALL_THICK, GOAL_TOP);
        ctx.fillRect(0, GOAL_BOTTOM, WALL_THICK, H - GOAL_BOTTOM);
        // Right wall (with goal gap)
        ctx.fillRect(W - WALL_THICK, 0, WALL_THICK, GOAL_TOP);
        ctx.fillRect(W - WALL_THICK, GOAL_BOTTOM, WALL_THICK, H - GOAL_BOTTOM);

        // Wall highlights
        ctx.fillStyle = '#7a4420';
        ctx.fillRect(0, 0, W, 4);
        ctx.fillRect(0, H - 4, W, 4);

        // Goals
        ctx.fillStyle = 'rgba(0,0,0,0.4)';
        // Left goal
        ctx.fillRect(0, GOAL_TOP, WALL_THICK, GOAL_WIDTH);
        // Right goal
        ctx.fillRect(W - WALL_THICK, GOAL_TOP, WALL_THICK, GOAL_WIDTH);

        // Goal nets
        ctx.strokeStyle = 'rgba(255,255,255,0.2)';
        ctx.lineWidth = 1;
        // Left net
        for (let y = GOAL_TOP; y < GOAL_BOTTOM; y += 10) {
            ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(WALL_THICK, y); ctx.stroke();
        }
        for (let x = 0; x < WALL_THICK; x += 10) {
            ctx.beginPath(); ctx.moveTo(x, GOAL_TOP); ctx.lineTo(x, GOAL_BOTTOM); ctx.stroke();
        }
        // Right net
        for (let y = GOAL_TOP; y < GOAL_BOTTOM; y += 10) {
            ctx.beginPath(); ctx.moveTo(W - WALL_THICK, y); ctx.lineTo(W, y); ctx.stroke();
        }
        for (let x = W - WALL_THICK; x < W; x += 10) {
            ctx.beginPath(); ctx.moveTo(x, GOAL_TOP); ctx.lineTo(x, GOAL_BOTTOM); ctx.stroke();
        }

        // Goal posts
        ctx.fillStyle = '#ffd700';
        ctx.fillRect(WALL_THICK - 4, GOAL_TOP - 4, 8, 8);
        ctx.fillRect(WALL_THICK - 4, GOAL_BOTTOM - 4, 8, 8);
        ctx.fillRect(W - WALL_THICK - 4, GOAL_TOP - 4, 8, 8);
        ctx.fillRect(W - WALL_THICK - 4, GOAL_BOTTOM - 4, 8, 8);
    }

    function drawRod(rod, isSelected) {
        const x = rod.x;

        // Rod bar
        ctx.fillStyle = '#c0c0c0';
        ctx.fillRect(x - 3, 0, 6, H);

        // Rod shine
        ctx.fillStyle = 'rgba(255,255,255,0.3)';
        ctx.fillRect(x - 1, 0, 2, H);

        // Rod ends (handles)
        const handleColor = rod.color === 'red' ? '#cc2222' : '#2244cc';
        ctx.fillStyle = handleColor;
        ctx.fillRect(x - 8, 0, 16, 12);
        ctx.fillRect(x - 8, H - 12, 16, 12);

        // Selection indicator
        if (isSelected) {
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 3;
            ctx.strokeRect(x - 10, 0, 20, H);
            ctx.lineWidth = 1;

            // Glow effect
            ctx.shadowColor = '#ffd700';
            ctx.shadowBlur = 15;
            ctx.fillStyle = 'rgba(255, 215, 0, 0.1)';
            ctx.fillRect(x - 10, 0, 20, H);
            ctx.shadowBlur = 0;
        }

        // Players
        rod.players.forEach(p => {
            const py = p.baseY + rod.offsetY;
            drawPlayer(x, py, rod.color, rod.kicking, rod.kickAngle);
        });
    }

    function drawPlayer(x, y, color, kicking, kickAngle) {
        const isRed = color === 'red';

        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.fillRect(x - PLAYER_W/2 + 2, y - PLAYER_H/2 + 2, PLAYER_W, PLAYER_H);

        // Body
        const bodyColor = isRed ? '#dd3333' : '#3355dd';
        const bodyLight = isRed ? '#ff5555' : '#5577ff';
        ctx.fillStyle = bodyColor;

        if (kicking) {
            // Draw kicked player with rotation effect
            ctx.save();
            ctx.translate(x, y);
            const kickExtend = Math.sin(kickAngle * Math.PI / 180) * 10;
            const dir = isRed ? 1 : -1;
            ctx.translate(dir * kickExtend, 0);

            ctx.fillStyle = bodyColor;
            ctx.fillRect(-PLAYER_W/2, -PLAYER_H/2, PLAYER_W, PLAYER_H);
            ctx.fillStyle = bodyLight;
            ctx.fillRect(-PLAYER_W/2, -PLAYER_H/2, PLAYER_W/2, PLAYER_H);

            // Kick foot
            ctx.fillStyle = '#222';
            ctx.fillRect(dir * PLAYER_W/2, -4, dir * (8 + kickExtend * 0.5), 8);

            ctx.restore();
        } else {
            ctx.fillRect(x - PLAYER_W/2, y - PLAYER_H/2, PLAYER_W, PLAYER_H);
            ctx.fillStyle = bodyLight;
            ctx.fillRect(x - PLAYER_W/2, y - PLAYER_H/2, PLAYER_W/2, PLAYER_H);

            // Feet
            ctx.fillStyle = '#222';
            const dir = isRed ? 1 : -1;
            ctx.fillRect(x + dir * PLAYER_W/2, y - 3, dir * 5, 6);
        }

        // Head
        ctx.fillStyle = '#ffcc88';
        ctx.beginPath();
        ctx.arc(x, y - PLAYER_H/2 - 5, 6, 0, Math.PI * 2);
        ctx.fill();

        // Jersey number area
        ctx.fillStyle = 'rgba(255,255,255,0.3)';
        ctx.fillRect(x - 3, y - 4, 6, 8);
    }

    function drawBall() {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath();
        ctx.arc(ball.x + 2, ball.y + 2, ball.r, 0, Math.PI * 2);
        ctx.fill();

        // Ball
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
        ctx.fill();

        // Ball pattern (pentagon pattern like a soccer ball)
        ctx.fillStyle = '#333';
        const angles = [0, 72, 144, 216, 288];
        angles.forEach(a => {
            const rad = a * Math.PI / 180;
            const px = ball.x + Math.cos(rad) * ball.r * 0.5;
            const py = ball.y + Math.sin(rad) * ball.r * 0.5;
            ctx.beginPath();
            ctx.arc(px, py, 2, 0, Math.PI * 2);
            ctx.fill();
        });

        // Shine
        ctx.fillStyle = 'rgba(255,255,255,0.6)';
        ctx.beginPath();
        ctx.arc(ball.x - 2, ball.y - 2, ball.r * 0.3, 0, Math.PI * 2);
        ctx.fill();
    }

    function drawRodLabel(rod, index, side) {
        const x = rod.x;
        const isSelected = (side === 'red' && index === redSelected) || (side === 'blue' && index === blueSelected);
        if (isSelected) {
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 11px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(rod.name, x, H - 4);
        }
    }

    function draw() {
        drawTable();

        // Draw rods
        redRods.forEach((r, i) => {
            drawRod(r, i === redSelected);
            drawRodLabel(r, i, 'red');
        });
        blueRods.forEach((r, i) => {
            drawRod(r, i === blueSelected);
            drawRodLabel(r, i, 'blue');
        });

        // Draw ball
        drawBall();

        // Paused overlay
        if (!gameRunning && scoreRed === 0 && scoreBlue === 0) {
            // Menu is showing
        }
    }

    function gameLoop() {
        update();
        draw();
        requestAnimationFrame(gameLoop);
    }

    // Start the render loop (game logic only runs when gameRunning is true)
    initGame();
    gameLoop();
    </script>
</body>
</html>
