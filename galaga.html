<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Galaga - Space Shooter</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background: linear-gradient(135deg, #000033 0%, #000066 50%, #330066 100%);
            padding: 20px;
            overflow: hidden;
        }

        .game-container {
            background: rgba(0, 0, 20, 0.9);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 0 40px rgba(100, 100, 255, 0.3), 0 0 80px rgba(100, 0, 200, 0.2);
            max-width: 700px;
            width: 100%;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(100, 100, 255, 0.2);
        }

        h1 {
            text-align: center;
            font-size: 48px;
            background: linear-gradient(135deg, #00ffff 0%, #ff00ff 50%, #ffff00 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
            letter-spacing: 8px;
            text-transform: uppercase;
        }

        .screen {
            display: none;
            text-align: center;
        }

        .screen.active {
            display: block;
        }

        canvas {
            display: block;
            margin: 0 auto;
            border: 2px solid rgba(100, 100, 255, 0.4);
            border-radius: 5px;
            background: #000011;
        }

        .hud {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 5px;
            color: #fff;
            font-size: 18px;
            font-family: monospace;
        }

        .hud .score { color: #00ffff; }
        .hud .wave { color: #ffff00; }
        .hud .lives { color: #ff4444; }

        .menu-title {
            color: #00ffff;
            font-size: 20px;
            margin-bottom: 30px;
        }

        .start-btn, .restart-btn {
            display: inline-block;
            padding: 15px 50px;
            font-size: 22px;
            font-weight: bold;
            color: #000;
            background: linear-gradient(135deg, #00ffff, #00ff88);
            border: none;
            border-radius: 10px;
            cursor: pointer;
            margin: 10px;
            transition: all 0.3s;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        .start-btn:hover, .restart-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(0, 255, 200, 0.5);
        }

        .controls-info {
            color: #8888cc;
            font-size: 14px;
            margin-top: 20px;
            line-height: 2;
        }

        .controls-info kbd {
            background: rgba(100, 100, 255, 0.2);
            border: 1px solid rgba(100, 100, 255, 0.4);
            border-radius: 4px;
            padding: 2px 8px;
            color: #aaaaff;
            font-family: monospace;
        }

        .game-over-text {
            font-size: 42px;
            color: #ff4444;
            margin: 20px 0;
            text-shadow: 0 0 20px rgba(255, 0, 0, 0.5);
            letter-spacing: 4px;
        }

        .final-score {
            font-size: 28px;
            color: #00ffff;
            margin: 15px 0;
        }

        .final-wave {
            font-size: 20px;
            color: #ffff00;
            margin-bottom: 25px;
        }

        .high-score {
            font-size: 18px;
            color: #ff00ff;
            margin-bottom: 20px;
        }

        .back-link {
            display: inline-block;
            margin-top: 20px;
            color: #8888cc;
            text-decoration: none;
            font-size: 14px;
            transition: color 0.3s;
        }

        .back-link:hover {
            color: #00ffff;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>Galaga</h1>

        <!-- Menu Screen -->
        <div class="screen active" id="menuScreen">
            <div class="menu-title">Defend Earth from the alien invasion!</div>
            <button class="start-btn" id="startBtn">Start Game</button>
            <div class="controls-info">
                <kbd>&larr;</kbd> <kbd>&rarr;</kbd> or <kbd>A</kbd> <kbd>D</kbd> to move<br>
                <kbd>Space</kbd> to shoot &bull; <kbd>P</kbd> to pause
            </div>
            <a href="index.html" class="back-link">&larr; Back to Game Gallery</a>
        </div>

        <!-- Game Screen -->
        <div class="screen" id="gameScreen">
            <div class="hud">
                <span class="score">SCORE: <span id="scoreDisplay">0</span></span>
                <span class="wave">WAVE <span id="waveDisplay">1</span></span>
                <span class="lives">LIVES: <span id="livesDisplay">&#10084; &#10084; &#10084;</span></span>
            </div>
            <canvas id="gameCanvas" width="640" height="520"></canvas>
        </div>

        <!-- Game Over Screen -->
        <div class="screen" id="gameOverScreen">
            <div class="game-over-text">GAME OVER</div>
            <div class="final-score">Score: <span id="finalScore">0</span></div>
            <div class="final-wave">Reached Wave <span id="finalWave">1</span></div>
            <div class="high-score">High Score: <span id="highScore">0</span></div>
            <button class="restart-btn" id="restartBtn">Play Again</button>
            <br>
            <a href="index.html" class="back-link">&larr; Back to Game Gallery</a>
        </div>
    </div>

    <script>
    // ===================== AUDIO =====================
    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    let audioCtx;
    function ensureAudio() {
        if (!audioCtx) audioCtx = new AudioCtx();
    }

    function playSound(type) {
        ensureAudio();
        const now = audioCtx.currentTime;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);

        switch (type) {
            case 'shoot':
                osc.type = 'square';
                osc.frequency.setValueAtTime(880, now);
                osc.frequency.exponentialRampToValueAtTime(220, now + 0.1);
                gain.gain.setValueAtTime(0.12, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
                break;
            case 'enemyHit':
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(400, now);
                osc.frequency.exponentialRampToValueAtTime(80, now + 0.15);
                gain.gain.setValueAtTime(0.15, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
                osc.start(now);
                osc.stop(now + 0.15);
                break;
            case 'playerHit':
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(200, now);
                osc.frequency.exponentialRampToValueAtTime(40, now + 0.5);
                gain.gain.setValueAtTime(0.2, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
                osc.start(now);
                osc.stop(now + 0.5);
                break;
            case 'wave':
                osc.type = 'sine';
                osc.frequency.setValueAtTime(440, now);
                osc.frequency.setValueAtTime(660, now + 0.1);
                osc.frequency.setValueAtTime(880, now + 0.2);
                gain.gain.setValueAtTime(0.12, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
                osc.start(now);
                osc.stop(now + 0.4);
                break;
            case 'powerup':
                osc.type = 'sine';
                osc.frequency.setValueAtTime(523, now);
                osc.frequency.setValueAtTime(659, now + 0.08);
                osc.frequency.setValueAtTime(784, now + 0.16);
                osc.frequency.setValueAtTime(1047, now + 0.24);
                gain.gain.setValueAtTime(0.12, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.35);
                osc.start(now);
                osc.stop(now + 0.35);
                break;
        }
    }

    // ===================== GAME =====================
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const W = canvas.width;
    const H = canvas.height;

    // Game state
    let score, lives, wave, paused, gameOver, gameRunning;
    let player, bullets, enemies, enemyBullets, particles, stars, powerups;
    let enemyDir, enemySpeed, enemyShootTimer, waveTransition, waveTransitionTimer;
    let shootCooldown, invincibleTimer, animFrame;
    let highScoreVal = parseInt(localStorage.getItem('galagaHighScore')) || 0;

    const keys = {};

    // Stars background
    function initStars() {
        stars = [];
        for (let i = 0; i < 100; i++) {
            stars.push({
                x: Math.random() * W,
                y: Math.random() * H,
                speed: 0.3 + Math.random() * 1.5,
                size: Math.random() * 2 + 0.5,
                brightness: Math.random()
            });
        }
    }

    function updateStars() {
        for (const s of stars) {
            s.y += s.speed;
            if (s.y > H) {
                s.y = 0;
                s.x = Math.random() * W;
            }
            s.brightness = 0.3 + 0.7 * Math.abs(Math.sin(Date.now() * 0.001 * s.speed));
        }
    }

    function drawStars() {
        for (const s of stars) {
            ctx.fillStyle = `rgba(255,255,255,${s.brightness})`;
            ctx.fillRect(s.x, s.y, s.size, s.size);
        }
    }

    // Player
    function initPlayer() {
        player = {
            x: W / 2,
            y: H - 40,
            w: 32,
            h: 28,
            speed: 5
        };
        shootCooldown = 0;
        invincibleTimer = 0;
    }

    function drawPlayer() {
        if (invincibleTimer > 0 && Math.floor(invincibleTimer * 10) % 2 === 0) return;
        const px = player.x;
        const py = player.y;

        // Ship body
        ctx.save();
        ctx.translate(px, py);

        // Main hull
        ctx.fillStyle = '#00ddff';
        ctx.beginPath();
        ctx.moveTo(0, -14);
        ctx.lineTo(-12, 10);
        ctx.lineTo(-6, 8);
        ctx.lineTo(-6, 14);
        ctx.lineTo(6, 14);
        ctx.lineTo(6, 8);
        ctx.lineTo(12, 10);
        ctx.closePath();
        ctx.fill();

        // Cockpit
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.arc(0, -4, 3, 0, Math.PI * 2);
        ctx.fill();

        // Wings
        ctx.fillStyle = '#0088cc';
        ctx.beginPath();
        ctx.moveTo(-6, 6);
        ctx.lineTo(-16, 14);
        ctx.lineTo(-6, 14);
        ctx.closePath();
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(6, 6);
        ctx.lineTo(16, 14);
        ctx.lineTo(6, 14);
        ctx.closePath();
        ctx.fill();

        // Engine glow
        ctx.fillStyle = `hsl(${(Date.now() * 0.5) % 60 + 10}, 100%, 60%)`;
        ctx.beginPath();
        ctx.moveTo(-4, 14);
        ctx.lineTo(0, 14 + 4 + Math.random() * 6);
        ctx.lineTo(4, 14);
        ctx.closePath();
        ctx.fill();

        ctx.restore();
    }

    // Enemies
    const ENEMY_TYPES = {
        grunt: { w: 26, h: 22, hp: 1, score: 100, color1: '#66cc44', color2: '#335522' },
        wasp: { w: 24, h: 20, hp: 1, score: 150, color1: '#ccaa00', color2: '#665500' },
        mid: { w: 30, h: 24, hp: 2, score: 250, color1: '#cc2222', color2: '#661111' },
        skull: { w: 28, h: 26, hp: 3, score: 350, color1: '#bbbbbb', color2: '#555555' },
        boss: { w: 34, h: 28, hp: 4, score: 500, color1: '#aa00cc', color2: '#550066' }
    };

    function createEnemyFormation() {
        enemies = [];
        const cols = Math.min(8, 6 + Math.floor(wave / 3));
        const rows = Math.min(5, 3 + Math.floor(wave / 2));
        const spacingX = 55;
        const spacingY = 42;
        const offsetX = (W - (cols - 1) * spacingX) / 2;
        const offsetY = 50;

        for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
                let type;
                if (r === 0) type = 'boss';
                else if (r === 1) type = 'skull';
                else if (r === 2) type = 'mid';
                else if (r === 3) type = 'wasp';
                else type = 'grunt';

                const et = ENEMY_TYPES[type];
                enemies.push({
                    x: offsetX + c * spacingX,
                    y: -50 - r * 30,  // start above screen, animate in
                    targetY: offsetY + r * spacingY,
                    w: et.w,
                    h: et.h,
                    hp: et.hp + Math.floor(wave / 4),
                    maxHp: et.hp + Math.floor(wave / 4),
                    score: et.score + wave * 10,
                    type: type,
                    color1: et.color1,
                    color2: et.color2,
                    entering: true,
                    swooping: false,
                    swoopPath: null,
                    swoopT: 0,
                    homeX: offsetX + c * spacingX,
                    homeY: offsetY + r * spacingY,
                    animTimer: Math.random() * Math.PI * 2,
                    hitFlash: 0
                });
            }
        }

        enemyDir = 1;
        enemySpeed = 0.3 + wave * 0.08;
        enemyShootTimer = 0;
    }

    function drawEnemy(e) {
        ctx.save();
        ctx.translate(e.x, e.y);

        const flash = e.hitFlash > 0;
        const t = e.animTimer;
        const wingFlap = Math.sin(t * 3) * 0.2;

        if (e.type === 'grunt') {
            // Creepy spider-like alien
            const pulse = Math.sin(t * 4) * 0.15;
            // Slimy body
            ctx.fillStyle = flash ? '#fff' : e.color1;
            ctx.beginPath();
            ctx.ellipse(0, 0, 10 + pulse * 3, 9, 0, 0, Math.PI * 2);
            ctx.fill();
            // Veiny texture
            ctx.strokeStyle = flash ? '#fff' : '#113300';
            ctx.lineWidth = 0.5;
            for (let v = 0; v < 4; v++) {
                ctx.beginPath();
                ctx.moveTo(-6 + v * 4, -6);
                ctx.quadraticCurveTo(-4 + v * 3, 0 + Math.sin(t + v) * 2, -5 + v * 4, 7);
                ctx.stroke();
            }
            // Multiple creepy eyes
            const eyeGlow = 0.6 + 0.4 * Math.sin(t * 6);
            ctx.fillStyle = flash ? '#fff' : `rgba(255, ${Math.floor(50 * eyeGlow)}, 0, ${eyeGlow})`;
            ctx.beginPath();
            ctx.arc(-5, -3, 2.5, 0, Math.PI * 2);
            ctx.arc(5, -3, 2.5, 0, Math.PI * 2);
            ctx.arc(0, -1, 1.8, 0, Math.PI * 2);
            ctx.fill();
            // Slit pupils
            ctx.fillStyle = flash ? '#fff' : '#000';
            ctx.fillRect(-5.5, -4.5, 1, 3);
            ctx.fillRect(4.5, -4.5, 1, 3);
            // Spindly legs
            ctx.strokeStyle = flash ? '#fff' : e.color2;
            ctx.lineWidth = 1.2;
            for (let leg = 0; leg < 4; leg++) {
                const side = leg < 2 ? -1 : 1;
                const idx = leg % 2;
                const legAnim = Math.sin(t * 5 + leg * 1.5) * 3;
                ctx.beginPath();
                ctx.moveTo(side * 8, -3 + idx * 6);
                ctx.quadraticCurveTo(side * 14, -1 + idx * 6 + legAnim, side * 16, 4 + idx * 5 + legAnim);
                ctx.stroke();
            }
            // Dripping slime
            const dripY = (t * 2 + e.homeX) % 3;
            ctx.fillStyle = flash ? '#fff' : 'rgba(100, 200, 50, 0.6)';
            ctx.beginPath();
            ctx.ellipse(Math.sin(t) * 3, 8 + dripY, 1.5, 2 + dripY, 0, 0, Math.PI * 2);
            ctx.fill();
        } else if (e.type === 'wasp') {
            // Creepy alien wasp with stinger and twitchy wings
            const pulse = Math.sin(t * 6) * 0.15;
            const buzzWing = Math.sin(t * 20) * 0.4;
            // Segmented abdomen
            ctx.fillStyle = flash ? '#fff' : '#aa8800';
            ctx.beginPath();
            ctx.ellipse(0, 4, 5, 7, 0, 0, Math.PI * 2);
            ctx.fill();
            // Stripes on abdomen
            ctx.fillStyle = flash ? '#fff' : '#332200';
            for (let s = 0; s < 3; s++) {
                ctx.fillRect(-4, 1 + s * 3, 8, 1.5);
            }
            // Thorax
            ctx.fillStyle = flash ? '#fff' : e.color1;
            ctx.beginPath();
            ctx.ellipse(0, -2, 6, 5, 0, 0, Math.PI * 2);
            ctx.fill();
            // Buzzing wings
            ctx.fillStyle = flash ? '#fff' : 'rgba(200, 200, 100, 0.4)';
            ctx.beginPath();
            ctx.ellipse(-8, -5 + buzzWing * 8, 4, 9, -0.4, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(8, -5 + buzzWing * 8, 4, 9, 0.4, 0, Math.PI * 2);
            ctx.fill();
            // Compound eyes - clusters of tiny dots
            const eyeGlow = 0.5 + 0.5 * Math.sin(t * 8);
            ctx.fillStyle = flash ? '#fff' : `rgba(255, 0, 0, ${eyeGlow})`;
            for (let ex = -1; ex <= 1; ex++) {
                for (let ey = -1; ey <= 1; ey++) {
                    ctx.beginPath();
                    ctx.arc(-4 + ex * 1.2, -5 + ey * 1.2, 0.8, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(4 + ex * 1.2, -5 + ey * 1.2, 0.8, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            // Stinger
            ctx.fillStyle = flash ? '#fff' : '#ff4400';
            ctx.beginPath();
            ctx.moveTo(-1.5, 10);
            ctx.lineTo(0, 15 + Math.sin(t * 4) * 2);
            ctx.lineTo(1.5, 10);
            ctx.closePath();
            ctx.fill();
            // Twitchy antennae
            ctx.strokeStyle = flash ? '#fff' : e.color2;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(-3, -7);
            ctx.quadraticCurveTo(-5 + Math.sin(t * 7) * 2, -14, -7 + Math.sin(t * 9) * 3, -16);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(3, -7);
            ctx.quadraticCurveTo(5 + Math.sin(t * 7 + 1) * 2, -14, 7 + Math.sin(t * 9 + 1) * 3, -16);
            ctx.stroke();
        } else if (e.type === 'mid') {
            // Creepy flesh-moth alien
            const pulse = Math.sin(t * 3) * 0.2;
            // Fleshy body
            ctx.fillStyle = flash ? '#fff' : e.color1;
            ctx.beginPath();
            ctx.ellipse(0, 0, 9 + pulse * 2, 11, 0, 0, Math.PI * 2);
            ctx.fill();
            // Exposed ribcage lines
            ctx.strokeStyle = flash ? '#fff' : '#880000';
            ctx.lineWidth = 0.8;
            for (let r = 0; r < 3; r++) {
                ctx.beginPath();
                ctx.ellipse(0, -2 + r * 4, 6 - r, 2, 0, 0, Math.PI);
                ctx.stroke();
            }
            // Torn, veiny wings
            ctx.fillStyle = flash ? '#fff' : e.color2;
            const wf = wingFlap * 14;
            // Left wing
            ctx.beginPath();
            ctx.moveTo(-8, -4);
            ctx.quadraticCurveTo(-18, -8 + wf, -16, 2 + wf);
            ctx.quadraticCurveTo(-14, 8 + wf, -12, 4 + wf);
            ctx.quadraticCurveTo(-15, 10 + wf, -8, 8);
            ctx.closePath();
            ctx.fill();
            // Right wing
            ctx.beginPath();
            ctx.moveTo(8, -4);
            ctx.quadraticCurveTo(18, -8 + wf, 16, 2 + wf);
            ctx.quadraticCurveTo(14, 8 + wf, 12, 4 + wf);
            ctx.quadraticCurveTo(15, 10 + wf, 8, 8);
            ctx.closePath();
            ctx.fill();
            // Wing veins
            ctx.strokeStyle = flash ? '#fff' : 'rgba(200, 0, 0, 0.5)';
            ctx.lineWidth = 0.6;
            ctx.beginPath();
            ctx.moveTo(-8, -2); ctx.lineTo(-15, 0 + wf);
            ctx.moveTo(-9, 2); ctx.lineTo(-13, 7 + wf);
            ctx.moveTo(8, -2); ctx.lineTo(15, 0 + wf);
            ctx.moveTo(9, 2); ctx.lineTo(13, 7 + wf);
            ctx.stroke();
            // Hollow glowing eyes
            const eyePulse = 0.5 + 0.5 * Math.sin(t * 8);
            ctx.strokeStyle = flash ? '#fff' : `rgba(255, 255, 0, ${eyePulse})`;
            ctx.lineWidth = 1.2;
            ctx.beginPath();
            ctx.arc(-4, -4, 3, 0, Math.PI * 2);
            ctx.arc(4, -4, 3, 0, Math.PI * 2);
            ctx.stroke();
            ctx.fillStyle = flash ? '#fff' : `rgba(255, 0, 0, ${eyePulse})`;
            ctx.beginPath();
            ctx.arc(-4, -4, 1.2, 0, Math.PI * 2);
            ctx.arc(4, -4, 1.2, 0, Math.PI * 2);
            ctx.fill();
            // Fanged mouth
            ctx.fillStyle = flash ? '#fff' : '#220000';
            ctx.beginPath();
            ctx.ellipse(0, 3, 4, 2, 0, 0, Math.PI);
            ctx.fill();
            ctx.fillStyle = flash ? '#fff' : '#ffcccc';
            ctx.beginPath();
            ctx.moveTo(-3, 3); ctx.lineTo(-2, 6); ctx.lineTo(-1, 3);
            ctx.moveTo(1, 3); ctx.lineTo(2, 6); ctx.lineTo(3, 3);
            ctx.fill();
        } else if (e.type === 'skull') {
            // Floating demon skull
            const pulse = Math.sin(t * 3) * 0.15;
            const bob = Math.sin(t * 2) * 2;
            // Skull shape
            ctx.fillStyle = flash ? '#fff' : e.color1;
            ctx.beginPath();
            ctx.moveTo(0, -13 + bob);
            ctx.quadraticCurveTo(-14, -12 + bob, -13, 2 + bob);
            ctx.quadraticCurveTo(-12, 10 + bob, -6, 12 + bob);
            ctx.lineTo(-4, 10 + bob);
            ctx.lineTo(-2, 12 + bob);
            ctx.lineTo(0, 10 + bob);
            ctx.lineTo(2, 12 + bob);
            ctx.lineTo(4, 10 + bob);
            ctx.lineTo(6, 12 + bob);
            ctx.quadraticCurveTo(12, 10 + bob, 13, 2 + bob);
            ctx.quadraticCurveTo(14, -12 + bob, 0, -13 + bob);
            ctx.fill();
            // Dark cracks
            ctx.strokeStyle = flash ? '#fff' : '#333';
            ctx.lineWidth = 0.7;
            ctx.beginPath();
            ctx.moveTo(-2, -12 + bob);
            ctx.lineTo(-3, -6 + bob);
            ctx.lineTo(-1, -2 + bob);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(5, -10 + bob);
            ctx.lineTo(6, -5 + bob);
            ctx.stroke();
            // Eye sockets (dark)
            ctx.fillStyle = flash ? '#fff' : '#111';
            ctx.beginPath();
            ctx.ellipse(-5, -3 + bob, 4, 4.5, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(5, -3 + bob, 4, 4.5, 0, 0, Math.PI * 2);
            ctx.fill();
            // Glowing eyes inside sockets
            const eyeFlicker = 0.4 + 0.6 * Math.sin(t * 5 + Math.sin(t * 13) * 0.5);
            ctx.fillStyle = flash ? '#fff' : `rgba(255, ${Math.floor(100 * eyeFlicker)}, 0, ${eyeFlicker})`;
            ctx.shadowColor = '#ff4400';
            ctx.shadowBlur = flash ? 0 : 8;
            ctx.beginPath();
            ctx.arc(-5, -3 + bob, 2, 0, Math.PI * 2);
            ctx.arc(5, -3 + bob, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            // Nose hole
            ctx.fillStyle = flash ? '#fff' : '#222';
            ctx.beginPath();
            ctx.moveTo(-1.5, 2 + bob);
            ctx.lineTo(0, 4 + bob);
            ctx.lineTo(1.5, 2 + bob);
            ctx.closePath();
            ctx.fill();
            // Ghostly wisps trailing below
            ctx.strokeStyle = flash ? '#fff' : `rgba(180, 180, 180, ${0.3 + pulse})`;
            ctx.lineWidth = 1.5;
            for (let w = 0; w < 4; w++) {
                ctx.beginPath();
                const wx = -6 + w * 4;
                ctx.moveTo(wx, 12 + bob);
                ctx.quadraticCurveTo(wx + Math.sin(t * 3 + w * 2) * 4, 18 + bob, wx + Math.sin(t * 4 + w) * 5, 24 + bob);
                ctx.stroke();
            }
        } else if (e.type === 'boss') {
            // Eldritch horror boss
            const pulse = Math.sin(t * 2) * 0.2;
            // Shifting dark body
            ctx.fillStyle = flash ? '#fff' : e.color1;
            ctx.beginPath();
            ctx.moveTo(0, -15);
            ctx.quadraticCurveTo(-10 - pulse * 5, -10, -16, -2);
            ctx.quadraticCurveTo(-14, 8, -10, 14);
            ctx.lineTo(10, 14);
            ctx.quadraticCurveTo(14, 8, 16, -2);
            ctx.quadraticCurveTo(10 + pulse * 5, -10, 0, -15);
            ctx.fill();
            // Inner pulsing core
            ctx.fillStyle = flash ? '#fff' : e.color2;
            const coreSize = 7 + pulse * 3;
            ctx.beginPath();
            ctx.arc(0, 2, coreSize, 0, Math.PI * 2);
            ctx.fill();
            // Swirling dark pattern inside core
            ctx.strokeStyle = flash ? '#fff' : 'rgba(200, 0, 255, 0.4)';
            ctx.lineWidth = 1;
            for (let s = 0; s < 3; s++) {
                ctx.beginPath();
                ctx.arc(0, 2, 3 + s * 2, t * 2 + s, t * 2 + s + 2);
                ctx.stroke();
            }
            // Giant central eye
            const eyeTrackX = Math.sin(t * 0.7) * 2;
            const eyeTrackY = Math.cos(t * 0.5) * 1;
            ctx.fillStyle = flash ? '#fff' : '#ffee00';
            ctx.beginPath();
            ctx.ellipse(0, 0, 6, 5, 0, 0, Math.PI * 2);
            ctx.fill();
            // Bloodshot veins in eye
            ctx.strokeStyle = flash ? '#fff' : 'rgba(255, 0, 0, 0.6)';
            ctx.lineWidth = 0.5;
            for (let v = 0; v < 6; v++) {
                const a = (v / 6) * Math.PI * 2;
                ctx.beginPath();
                ctx.moveTo(Math.cos(a) * 2, Math.sin(a) * 2);
                ctx.lineTo(Math.cos(a) * 5.5, Math.sin(a) * 4.5);
                ctx.stroke();
            }
            // Slit pupil that tracks
            ctx.fillStyle = flash ? '#fff' : '#000';
            ctx.beginPath();
            ctx.ellipse(eyeTrackX, eyeTrackY, 1.5, 4, 0, 0, Math.PI * 2);
            ctx.fill();
            // Writhing tentacles
            ctx.strokeStyle = flash ? '#fff' : e.color1;
            ctx.lineWidth = 2;
            for (let tn = 0; tn < 6; tn++) {
                const baseX = -12 + tn * 5;
                const baseY = 13;
                ctx.beginPath();
                ctx.moveTo(baseX, baseY);
                const wave1 = Math.sin(t * 3 + tn * 1.2) * 5;
                const wave2 = Math.sin(t * 4 + tn * 0.8) * 3;
                ctx.quadraticCurveTo(baseX + wave1, baseY + 8, baseX + wave2, baseY + 16);
                ctx.stroke();
            }
            // Glowing aura
            ctx.strokeStyle = flash ? '#fff' : `rgba(170, 0, 200, ${0.2 + pulse * 0.3})`;
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.ellipse(0, 0, 18 + pulse * 4, 16 + pulse * 3, 0, 0, Math.PI * 2);
            ctx.stroke();
        }

        // HP bar for multi-hit enemies
        if (e.maxHp > 1 && !flash) {
            const barW = e.w;
            const hpRatio = e.hp / e.maxHp;
            ctx.fillStyle = '#333';
            ctx.fillRect(-barW / 2, e.h / 2 + 3, barW, 3);
            ctx.fillStyle = hpRatio > 0.5 ? '#44ff44' : hpRatio > 0.25 ? '#ffff00' : '#ff4444';
            ctx.fillRect(-barW / 2, e.h / 2 + 3, barW * hpRatio, 3);
        }

        ctx.restore();
    }

    // Swooping logic
    function startSwoop(enemy) {
        if (enemy.swooping || enemy.entering) return;
        enemy.swooping = true;
        enemy.swoopT = 0;

        // Create a swoop path toward player then back
        const startX = enemy.x;
        const startY = enemy.y;
        const targetX = player.x + (Math.random() - 0.5) * 80;
        const targetY = player.y - 40;
        const cp1x = startX + (Math.random() - 0.5) * 200;
        const cp1y = startY + 100;
        const cp2x = targetX + (Math.random() - 0.5) * 200;
        const cp2y = targetY - 60;

        enemy.swoopPath = {
            sx: startX, sy: startY,
            cp1x, cp1y, cp2x, cp2y,
            ex: enemy.homeX, ey: enemy.homeY,
            tx: targetX, ty: targetY
        };
    }

    function bezier(t, p0, p1, p2, p3) {
        const u = 1 - t;
        return u*u*u*p0 + 3*u*u*t*p1 + 3*u*t*t*p2 + t*t*t*p3;
    }

    function updateEnemies(dt) {
        if (waveTransition) return;

        // Move formation side to side
        let edgeHit = false;
        for (const e of enemies) {
            if (!e.swooping && !e.entering) {
                if (e.x + enemyDir * enemySpeed > W - 30 || e.x + enemyDir * enemySpeed < 30) {
                    edgeHit = true;
                    break;
                }
            }
        }
        if (edgeHit) enemyDir *= -1;

        for (const e of enemies) {
            e.animTimer += dt * 5;
            if (e.hitFlash > 0) e.hitFlash -= dt;

            if (e.entering) {
                e.y += (e.targetY - e.y) * 0.05;
                if (Math.abs(e.y - e.targetY) < 1) {
                    e.y = e.targetY;
                    e.entering = false;
                }
            } else if (e.swooping) {
                const sp = e.swoopPath;
                e.swoopT += dt * 0.7;

                if (e.swoopT < 0.5) {
                    // First half: swoop down toward player
                    const t = e.swoopT * 2;
                    e.x = bezier(t, sp.sx, sp.cp1x, sp.cp2x, sp.tx);
                    e.y = bezier(t, sp.sy, sp.cp1y, sp.cp2y, sp.ty);
                } else if (e.swoopT < 1.0) {
                    // Second half: return to formation
                    const t = (e.swoopT - 0.5) * 2;
                    e.x = bezier(t, sp.tx, sp.tx + 100, sp.ex - 50, sp.ex);
                    e.y = bezier(t, sp.ty, sp.ty - 100, sp.ey - 50, sp.ey);
                } else {
                    e.swooping = false;
                    e.x = e.homeX;
                    e.y = e.homeY;
                }

                // Enemy shoots during swoop
                if (e.swoopT > 0.2 && e.swoopT < 0.5 && Math.random() < 0.02) {
                    const swoopStyle = e.type === 'boss' ? 'plasma' : e.type === 'skull' ? 'ghost' : e.type === 'wasp' ? 'stinger' : e.type === 'mid' ? 'blood' : 'acid';
                    enemyBullets.push({
                        x: e.x,
                        y: e.y + e.h / 2,
                        vx: (player.x - e.x) * 0.01,
                        vy: 3 + wave * 0.2,
                        style: swoopStyle,
                        age: 0, split: false, active: true,
                        maxAge: swoopStyle === 'ghost' ? 3.5 : 99
                    });
                }
            } else {
                e.x += enemyDir * enemySpeed;
                e.homeX += enemyDir * enemySpeed;
            }
        }

        // Random swooping
        const swoopChance = 0.003 + wave * 0.001;
        for (const e of enemies) {
            if (!e.swooping && !e.entering && Math.random() < swoopChance * dt) {
                startSwoop(e);
            }
        }

        // Enemy shooting from formation - each type has a different attack
        enemyShootTimer -= dt;
        if (enemyShootTimer <= 0) {
            const formationEnemies = enemies.filter(e => !e.swooping && !e.entering);
            if (formationEnemies.length > 0) {
                const shooter = formationEnemies[Math.floor(Math.random() * formationEnemies.length)];
                const speed = 2.5 + wave * 0.2;
                const dx = player.x - shooter.x;
                const dy = player.y - shooter.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (shooter.type === 'grunt') {
                    // Grunt: spits acid glob that splits into 2 tiny drops after falling a bit
                    enemyBullets.push({
                        x: shooter.x, y: shooter.y + shooter.h / 2,
                        vx: (dx / dist) * speed * 0.15,
                        vy: speed * 0.7,
                        style: 'acid',
                        age: 0, split: false
                    });
                } else if (shooter.type === 'wasp') {
                    // Wasp: quick 3-shot burst with slight delay between each
                    for (let burst = 0; burst < 3; burst++) {
                        enemyBullets.push({
                            x: shooter.x, y: shooter.y + shooter.h / 2,
                            vx: 0,
                            vy: speed * 1.1,
                            style: 'stinger',
                            delay: burst * 0.12,
                            active: burst === 0
                        });
                    }
                } else if (shooter.type === 'mid') {
                    // Mid: blood spray - fan of 3 slow drops
                    for (let f = -1; f <= 1; f++) {
                        enemyBullets.push({
                            x: shooter.x, y: shooter.y + shooter.h / 2,
                            vx: f * 1.5,
                            vy: speed * 0.75,
                            style: 'blood',
                            age: 0
                        });
                    }
                } else if (shooter.type === 'skull') {
                    // Skull: homing ghost that slowly drifts toward player then fades
                    enemyBullets.push({
                        x: shooter.x, y: shooter.y + shooter.h / 2,
                        vx: 0, vy: speed * 0.45,
                        style: 'ghost',
                        age: 0, maxAge: 3.5
                    });
                } else if (shooter.type === 'boss') {
                    // Boss: plasma ring that expands outward in a circle
                    const ringSpeed = speed * 0.6;
                    for (let a = 0; a < 5; a++) {
                        const angle = (a / 5) * Math.PI * 0.8 + Math.PI * 0.6;
                        enemyBullets.push({
                            x: shooter.x, y: shooter.y + shooter.h / 2,
                            vx: Math.cos(angle) * ringSpeed,
                            vy: Math.sin(angle) * ringSpeed,
                            style: 'plasma',
                            age: 0
                        });
                    }
                }
            }
            enemyShootTimer = Math.max(0.4, 1.6 - wave * 0.07);
        }
    }

    // Bullets
    function updateBullets(dt) {
        for (let i = bullets.length - 1; i >= 0; i--) {
            bullets[i].y -= 8;
            if (bullets[i].y < -10) bullets.splice(i, 1);
        }

        const newBullets = [];
        for (let i = enemyBullets.length - 1; i >= 0; i--) {
            const eb = enemyBullets[i];
            eb.age = (eb.age || 0) + dt;

            if (eb.style === 'stinger') {
                // Wasp burst: delayed activation
                if (!eb.active) {
                    eb.delay -= dt;
                    if (eb.delay <= 0) eb.active = true;
                    continue;
                }
                eb.x += eb.vx;
                eb.y += eb.vy;
            } else if (eb.style === 'acid') {
                // Acid: splits into 2 after 0.4s
                eb.x += eb.vx;
                eb.y += eb.vy;
                if (!eb.split && eb.age > 0.4) {
                    eb.split = true;
                    newBullets.push({
                        x: eb.x, y: eb.y,
                        vx: -1.3, vy: eb.vy * 0.9,
                        style: 'acid_drop', age: 0
                    });
                    newBullets.push({
                        x: eb.x, y: eb.y,
                        vx: 1.3, vy: eb.vy * 0.9,
                        style: 'acid_drop', age: 0
                    });
                }
            } else if (eb.style === 'ghost') {
                // Ghost: gently homes toward player, fades out after maxAge
                const gdx = player.x - eb.x;
                const gdy = player.y - eb.y;
                const gd = Math.sqrt(gdx * gdx + gdy * gdy) || 1;
                eb.vx += (gdx / gd) * 0.8 * dt;
                eb.vy += (gdy / gd) * 0.8 * dt;
                // Cap speed so it's not too fast
                const gspd = Math.sqrt(eb.vx * eb.vx + eb.vy * eb.vy);
                if (gspd > 2.5) { eb.vx *= 2.5/gspd; eb.vy *= 2.5/gspd; }
                eb.x += eb.vx;
                eb.y += eb.vy;
                if (eb.age > eb.maxAge) { enemyBullets.splice(i, 1); continue; }
            } else if (eb.style === 'blood') {
                // Blood: affected by gravity, drips down and arcs
                eb.vy += 1.5 * dt;
                eb.x += eb.vx;
                eb.y += eb.vy;
            } else if (eb.style === 'plasma') {
                // Plasma ring pieces: just fly outward
                eb.x += eb.vx;
                eb.y += eb.vy;
            } else {
                // acid_drop and default
                eb.x += eb.vx;
                eb.y += eb.vy;
            }
            if (eb.y > H + 10 || eb.x < -10 || eb.x > W + 10) {
                enemyBullets.splice(i, 1);
            }
        }
        for (const nb of newBullets) enemyBullets.push(nb);
    }

    function drawBullets() {
        // Player bullets
        ctx.fillStyle = '#00ffff';
        ctx.shadowColor = '#00ffff';
        ctx.shadowBlur = 8;
        for (const b of bullets) {
            ctx.fillRect(b.x - 2, b.y - 6, 4, 12);
        }
        ctx.shadowBlur = 0;

        // Enemy bullets - unique scary look per monster
        const now = Date.now();
        for (const b of enemyBullets) {
            if (b.style === 'stinger' && !b.active) continue;
            ctx.save();
            if (b.style === 'acid' || b.style === 'acid_drop') {
                // Grunt acid: bubbling green glob
                const sz = b.style === 'acid' ? 5 : 3;
                const bubblePulse = Math.sin(now * 0.015 + b.x) * 1.5;
                ctx.fillStyle = '#33ff00';
                ctx.shadowColor = '#33ff00';
                ctx.shadowBlur = 12;
                ctx.beginPath();
                ctx.arc(b.x, b.y, sz + bubblePulse, 0, Math.PI * 2);
                ctx.fill();
                // Toxic inner
                ctx.fillStyle = '#aaff44';
                ctx.beginPath();
                ctx.arc(b.x - 1, b.y - 1, sz * 0.4, 0, Math.PI * 2);
                ctx.fill();
                // Drip trail
                ctx.fillStyle = 'rgba(50, 255, 0, 0.3)';
                ctx.beginPath();
                ctx.ellipse(b.x, b.y - sz - 2, 1.5, 4, 0, 0, Math.PI * 2);
                ctx.fill();
            } else if (b.style === 'stinger') {
                // Wasp stinger: glowing barbed needle
                ctx.strokeStyle = '#ffdd00';
                ctx.shadowColor = '#ffaa00';
                ctx.shadowBlur = 8;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(b.x, b.y - 7);
                ctx.lineTo(b.x, b.y + 5);
                ctx.stroke();
                // Barb tip
                ctx.fillStyle = '#ff4400';
                ctx.beginPath();
                ctx.moveTo(b.x - 3, b.y + 3);
                ctx.lineTo(b.x, b.y + 8);
                ctx.lineTo(b.x + 3, b.y + 3);
                ctx.closePath();
                ctx.fill();
                // Venom drip
                ctx.fillStyle = `rgba(255, 200, 0, ${0.4 + 0.3 * Math.sin(now * 0.01)})`;
                ctx.beginPath();
                ctx.arc(b.x, b.y + 10, 1.5, 0, Math.PI * 2);
                ctx.fill();
            } else if (b.style === 'blood') {
                // Mid blood: dark red dripping globs
                const drip = Math.sin(now * 0.008 + b.x * 0.1) * 1;
                ctx.fillStyle = '#880000';
                ctx.shadowColor = '#ff0000';
                ctx.shadowBlur = 6;
                ctx.beginPath();
                ctx.arc(b.x, b.y, 3.5 + drip, 0, Math.PI * 2);
                ctx.fill();
                // Shiny blood highlight
                ctx.fillStyle = '#cc2222';
                ctx.beginPath();
                ctx.arc(b.x - 1, b.y - 1, 1.5, 0, Math.PI * 2);
                ctx.fill();
                // Trailing drops
                ctx.fillStyle = 'rgba(140, 0, 0, 0.4)';
                ctx.beginPath();
                ctx.ellipse(b.x, b.y - 5, 1.5, 3, 0, 0, Math.PI * 2);
                ctx.fill();
            } else if (b.style === 'ghost') {
                // Skull ghost: translucent spooky wisp with face
                const fade = 1 - (b.age / b.maxAge);
                const flicker = 0.5 + 0.3 * Math.sin(now * 0.012);
                ctx.globalAlpha = fade * flicker;
                ctx.fillStyle = '#ccddff';
                ctx.shadowColor = '#8899ff';
                ctx.shadowBlur = 15;
                // Wispy body
                ctx.beginPath();
                ctx.ellipse(b.x, b.y, 7, 9, 0, 0, Math.PI * 2);
                ctx.fill();
                // Trailing wisps
                ctx.strokeStyle = 'rgba(200, 220, 255, 0.4)';
                ctx.lineWidth = 2;
                for (let w = 0; w < 3; w++) {
                    ctx.beginPath();
                    ctx.moveTo(b.x - 4 + w * 4, b.y + 7);
                    ctx.quadraticCurveTo(b.x - 4 + w * 4 + Math.sin(now * 0.005 + w) * 3, b.y + 14, b.x - 4 + w * 4 + Math.sin(now * 0.007 + w) * 4, b.y + 20);
                    ctx.stroke();
                }
                // Ghost face - hollow eyes and mouth
                ctx.fillStyle = '#112';
                ctx.beginPath();
                ctx.ellipse(b.x - 2.5, b.y - 2, 1.8, 2.2, 0, 0, Math.PI * 2);
                ctx.ellipse(b.x + 2.5, b.y - 2, 1.8, 2.2, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(b.x, b.y + 3, 2, 1.5, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            } else if (b.style === 'plasma') {
                // Boss plasma: swirling purple energy orb with lightning
                const orb = Math.sin(now * 0.01 + b.x * 0.1) * 1.5;
                ctx.fillStyle = '#aa22ff';
                ctx.shadowColor = '#cc00ff';
                ctx.shadowBlur = 14;
                ctx.beginPath();
                ctx.arc(b.x, b.y, 4.5 + orb, 0, Math.PI * 2);
                ctx.fill();
                // Hot core
                ctx.fillStyle = '#ff88ff';
                ctx.beginPath();
                ctx.arc(b.x, b.y, 2, 0, Math.PI * 2);
                ctx.fill();
                // Mini lightning arcs
                ctx.strokeStyle = `rgba(220, 150, 255, ${0.5 + 0.5 * Math.sin(now * 0.03)})`;
                ctx.lineWidth = 0.8;
                for (let l = 0; l < 3; l++) {
                    const la = (now * 0.008 + l * 2.1) % (Math.PI * 2);
                    ctx.beginPath();
                    ctx.moveTo(b.x + Math.cos(la) * 4, b.y + Math.sin(la) * 4);
                    ctx.lineTo(b.x + Math.cos(la) * 8 + (Math.random()-0.5)*2, b.y + Math.sin(la) * 8 + (Math.random()-0.5)*2);
                    ctx.stroke();
                }
            } else {
                // Fallback
                ctx.fillStyle = '#ff4444';
                ctx.shadowColor = '#ff4444';
                ctx.shadowBlur = 6;
                ctx.beginPath();
                ctx.arc(b.x, b.y, 3, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
        }
    }

    // Particles
    function spawnExplosion(x, y, color, count) {
        for (let i = 0; i < count; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 1 + Math.random() * 4;
            particles.push({
                x, y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                life: 0.5 + Math.random() * 0.5,
                maxLife: 0.5 + Math.random() * 0.5,
                color: color,
                size: 2 + Math.random() * 3
            });
        }
    }

    function updateParticles(dt) {
        for (let i = particles.length - 1; i >= 0; i--) {
            const p = particles[i];
            p.x += p.vx;
            p.y += p.vy;
            p.life -= dt;
            if (p.life <= 0) particles.splice(i, 1);
        }
    }

    function drawParticles() {
        for (const p of particles) {
            const alpha = p.life / p.maxLife;
            ctx.globalAlpha = alpha;
            ctx.fillStyle = p.color;
            ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
        }
        ctx.globalAlpha = 1;
    }

    // Powerups
    function spawnPowerup(x, y) {
        if (Math.random() < 0.08) {
            const types = ['rapid', 'spread', 'shield'];
            powerups.push({
                x, y,
                type: types[Math.floor(Math.random() * types.length)],
                vy: 1.5,
                timer: 0
            });
        }
    }

    function updatePowerups(dt) {
        for (let i = powerups.length - 1; i >= 0; i--) {
            powerups[i].y += powerups[i].vy;
            powerups[i].timer += dt;
            if (powerups[i].y > H + 20) {
                powerups.splice(i, 1);
                continue;
            }

            // Check collision with player
            const p = powerups[i];
            const dx = p.x - player.x;
            const dy = p.y - player.y;
            if (Math.abs(dx) < 20 && Math.abs(dy) < 20) {
                activatePowerup(p.type);
                powerups.splice(i, 1);
                playSound('powerup');
            }
        }
    }

    let activePowerup = null;
    let powerupTimer = 0;

    function activatePowerup(type) {
        activePowerup = type;
        powerupTimer = 8; // 8 seconds
    }

    function drawPowerups() {
        for (const p of powerups) {
            ctx.save();
            ctx.translate(p.x, p.y);
            const glow = 0.5 + 0.5 * Math.sin(p.timer * 5);

            let color;
            let label;
            if (p.type === 'rapid') { color = '#00ff88'; label = 'R'; }
            else if (p.type === 'spread') { color = '#ff8800'; label = 'S'; }
            else { color = '#00aaff'; label = 'H'; }

            ctx.shadowColor = color;
            ctx.shadowBlur = 10 + glow * 10;
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(0, 0, 10, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            ctx.fillStyle = '#000';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(label, 0, 0);

            ctx.restore();
        }
    }

    // Collisions
    function checkCollisions() {
        // Player bullets vs enemies
        for (let bi = bullets.length - 1; bi >= 0; bi--) {
            const b = bullets[bi];
            for (let ei = enemies.length - 1; ei >= 0; ei--) {
                const e = enemies[ei];
                if (Math.abs(b.x - e.x) < e.w / 2 + 2 && Math.abs(b.y - e.y) < e.h / 2 + 6) {
                    bullets.splice(bi, 1);
                    e.hp--;
                    e.hitFlash = 0.1;
                    if (e.hp <= 0) {
                        score += e.score;
                        spawnExplosion(e.x, e.y, e.color1, 15);
                        spawnPowerup(e.x, e.y);
                        enemies.splice(ei, 1);
                        playSound('enemyHit');
                        updateHUD();
                    }
                    break;
                }
            }
        }

        if (invincibleTimer > 0) return;

        // Enemy bullets vs player
        for (let i = enemyBullets.length - 1; i >= 0; i--) {
            const b = enemyBullets[i];
            if (Math.abs(b.x - player.x) < player.w / 2 && Math.abs(b.y - player.y) < player.h / 2) {
                if (activePowerup === 'shield') {
                    activePowerup = null;
                    powerupTimer = 0;
                    enemyBullets.splice(i, 1);
                    spawnExplosion(b.x, b.y, '#00aaff', 8);
                } else {
                    playerDie();
                }
                return;
            }
        }

        // Enemy body vs player
        for (const e of enemies) {
            if (Math.abs(e.x - player.x) < (e.w + player.w) / 2 &&
                Math.abs(e.y - player.y) < (e.h + player.h) / 2) {
                if (activePowerup === 'shield') {
                    activePowerup = null;
                    powerupTimer = 0;
                    e.hp = 0;
                    score += e.score;
                    spawnExplosion(e.x, e.y, e.color1, 15);
                    enemies.splice(enemies.indexOf(e), 1);
                    playSound('enemyHit');
                    updateHUD();
                } else {
                    playerDie();
                }
                return;
            }
        }
    }

    function playerDie() {
        lives--;
        spawnExplosion(player.x, player.y, '#00ddff', 25);
        playSound('playerHit');
        invincibleTimer = 2;
        player.x = W / 2;
        updateHUD();

        if (lives <= 0) {
            endGame();
        }
    }

    // HUD
    function updateHUD() {
        document.getElementById('scoreDisplay').textContent = score;
        document.getElementById('waveDisplay').textContent = wave;
        let heartsHtml = '';
        for (let i = 0; i < lives; i++) heartsHtml += '\u2764 ';
        document.getElementById('livesDisplay').innerHTML = heartsHtml;
    }

    // Wave management
    function checkWaveComplete() {
        if (enemies.length === 0 && !waveTransition) {
            waveTransition = true;
            waveTransitionTimer = 2;
            playSound('wave');
        }
    }

    function updateWaveTransition(dt) {
        if (!waveTransition) return;
        waveTransitionTimer -= dt;
        if (waveTransitionTimer <= 0) {
            wave++;
            waveTransition = false;
            createEnemyFormation();
            enemyBullets = [];
            updateHUD();
        }
    }

    function drawWaveTransition() {
        if (!waveTransition) return;
        ctx.save();
        ctx.fillStyle = '#ffff00';
        ctx.font = 'bold 36px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.shadowColor = '#ffff00';
        ctx.shadowBlur = 20;
        ctx.fillText(`WAVE ${wave + 1}`, W / 2, H / 2);
        ctx.restore();
    }

    // Draw active powerup indicator
    function drawPowerupIndicator() {
        if (!activePowerup || powerupTimer <= 0) return;
        let color, label;
        if (activePowerup === 'rapid') { color = '#00ff88'; label = 'RAPID FIRE'; }
        else if (activePowerup === 'spread') { color = '#ff8800'; label = 'SPREAD SHOT'; }
        else { color = '#00aaff'; label = 'SHIELD'; }

        ctx.save();
        ctx.fillStyle = color;
        ctx.font = 'bold 14px Arial';
        ctx.textAlign = 'center';
        ctx.globalAlpha = 0.7 + 0.3 * Math.sin(Date.now() * 0.005);
        ctx.fillText(`${label} ${powerupTimer.toFixed(1)}s`, W / 2, H - 10);
        ctx.restore();
    }

    // Draw shield effect
    function drawShield() {
        if (activePowerup !== 'shield') return;
        ctx.save();
        ctx.strokeStyle = `rgba(0, 170, 255, ${0.3 + 0.3 * Math.sin(Date.now() * 0.008)})`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(player.x, player.y, 22, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
    }

    // Main loop
    let lastTime = 0;

    function gameLoop(timestamp) {
        if (!gameRunning) return;
        const dt = Math.min((timestamp - lastTime) / 1000, 0.05);
        lastTime = timestamp;

        if (!paused && !gameOver) {
            // Input
            if (keys['ArrowLeft'] || keys['KeyA']) player.x -= player.speed;
            if (keys['ArrowRight'] || keys['KeyD']) player.x += player.speed;
            player.x = Math.max(player.w / 2, Math.min(W - player.w / 2, player.x));

            if (keys['Space'] && shootCooldown <= 0) {
                const cooldownTime = activePowerup === 'rapid' ? 0.1 : 0.22;
                shootCooldown = cooldownTime;

                if (activePowerup === 'spread') {
                    bullets.push({ x: player.x, y: player.y - 14 });
                    bullets.push({ x: player.x - 10, y: player.y - 10 });
                    bullets.push({ x: player.x + 10, y: player.y - 10 });
                } else {
                    bullets.push({ x: player.x, y: player.y - 14 });
                }
                playSound('shoot');
            }
            shootCooldown -= dt;
            if (invincibleTimer > 0) invincibleTimer -= dt;

            // Powerup timer
            if (activePowerup && powerupTimer > 0) {
                powerupTimer -= dt;
                if (powerupTimer <= 0) {
                    activePowerup = null;
                }
            }

            updateStars();
            updateBullets(dt);
            updateEnemies(dt);
            updatePowerups(dt);
            updateParticles(dt);
            checkCollisions();
            checkWaveComplete();
            updateWaveTransition(dt);
        }

        // Draw
        ctx.clearRect(0, 0, W, H);
        drawStars();

        if (!gameOver) {
            drawBullets();
            for (const e of enemies) drawEnemy(e);
            drawPowerups();
            drawPlayer();
            drawShield();
            drawParticles();
            drawWaveTransition();
            drawPowerupIndicator();
        }

        if (paused && !gameOver) {
            ctx.save();
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.fillRect(0, 0, W, H);
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 40px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('PAUSED', W / 2, H / 2);
            ctx.restore();
        }

        animFrame = requestAnimationFrame(gameLoop);
    }

    // Game state management
    function showScreen(id) {
        document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
        document.getElementById(id).classList.add('active');
    }

    function startGame() {
        score = 0;
        lives = 5;
        wave = 1;
        paused = false;
        gameOver = false;
        gameRunning = true;
        waveTransition = false;
        activePowerup = null;
        powerupTimer = 0;

        bullets = [];
        enemyBullets = [];
        particles = [];
        powerups = [];

        initStars();
        initPlayer();
        createEnemyFormation();
        updateHUD();
        showScreen('gameScreen');

        ensureAudio();
        lastTime = performance.now();
        animFrame = requestAnimationFrame(gameLoop);
    }

    function endGame() {
        gameOver = true;
        gameRunning = false;
        cancelAnimationFrame(animFrame);

        if (score > highScoreVal) {
            highScoreVal = score;
            localStorage.setItem('galagaHighScore', highScoreVal);
        }

        document.getElementById('finalScore').textContent = score;
        document.getElementById('finalWave').textContent = wave;
        document.getElementById('highScore').textContent = highScoreVal;

        setTimeout(() => showScreen('gameOverScreen'), 1000);
    }

    // Event listeners
    document.addEventListener('keydown', (e) => {
        keys[e.code] = true;
        if (e.code === 'Space') e.preventDefault();
        if (e.code === 'KeyP' && gameRunning && !gameOver) {
            paused = !paused;
        }
    });

    document.addEventListener('keyup', (e) => {
        keys[e.code] = false;
    });

    document.getElementById('startBtn').addEventListener('click', startGame);
    document.getElementById('restartBtn').addEventListener('click', startGame);
    </script>
</body>
</html>
