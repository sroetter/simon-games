<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Galaga - Space Shooter</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background: linear-gradient(135deg, #000033 0%, #000066 50%, #330066 100%);
            padding: 20px;
            overflow: hidden;
        }

        .game-container {
            background: rgba(0, 0, 20, 0.9);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 0 40px rgba(100, 100, 255, 0.3), 0 0 80px rgba(100, 0, 200, 0.2);
            max-width: 700px;
            width: 100%;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(100, 100, 255, 0.2);
        }

        h1 {
            text-align: center;
            font-size: 48px;
            background: linear-gradient(135deg, #00ffff 0%, #ff00ff 50%, #ffff00 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
            letter-spacing: 8px;
            text-transform: uppercase;
        }

        .screen {
            display: none;
            text-align: center;
        }

        .screen.active {
            display: block;
        }

        canvas {
            display: block;
            margin: 0 auto;
            border: 2px solid rgba(100, 100, 255, 0.4);
            border-radius: 5px;
            background: #000011;
        }

        .hud {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 5px;
            color: #fff;
            font-size: 18px;
            font-family: monospace;
        }

        .hud .score { color: #00ffff; }
        .hud .wave { color: #ffff00; }
        .hud .lives { color: #ff4444; }

        .menu-title {
            color: #00ffff;
            font-size: 20px;
            margin-bottom: 30px;
        }

        .start-btn, .restart-btn {
            display: inline-block;
            padding: 15px 50px;
            font-size: 22px;
            font-weight: bold;
            color: #000;
            background: linear-gradient(135deg, #00ffff, #00ff88);
            border: none;
            border-radius: 10px;
            cursor: pointer;
            margin: 10px;
            transition: all 0.3s;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        .start-btn:hover, .restart-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(0, 255, 200, 0.5);
        }

        .controls-info {
            color: #8888cc;
            font-size: 14px;
            margin-top: 20px;
            line-height: 2;
        }

        .controls-info kbd {
            background: rgba(100, 100, 255, 0.2);
            border: 1px solid rgba(100, 100, 255, 0.4);
            border-radius: 4px;
            padding: 2px 8px;
            color: #aaaaff;
            font-family: monospace;
        }

        .game-over-text {
            font-size: 42px;
            color: #ff4444;
            margin: 20px 0;
            text-shadow: 0 0 20px rgba(255, 0, 0, 0.5);
            letter-spacing: 4px;
        }

        .final-score {
            font-size: 28px;
            color: #00ffff;
            margin: 15px 0;
        }

        .final-wave {
            font-size: 20px;
            color: #ffff00;
            margin-bottom: 25px;
        }

        .high-score {
            font-size: 18px;
            color: #ff00ff;
            margin-bottom: 20px;
        }

        .back-link {
            display: inline-block;
            margin-top: 20px;
            color: #8888cc;
            text-decoration: none;
            font-size: 14px;
            transition: color 0.3s;
        }

        .back-link:hover {
            color: #00ffff;
        }

        .color-picker {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 25px 0;
            flex-wrap: wrap;
        }

        .color-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: 3px solid transparent;
            cursor: pointer;
            transition: all 0.2s;
        }

        .color-btn:hover {
            transform: scale(1.15);
        }

        .color-btn.selected {
            border-color: #fff;
            transform: scale(1.2);
        }

        .color-label {
            color: #8888cc;
            font-size: 16px;
            margin-bottom: 5px;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>Galaga</h1>

        <!-- Menu Screen -->
        <div class="screen active" id="menuScreen">
            <div class="menu-title">Defend Earth from the alien invasion!</div>
            <div class="color-label">Choose your fighter color:</div>
            <div class="color-picker" id="colorPicker">
                <button class="color-btn selected" data-color="#00ddff" style="background:#00ddff;" title="Cyan"></button>
                <button class="color-btn" data-color="#ff4444" style="background:#ff4444;" title="Red"></button>
                <button class="color-btn" data-color="#44ff44" style="background:#44ff44;" title="Green"></button>
                <button class="color-btn" data-color="#ffaa00" style="background:#ffaa00;" title="Orange"></button>
                <button class="color-btn" data-color="#ff44ff" style="background:#ff44ff;" title="Pink"></button>
                <button class="color-btn" data-color="#ffffff" style="background:#ffffff;" title="White"></button>
                <button class="color-btn" data-color="#ffff00" style="background:#ffff00;" title="Yellow"></button>
                <button class="color-btn" data-color="#8844ff" style="background:#8844ff;" title="Purple"></button>
                <button class="color-btn" data-color="#ff8888" style="background:#ff8888;" title="Salmon"></button>
                <button class="color-btn" data-color="#88ffcc" style="background:#88ffcc;" title="Mint"></button>
                <button class="color-btn" data-color="#4488ff" style="background:#4488ff;" title="Blue"></button>
                <button class="color-btn" data-color="#ff6600" style="background:#ff6600;" title="Flame"></button>
                <button class="color-btn" data-color="#00ff00" style="background:#00ff00;" title="Lime"></button>
                <button class="color-btn" data-color="#cc88ff" style="background:#cc88ff;" title="Lavender"></button>
                <button class="color-btn" data-color="#ff0066" style="background:#ff0066;" title="Hot Pink"></button>
                <button class="color-btn" data-color="#66ffff" style="background:#66ffff;" title="Aqua"></button>
            </div>
            <button class="start-btn" id="startBtn">Start Game</button>
            <div class="controls-info">
                <kbd>&larr;</kbd> <kbd>&rarr;</kbd> or <kbd>A</kbd> <kbd>D</kbd> to move<br>
                <kbd>Space</kbd> to shoot &bull; <kbd>P</kbd> to pause
            </div>
            <a href="index.html" class="back-link">&larr; Back to Game Gallery</a>
        </div>

        <!-- Game Screen -->
        <div class="screen" id="gameScreen">
            <div class="hud">
                <span class="score">SCORE: <span id="scoreDisplay">0</span></span>
                <span class="wave">WAVE <span id="waveDisplay">1</span></span>
                <span class="lives">LIVES: <span id="livesDisplay">&#10084; &#10084; &#10084;</span></span>
            </div>
            <canvas id="gameCanvas" width="640" height="520"></canvas>
        </div>

        <!-- Game Over Screen -->
        <div class="screen" id="gameOverScreen">
            <div class="game-over-text">GAME OVER</div>
            <div class="final-score">Score: <span id="finalScore">0</span></div>
            <div class="final-wave">Reached Wave <span id="finalWave">1</span></div>
            <div class="high-score">High Score: <span id="highScore">0</span></div>
            <button class="restart-btn" id="restartBtn">Play Again</button>
            <br>
            <a href="index.html" class="back-link">&larr; Back to Game Gallery</a>
        </div>
    </div>

    <script>
    // ===================== AUDIO =====================
    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    let audioCtx;
    function ensureAudio() {
        if (!audioCtx) audioCtx = new AudioCtx();
    }

    function playSound(type) {
        ensureAudio();
        const now = audioCtx.currentTime;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);

        switch (type) {
            case 'shoot':
                osc.type = 'square';
                osc.frequency.setValueAtTime(880, now);
                osc.frequency.exponentialRampToValueAtTime(220, now + 0.1);
                gain.gain.setValueAtTime(0.12, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
                break;
            case 'enemyHit':
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(400, now);
                osc.frequency.exponentialRampToValueAtTime(80, now + 0.15);
                gain.gain.setValueAtTime(0.15, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
                osc.start(now);
                osc.stop(now + 0.15);
                break;
            case 'playerHit':
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(200, now);
                osc.frequency.exponentialRampToValueAtTime(40, now + 0.5);
                gain.gain.setValueAtTime(0.2, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
                osc.start(now);
                osc.stop(now + 0.5);
                break;
            case 'wave':
                osc.type = 'sine';
                osc.frequency.setValueAtTime(440, now);
                osc.frequency.setValueAtTime(660, now + 0.1);
                osc.frequency.setValueAtTime(880, now + 0.2);
                gain.gain.setValueAtTime(0.12, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
                osc.start(now);
                osc.stop(now + 0.4);
                break;
            case 'powerup':
                osc.type = 'sine';
                osc.frequency.setValueAtTime(523, now);
                osc.frequency.setValueAtTime(659, now + 0.08);
                osc.frequency.setValueAtTime(784, now + 0.16);
                osc.frequency.setValueAtTime(1047, now + 0.24);
                gain.gain.setValueAtTime(0.12, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.35);
                osc.start(now);
                osc.stop(now + 0.35);
                break;
        }
    }

    // ===================== GAME =====================
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const W = canvas.width;
    const H = canvas.height;

    // Game state
    let score, lives, wave, paused, gameOver, gameRunning;
    let player, bullets, enemies, enemyBullets, particles, stars, powerups;
    let enemyDir, enemySpeed, enemyShootTimer, waveTransition, waveTransitionTimer;
    let shootCooldown, invincibleTimer, animFrame;
    let highScoreVal = parseInt(localStorage.getItem('galagaHighScore')) || 0;

    const keys = {};
    let playerColor = '#00ddff';

    function darkenColor(hex, factor) {
        const r = Math.floor(parseInt(hex.slice(1, 3), 16) * factor);
        const g = Math.floor(parseInt(hex.slice(3, 5), 16) * factor);
        const b = Math.floor(parseInt(hex.slice(5, 7), 16) * factor);
        return `rgb(${r},${g},${b})`;
    }

    // Stars background
    function initStars() {
        stars = [];
        for (let i = 0; i < 100; i++) {
            stars.push({
                x: Math.random() * W,
                y: Math.random() * H,
                speed: 0.3 + Math.random() * 1.5,
                size: Math.random() * 2 + 0.5,
                brightness: Math.random()
            });
        }
    }

    function updateStars() {
        for (const s of stars) {
            s.y += s.speed;
            if (s.y > H) {
                s.y = 0;
                s.x = Math.random() * W;
            }
            s.brightness = 0.3 + 0.7 * Math.abs(Math.sin(Date.now() * 0.001 * s.speed));
        }
    }

    function drawStars() {
        for (const s of stars) {
            ctx.fillStyle = `rgba(255,255,255,${s.brightness})`;
            ctx.fillRect(s.x, s.y, s.size, s.size);
        }
    }

    // Player
    function initPlayer() {
        player = {
            x: W / 2,
            y: H - 40,
            w: 32,
            h: 28,
            speed: 5
        };
        shootCooldown = 0;
        invincibleTimer = 0;
    }

    function drawPlayer() {
        if (invincibleTimer > 0 && Math.floor(invincibleTimer * 10) % 2 === 0) return;
        const px = player.x;
        const py = player.y;

        // Ship body
        ctx.save();
        ctx.translate(px, py);

        // Main hull
        ctx.fillStyle = playerColor;
        ctx.beginPath();
        ctx.moveTo(0, -14);
        ctx.lineTo(-12, 10);
        ctx.lineTo(-6, 8);
        ctx.lineTo(-6, 14);
        ctx.lineTo(6, 14);
        ctx.lineTo(6, 8);
        ctx.lineTo(12, 10);
        ctx.closePath();
        ctx.fill();

        // Cockpit
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.arc(0, -4, 3, 0, Math.PI * 2);
        ctx.fill();

        // Wings
        ctx.fillStyle = darkenColor(playerColor, 0.6);
        ctx.beginPath();
        ctx.moveTo(-6, 6);
        ctx.lineTo(-16, 14);
        ctx.lineTo(-6, 14);
        ctx.closePath();
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(6, 6);
        ctx.lineTo(16, 14);
        ctx.lineTo(6, 14);
        ctx.closePath();
        ctx.fill();

        // Engine glow
        ctx.fillStyle = `hsl(${(Date.now() * 0.5) % 60 + 10}, 100%, 60%)`;
        ctx.beginPath();
        ctx.moveTo(-4, 14);
        ctx.lineTo(0, 14 + 4 + Math.random() * 6);
        ctx.lineTo(4, 14);
        ctx.closePath();
        ctx.fill();

        ctx.restore();
    }

    // Enemies
    const ENEMY_TYPES = {
        grunt: { w: 26, h: 22, hp: 1, score: 100, color1: '#66cc44', color2: '#335522' },
        wasp: { w: 24, h: 20, hp: 1, score: 150, color1: '#ccaa00', color2: '#665500' },
        mid: { w: 30, h: 24, hp: 2, score: 250, color1: '#cc2222', color2: '#661111' },
        worm: { w: 30, h: 20, hp: 2, score: 300, color1: '#cc6699', color2: '#882255' },
        skull: { w: 28, h: 26, hp: 3, score: 350, color1: '#bbbbbb', color2: '#555555' },
        eye: { w: 30, h: 30, hp: 3, score: 400, color1: '#ff6600', color2: '#993300' },
        crab: { w: 32, h: 24, hp: 4, score: 450, color1: '#22aacc', color2: '#115566' },
        boss: { w: 34, h: 28, hp: 4, score: 500, color1: '#aa00cc', color2: '#550066' },
        dragon: { w: 36, h: 30, hp: 6, score: 700, color1: '#ff2200', color2: '#881100' },
        demon: { w: 38, h: 32, hp: 8, score: 1000, color1: '#440000', color2: '#220000' }
    };

    // New enemy every 2 waves
    function getAvailableTypes() {
        const types = ['grunt'];
        if (wave >= 2) types.push('wasp');
        if (wave >= 4) types.push('mid');
        if (wave >= 6) types.push('worm');
        if (wave >= 8) types.push('skull');
        if (wave >= 10) types.push('eye');
        if (wave >= 12) types.push('crab');
        if (wave >= 14) types.push('boss');
        if (wave >= 16) types.push('dragon');
        if (wave >= 18) types.push('demon');
        return types;
    }

    function createEnemyFormation() {
        enemies = [];
        // Start with a solid grid, grows each wave
        const cols = Math.min(9, 5 + Math.floor(wave / 2));
        const rows = Math.min(6, 2 + Math.floor(wave / 2));
        const spacingX = 55;
        const spacingY = 42;
        const offsetX = (W - (cols - 1) * spacingX) / 2;
        const offsetY = 50;

        const available = getAvailableTypes();

        for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
                // Tougher monsters go in front rows, weaker in back
                const rowIndex = Math.min(r, available.length - 1);
                const type = available[available.length - 1 - rowIndex];

                const et = ENEMY_TYPES[type];
                enemies.push({
                    x: offsetX + c * spacingX,
                    y: -50 - r * 30,
                    targetY: offsetY + r * spacingY,
                    w: et.w,
                    h: et.h,
                    hp: et.hp + Math.floor(wave / 3),
                    maxHp: et.hp + Math.floor(wave / 3),
                    score: et.score + wave * 10,
                    type: type,
                    color1: et.color1,
                    color2: et.color2,
                    entering: true,
                    swooping: false,
                    swoopPath: null,
                    swoopT: 0,
                    homeX: offsetX + c * spacingX,
                    homeY: offsetY + r * spacingY,
                    animTimer: Math.random() * Math.PI * 2,
                    hitFlash: 0
                });
            }
        }

        enemyDir = 1;
        enemySpeed = 0.4 + wave * 0.15;
        enemyShootTimer = 0;
    }

    function drawEnemy(e) {
        ctx.save();
        ctx.translate(e.x, e.y);

        const flash = e.hitFlash > 0;
        const t = e.animTimer;
        const wingFlap = Math.sin(t * 3) * 0.2;

        if (e.type === 'grunt') {
            // Creepy spider-like alien
            const pulse = Math.sin(t * 4) * 0.15;
            // Slimy body
            ctx.fillStyle = flash ? '#fff' : e.color1;
            ctx.beginPath();
            ctx.ellipse(0, 0, 10 + pulse * 3, 9, 0, 0, Math.PI * 2);
            ctx.fill();
            // Veiny texture
            ctx.strokeStyle = flash ? '#fff' : '#113300';
            ctx.lineWidth = 0.5;
            for (let v = 0; v < 4; v++) {
                ctx.beginPath();
                ctx.moveTo(-6 + v * 4, -6);
                ctx.quadraticCurveTo(-4 + v * 3, 0 + Math.sin(t + v) * 2, -5 + v * 4, 7);
                ctx.stroke();
            }
            // Multiple creepy eyes
            const eyeGlow = 0.6 + 0.4 * Math.sin(t * 6);
            ctx.fillStyle = flash ? '#fff' : `rgba(255, ${Math.floor(50 * eyeGlow)}, 0, ${eyeGlow})`;
            ctx.beginPath();
            ctx.arc(-5, -3, 2.5, 0, Math.PI * 2);
            ctx.arc(5, -3, 2.5, 0, Math.PI * 2);
            ctx.arc(0, -1, 1.8, 0, Math.PI * 2);
            ctx.fill();
            // Slit pupils
            ctx.fillStyle = flash ? '#fff' : '#000';
            ctx.fillRect(-5.5, -4.5, 1, 3);
            ctx.fillRect(4.5, -4.5, 1, 3);
            // Spindly legs
            ctx.strokeStyle = flash ? '#fff' : e.color2;
            ctx.lineWidth = 1.2;
            for (let leg = 0; leg < 4; leg++) {
                const side = leg < 2 ? -1 : 1;
                const idx = leg % 2;
                const legAnim = Math.sin(t * 5 + leg * 1.5) * 3;
                ctx.beginPath();
                ctx.moveTo(side * 8, -3 + idx * 6);
                ctx.quadraticCurveTo(side * 14, -1 + idx * 6 + legAnim, side * 16, 4 + idx * 5 + legAnim);
                ctx.stroke();
            }
            // Dripping slime
            const dripY = (t * 2 + e.homeX) % 3;
            ctx.fillStyle = flash ? '#fff' : 'rgba(100, 200, 50, 0.6)';
            ctx.beginPath();
            ctx.ellipse(Math.sin(t) * 3, 8 + dripY, 1.5, 2 + dripY, 0, 0, Math.PI * 2);
            ctx.fill();
        } else if (e.type === 'wasp') {
            // Creepy alien wasp with stinger and twitchy wings
            const pulse = Math.sin(t * 6) * 0.15;
            const buzzWing = Math.sin(t * 20) * 0.4;
            // Segmented abdomen
            ctx.fillStyle = flash ? '#fff' : '#aa8800';
            ctx.beginPath();
            ctx.ellipse(0, 4, 5, 7, 0, 0, Math.PI * 2);
            ctx.fill();
            // Stripes on abdomen
            ctx.fillStyle = flash ? '#fff' : '#332200';
            for (let s = 0; s < 3; s++) {
                ctx.fillRect(-4, 1 + s * 3, 8, 1.5);
            }
            // Thorax
            ctx.fillStyle = flash ? '#fff' : e.color1;
            ctx.beginPath();
            ctx.ellipse(0, -2, 6, 5, 0, 0, Math.PI * 2);
            ctx.fill();
            // Buzzing wings
            ctx.fillStyle = flash ? '#fff' : 'rgba(200, 200, 100, 0.4)';
            ctx.beginPath();
            ctx.ellipse(-8, -5 + buzzWing * 8, 4, 9, -0.4, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(8, -5 + buzzWing * 8, 4, 9, 0.4, 0, Math.PI * 2);
            ctx.fill();
            // Compound eyes - clusters of tiny dots
            const eyeGlow = 0.5 + 0.5 * Math.sin(t * 8);
            ctx.fillStyle = flash ? '#fff' : `rgba(255, 0, 0, ${eyeGlow})`;
            for (let ex = -1; ex <= 1; ex++) {
                for (let ey = -1; ey <= 1; ey++) {
                    ctx.beginPath();
                    ctx.arc(-4 + ex * 1.2, -5 + ey * 1.2, 0.8, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(4 + ex * 1.2, -5 + ey * 1.2, 0.8, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            // Stinger
            ctx.fillStyle = flash ? '#fff' : '#ff4400';
            ctx.beginPath();
            ctx.moveTo(-1.5, 10);
            ctx.lineTo(0, 15 + Math.sin(t * 4) * 2);
            ctx.lineTo(1.5, 10);
            ctx.closePath();
            ctx.fill();
            // Twitchy antennae
            ctx.strokeStyle = flash ? '#fff' : e.color2;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(-3, -7);
            ctx.quadraticCurveTo(-5 + Math.sin(t * 7) * 2, -14, -7 + Math.sin(t * 9) * 3, -16);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(3, -7);
            ctx.quadraticCurveTo(5 + Math.sin(t * 7 + 1) * 2, -14, 7 + Math.sin(t * 9 + 1) * 3, -16);
            ctx.stroke();
        } else if (e.type === 'mid') {
            // Creepy flesh-moth alien
            const pulse = Math.sin(t * 3) * 0.2;
            // Fleshy body
            ctx.fillStyle = flash ? '#fff' : e.color1;
            ctx.beginPath();
            ctx.ellipse(0, 0, 9 + pulse * 2, 11, 0, 0, Math.PI * 2);
            ctx.fill();
            // Exposed ribcage lines
            ctx.strokeStyle = flash ? '#fff' : '#880000';
            ctx.lineWidth = 0.8;
            for (let r = 0; r < 3; r++) {
                ctx.beginPath();
                ctx.ellipse(0, -2 + r * 4, 6 - r, 2, 0, 0, Math.PI);
                ctx.stroke();
            }
            // Torn, veiny wings
            ctx.fillStyle = flash ? '#fff' : e.color2;
            const wf = wingFlap * 14;
            // Left wing
            ctx.beginPath();
            ctx.moveTo(-8, -4);
            ctx.quadraticCurveTo(-18, -8 + wf, -16, 2 + wf);
            ctx.quadraticCurveTo(-14, 8 + wf, -12, 4 + wf);
            ctx.quadraticCurveTo(-15, 10 + wf, -8, 8);
            ctx.closePath();
            ctx.fill();
            // Right wing
            ctx.beginPath();
            ctx.moveTo(8, -4);
            ctx.quadraticCurveTo(18, -8 + wf, 16, 2 + wf);
            ctx.quadraticCurveTo(14, 8 + wf, 12, 4 + wf);
            ctx.quadraticCurveTo(15, 10 + wf, 8, 8);
            ctx.closePath();
            ctx.fill();
            // Wing veins
            ctx.strokeStyle = flash ? '#fff' : 'rgba(200, 0, 0, 0.5)';
            ctx.lineWidth = 0.6;
            ctx.beginPath();
            ctx.moveTo(-8, -2); ctx.lineTo(-15, 0 + wf);
            ctx.moveTo(-9, 2); ctx.lineTo(-13, 7 + wf);
            ctx.moveTo(8, -2); ctx.lineTo(15, 0 + wf);
            ctx.moveTo(9, 2); ctx.lineTo(13, 7 + wf);
            ctx.stroke();
            // Hollow glowing eyes
            const eyePulse = 0.5 + 0.5 * Math.sin(t * 8);
            ctx.strokeStyle = flash ? '#fff' : `rgba(255, 255, 0, ${eyePulse})`;
            ctx.lineWidth = 1.2;
            ctx.beginPath();
            ctx.arc(-4, -4, 3, 0, Math.PI * 2);
            ctx.arc(4, -4, 3, 0, Math.PI * 2);
            ctx.stroke();
            ctx.fillStyle = flash ? '#fff' : `rgba(255, 0, 0, ${eyePulse})`;
            ctx.beginPath();
            ctx.arc(-4, -4, 1.2, 0, Math.PI * 2);
            ctx.arc(4, -4, 1.2, 0, Math.PI * 2);
            ctx.fill();
            // Fanged mouth
            ctx.fillStyle = flash ? '#fff' : '#220000';
            ctx.beginPath();
            ctx.ellipse(0, 3, 4, 2, 0, 0, Math.PI);
            ctx.fill();
            ctx.fillStyle = flash ? '#fff' : '#ffcccc';
            ctx.beginPath();
            ctx.moveTo(-3, 3); ctx.lineTo(-2, 6); ctx.lineTo(-1, 3);
            ctx.moveTo(1, 3); ctx.lineTo(2, 6); ctx.lineTo(3, 3);
            ctx.fill();
        } else if (e.type === 'worm') {
            // Brain worm - segmented pulsing worm with exposed brain
            const pulse = Math.sin(t * 4) * 0.2;
            // Segments
            for (let s = 3; s >= 0; s--) {
                const sx = Math.sin(t * 3 + s * 1.2) * 3;
                const segSize = 5 + (3 - s) * 1.5 + pulse;
                ctx.fillStyle = flash ? '#fff' : (s === 0 ? e.color1 : `hsl(330, 50%, ${30 + s * 10}%)`);
                ctx.beginPath();
                ctx.ellipse(sx, -8 + s * 6, segSize, 4.5, 0, 0, Math.PI * 2);
                ctx.fill();
            }
            // Brain bulge on head
            ctx.fillStyle = flash ? '#fff' : '#ee88aa';
            ctx.beginPath();
            ctx.ellipse(Math.sin(t * 3) * 3, -10, 7 + pulse * 2, 6, 0, 0, Math.PI * 2);
            ctx.fill();
            // Brain folds
            ctx.strokeStyle = flash ? '#fff' : '#cc5577';
            ctx.lineWidth = 0.8;
            for (let f = 0; f < 3; f++) {
                ctx.beginPath();
                const fx = Math.sin(t * 3) * 3;
                ctx.arc(fx - 3 + f * 3, -11, 3, 0.5, 2.5);
                ctx.stroke();
            }
            // Tiny evil eyes
            const eg = 0.5 + 0.5 * Math.sin(t * 7);
            ctx.fillStyle = flash ? '#fff' : `rgba(255, 255, 0, ${eg})`;
            ctx.beginPath();
            ctx.arc(Math.sin(t * 3) * 3 - 3, -8, 1.5, 0, Math.PI * 2);
            ctx.arc(Math.sin(t * 3) * 3 + 3, -8, 1.5, 0, Math.PI * 2);
            ctx.fill();
            // Tail stinger
            ctx.fillStyle = flash ? '#fff' : '#ff4488';
            ctx.beginPath();
            ctx.moveTo(Math.sin(t * 3 + 3.6) * 3 - 2, 12);
            ctx.lineTo(Math.sin(t * 3 + 3.6) * 3, 18 + Math.sin(t * 5) * 2);
            ctx.lineTo(Math.sin(t * 3 + 3.6) * 3 + 2, 12);
            ctx.closePath();
            ctx.fill();
        } else if (e.type === 'skull') {
            // Floating demon skull
            const pulse = Math.sin(t * 3) * 0.15;
            const bob = Math.sin(t * 2) * 2;
            // Skull shape
            ctx.fillStyle = flash ? '#fff' : e.color1;
            ctx.beginPath();
            ctx.moveTo(0, -13 + bob);
            ctx.quadraticCurveTo(-14, -12 + bob, -13, 2 + bob);
            ctx.quadraticCurveTo(-12, 10 + bob, -6, 12 + bob);
            ctx.lineTo(-4, 10 + bob);
            ctx.lineTo(-2, 12 + bob);
            ctx.lineTo(0, 10 + bob);
            ctx.lineTo(2, 12 + bob);
            ctx.lineTo(4, 10 + bob);
            ctx.lineTo(6, 12 + bob);
            ctx.quadraticCurveTo(12, 10 + bob, 13, 2 + bob);
            ctx.quadraticCurveTo(14, -12 + bob, 0, -13 + bob);
            ctx.fill();
            // Dark cracks
            ctx.strokeStyle = flash ? '#fff' : '#333';
            ctx.lineWidth = 0.7;
            ctx.beginPath();
            ctx.moveTo(-2, -12 + bob);
            ctx.lineTo(-3, -6 + bob);
            ctx.lineTo(-1, -2 + bob);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(5, -10 + bob);
            ctx.lineTo(6, -5 + bob);
            ctx.stroke();
            // Eye sockets (dark)
            ctx.fillStyle = flash ? '#fff' : '#111';
            ctx.beginPath();
            ctx.ellipse(-5, -3 + bob, 4, 4.5, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(5, -3 + bob, 4, 4.5, 0, 0, Math.PI * 2);
            ctx.fill();
            // Glowing eyes inside sockets
            const eyeFlicker = 0.4 + 0.6 * Math.sin(t * 5 + Math.sin(t * 13) * 0.5);
            ctx.fillStyle = flash ? '#fff' : `rgba(255, ${Math.floor(100 * eyeFlicker)}, 0, ${eyeFlicker})`;
            ctx.beginPath();
            ctx.arc(-5, -3 + bob, 2, 0, Math.PI * 2);
            ctx.arc(5, -3 + bob, 2, 0, Math.PI * 2);
            ctx.fill();
            // Nose hole
            ctx.fillStyle = flash ? '#fff' : '#222';
            ctx.beginPath();
            ctx.moveTo(-1.5, 2 + bob);
            ctx.lineTo(0, 4 + bob);
            ctx.lineTo(1.5, 2 + bob);
            ctx.closePath();
            ctx.fill();
            // Ghostly wisps trailing below
            ctx.strokeStyle = flash ? '#fff' : `rgba(180, 180, 180, ${0.3 + pulse})`;
            ctx.lineWidth = 1.5;
            for (let w = 0; w < 4; w++) {
                ctx.beginPath();
                const wx = -6 + w * 4;
                ctx.moveTo(wx, 12 + bob);
                ctx.quadraticCurveTo(wx + Math.sin(t * 3 + w * 2) * 4, 18 + bob, wx + Math.sin(t * 4 + w) * 5, 24 + bob);
                ctx.stroke();
            }
        } else if (e.type === 'boss') {
            // Eldritch horror boss
            const pulse = Math.sin(t * 2) * 0.2;
            // Shifting dark body
            ctx.fillStyle = flash ? '#fff' : e.color1;
            ctx.beginPath();
            ctx.moveTo(0, -15);
            ctx.quadraticCurveTo(-10 - pulse * 5, -10, -16, -2);
            ctx.quadraticCurveTo(-14, 8, -10, 14);
            ctx.lineTo(10, 14);
            ctx.quadraticCurveTo(14, 8, 16, -2);
            ctx.quadraticCurveTo(10 + pulse * 5, -10, 0, -15);
            ctx.fill();
            // Inner pulsing core
            ctx.fillStyle = flash ? '#fff' : e.color2;
            const coreSize = 7 + pulse * 3;
            ctx.beginPath();
            ctx.arc(0, 2, coreSize, 0, Math.PI * 2);
            ctx.fill();
            // Swirling dark pattern inside core
            ctx.strokeStyle = flash ? '#fff' : 'rgba(200, 0, 255, 0.4)';
            ctx.lineWidth = 1;
            for (let s = 0; s < 3; s++) {
                ctx.beginPath();
                ctx.arc(0, 2, 3 + s * 2, t * 2 + s, t * 2 + s + 2);
                ctx.stroke();
            }
            // Giant central eye
            const eyeTrackX = Math.sin(t * 0.7) * 2;
            const eyeTrackY = Math.cos(t * 0.5) * 1;
            ctx.fillStyle = flash ? '#fff' : '#ffee00';
            ctx.beginPath();
            ctx.ellipse(0, 0, 6, 5, 0, 0, Math.PI * 2);
            ctx.fill();
            // Bloodshot veins in eye
            ctx.strokeStyle = flash ? '#fff' : 'rgba(255, 0, 0, 0.6)';
            ctx.lineWidth = 0.5;
            for (let v = 0; v < 6; v++) {
                const a = (v / 6) * Math.PI * 2;
                ctx.beginPath();
                ctx.moveTo(Math.cos(a) * 2, Math.sin(a) * 2);
                ctx.lineTo(Math.cos(a) * 5.5, Math.sin(a) * 4.5);
                ctx.stroke();
            }
            // Slit pupil that tracks
            ctx.fillStyle = flash ? '#fff' : '#000';
            ctx.beginPath();
            ctx.ellipse(eyeTrackX, eyeTrackY, 1.5, 4, 0, 0, Math.PI * 2);
            ctx.fill();
            // Writhing tentacles
            ctx.strokeStyle = flash ? '#fff' : e.color1;
            ctx.lineWidth = 2;
            for (let tn = 0; tn < 6; tn++) {
                const baseX = -12 + tn * 5;
                const baseY = 13;
                ctx.beginPath();
                ctx.moveTo(baseX, baseY);
                const wave1 = Math.sin(t * 3 + tn * 1.2) * 5;
                const wave2 = Math.sin(t * 4 + tn * 0.8) * 3;
                ctx.quadraticCurveTo(baseX + wave1, baseY + 8, baseX + wave2, baseY + 16);
                ctx.stroke();
            }
            // Glowing aura
            ctx.strokeStyle = flash ? '#fff' : `rgba(170, 0, 200, ${0.2 + pulse * 0.3})`;
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.ellipse(0, 0, 18 + pulse * 4, 16 + pulse * 3, 0, 0, Math.PI * 2);
            ctx.stroke();
        } else if (e.type === 'eye') {
            // Giant floating evil eye
            const pulse = Math.sin(t * 2.5) * 0.2;
            const irisAngle = t * 0.5;
            // Outer eye white
            ctx.fillStyle = flash ? '#fff' : '#ffeecc';
            ctx.beginPath();
            ctx.ellipse(0, 0, 14 + pulse * 3, 11, 0, 0, Math.PI * 2);
            ctx.fill();
            // Bloodshot veins
            ctx.strokeStyle = flash ? '#fff' : 'rgba(200, 0, 0, 0.5)';
            ctx.lineWidth = 0.6;
            for (let v = 0; v < 8; v++) {
                const a = (v / 8) * Math.PI * 2;
                ctx.beginPath();
                ctx.moveTo(Math.cos(a) * 5, Math.sin(a) * 4);
                ctx.quadraticCurveTo(Math.cos(a) * 10 + Math.sin(t + v) * 1, Math.sin(a) * 8, Math.cos(a) * 13, Math.sin(a) * 10);
                ctx.stroke();
            }
            // Iris
            ctx.fillStyle = flash ? '#fff' : e.color1;
            ctx.beginPath();
            ctx.arc(Math.sin(irisAngle) * 3, Math.cos(irisAngle) * 2, 6, 0, Math.PI * 2);
            ctx.fill();
            // Pupil - slit
            ctx.fillStyle = flash ? '#fff' : '#000';
            ctx.beginPath();
            ctx.ellipse(Math.sin(irisAngle) * 3, Math.cos(irisAngle) * 2, 1.5, 5, 0, 0, Math.PI * 2);
            ctx.fill();
            // Eyelid shadow
            ctx.fillStyle = flash ? '#fff' : `rgba(100, 30, 0, ${0.3 + pulse * 0.5})`;
            ctx.beginPath();
            ctx.ellipse(0, -8, 14, 5, 0, 0, Math.PI);
            ctx.fill();
            // Tear/ichor drip
            ctx.fillStyle = flash ? '#fff' : 'rgba(180, 0, 0, 0.5)';
            ctx.beginPath();
            ctx.ellipse(-5, 10 + (t * 2) % 4, 1.5, 2 + (t * 2) % 3, 0, 0, Math.PI * 2);
            ctx.fill();
        } else if (e.type === 'crab') {
            // Armored alien crab with snapping claws
            const pulse = Math.sin(t * 3) * 0.15;
            const clawSnap = Math.abs(Math.sin(t * 4)) * 0.5;
            // Shell
            ctx.fillStyle = flash ? '#fff' : e.color1;
            ctx.beginPath();
            ctx.ellipse(0, 0, 14 + pulse * 2, 10, 0, 0, Math.PI * 2);
            ctx.fill();
            // Shell armor plates
            ctx.strokeStyle = flash ? '#fff' : e.color2;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.ellipse(0, -1, 10, 6, 0, 0, Math.PI);
            ctx.stroke();
            ctx.beginPath();
            ctx.ellipse(0, 1, 8, 4, 0, Math.PI, Math.PI * 2);
            ctx.stroke();
            // Left claw
            ctx.fillStyle = flash ? '#fff' : e.color1;
            ctx.beginPath();
            ctx.moveTo(-13, -2);
            ctx.lineTo(-19, -6 - clawSnap * 5);
            ctx.lineTo(-16, -2);
            ctx.lineTo(-19, 2 + clawSnap * 5);
            ctx.closePath();
            ctx.fill();
            // Right claw
            ctx.beginPath();
            ctx.moveTo(13, -2);
            ctx.lineTo(19, -6 - clawSnap * 5);
            ctx.lineTo(16, -2);
            ctx.lineTo(19, 2 + clawSnap * 5);
            ctx.closePath();
            ctx.fill();
            // Legs
            ctx.strokeStyle = flash ? '#fff' : e.color2;
            ctx.lineWidth = 1.2;
            for (let leg = 0; leg < 3; leg++) {
                const la = Math.sin(t * 4 + leg * 1.5) * 2;
                ctx.beginPath();
                ctx.moveTo(-10 + leg * 2, 8);
                ctx.lineTo(-13 + leg, 14 + la);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(10 - leg * 2, 8);
                ctx.lineTo(13 - leg, 14 + la);
                ctx.stroke();
            }
            // Eyes on stalks
            ctx.strokeStyle = flash ? '#fff' : e.color1;
            ctx.lineWidth = 1.5;
            ctx.beginPath(); ctx.moveTo(-5, -8); ctx.lineTo(-6, -14); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(5, -8); ctx.lineTo(6, -14); ctx.stroke();
            ctx.fillStyle = flash ? '#fff' : '#ff0000';
            ctx.beginPath();
            ctx.arc(-6, -14, 2, 0, Math.PI * 2);
            ctx.arc(6, -14, 2, 0, Math.PI * 2);
            ctx.fill();
        } else if (e.type === 'dragon') {
            // Fire dragon with flapping wings and flame breath
            const pulse = Math.sin(t * 2) * 0.2;
            const wingFlap2 = Math.sin(t * 4) * 0.3;
            // Body
            ctx.fillStyle = flash ? '#fff' : e.color1;
            ctx.beginPath();
            ctx.ellipse(0, 2, 10, 12, 0, 0, Math.PI * 2);
            ctx.fill();
            // Scales
            ctx.fillStyle = flash ? '#fff' : e.color2;
            for (let s = 0; s < 4; s++) {
                ctx.beginPath();
                ctx.arc(0, -6 + s * 5, 4, 0.3, 2.8);
                ctx.fill();
            }
            // Wings
            ctx.fillStyle = flash ? '#fff' : '#cc4400';
            const wf2 = wingFlap2 * 15;
            ctx.beginPath();
            ctx.moveTo(-8, -4);
            ctx.lineTo(-22, -12 + wf2);
            ctx.lineTo(-18, 0 + wf2);
            ctx.lineTo(-8, 4);
            ctx.closePath();
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(8, -4);
            ctx.lineTo(22, -12 + wf2);
            ctx.lineTo(18, 0 + wf2);
            ctx.lineTo(8, 4);
            ctx.closePath();
            ctx.fill();
            // Head with horns
            ctx.fillStyle = flash ? '#fff' : e.color1;
            ctx.beginPath();
            ctx.ellipse(0, -12, 6, 5, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = flash ? '#fff' : '#ffaa00';
            ctx.beginPath();
            ctx.moveTo(-4, -16); ctx.lineTo(-6, -22); ctx.lineTo(-2, -17);
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(4, -16); ctx.lineTo(6, -22); ctx.lineTo(2, -17);
            ctx.fill();
            // Glowing eyes
            const eg = 0.5 + 0.5 * Math.sin(t * 6);
            ctx.fillStyle = flash ? '#fff' : `rgba(255, 200, 0, ${eg})`;
            ctx.beginPath();
            ctx.arc(-3, -13, 1.5, 0, Math.PI * 2);
            ctx.arc(3, -13, 1.5, 0, Math.PI * 2);
            ctx.fill();
            // Flame from mouth
            ctx.fillStyle = flash ? '#fff' : `rgba(255, ${100 + Math.floor(Math.sin(t * 8) * 50)}, 0, 0.7)`;
            ctx.beginPath();
            ctx.moveTo(-2, -7);
            ctx.quadraticCurveTo(0, -4, 2, -7);
            ctx.quadraticCurveTo(0, -2 + Math.sin(t * 6) * 2, 0, -7);
            ctx.fill();
            // Tail
            ctx.strokeStyle = flash ? '#fff' : e.color1;
            ctx.lineWidth = 2.5;
            ctx.beginPath();
            ctx.moveTo(0, 13);
            ctx.quadraticCurveTo(8 + Math.sin(t * 3) * 4, 18, 4 + Math.sin(t * 2) * 6, 24);
            ctx.stroke();
        } else if (e.type === 'demon') {
            // Arch demon - massive horned nightmare
            const pulse = Math.sin(t * 1.5) * 0.2;
            // Dark body
            ctx.fillStyle = flash ? '#fff' : e.color1;
            ctx.beginPath();
            ctx.moveTo(0, -16);
            ctx.quadraticCurveTo(-18, -8, -16, 6);
            ctx.quadraticCurveTo(-14, 16, 0, 16);
            ctx.quadraticCurveTo(14, 16, 16, 6);
            ctx.quadraticCurveTo(18, -8, 0, -16);
            ctx.fill();
            // Inner hellfire
            ctx.fillStyle = flash ? '#fff' : `rgba(255, ${50 + Math.floor(Math.sin(t * 4) * 50)}, 0, 0.6)`;
            ctx.beginPath();
            ctx.ellipse(0, 2, 10 + pulse * 4, 9 + pulse * 3, 0, 0, Math.PI * 2);
            ctx.fill();
            // Massive horns
            ctx.fillStyle = flash ? '#fff' : '#331111';
            ctx.beginPath();
            ctx.moveTo(-8, -14);
            ctx.quadraticCurveTo(-14, -26, -18, -28 + Math.sin(t) * 2);
            ctx.lineTo(-10, -16);
            ctx.closePath();
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(8, -14);
            ctx.quadraticCurveTo(14, -26, 18, -28 + Math.sin(t) * 2);
            ctx.lineTo(10, -16);
            ctx.closePath();
            ctx.fill();
            // Multiple eyes in a row
            for (let de = 0; de < 5; de++) {
                const ex = -8 + de * 4;
                const eyeFlicker = 0.3 + 0.7 * Math.sin(t * 5 + de * 1.3);
                ctx.fillStyle = flash ? '#fff' : `rgba(255, 0, 0, ${eyeFlicker})`;
                ctx.beginPath();
                ctx.arc(ex, -6, 1.8, 0, Math.PI * 2);
                ctx.fill();
            }
            // Jagged mouth
            ctx.fillStyle = flash ? '#fff' : '#000';
            ctx.beginPath();
            ctx.moveTo(-8, 2);
            for (let tooth = 0; tooth < 5; tooth++) {
                ctx.lineTo(-6 + tooth * 3, 5 + (tooth % 2) * 3);
            }
            ctx.lineTo(8, 2);
            ctx.closePath();
            ctx.fill();
            // Hell flames around body
            ctx.strokeStyle = flash ? '#fff' : `rgba(255, 100, 0, ${0.3 + pulse * 0.4})`;
            ctx.lineWidth = 1.5;
            for (let fl = 0; fl < 6; fl++) {
                const fa = (fl / 6) * Math.PI * 2 + t * 1.5;
                const fr = 16 + pulse * 5;
                ctx.beginPath();
                ctx.moveTo(Math.cos(fa) * fr, Math.sin(fa) * fr);
                ctx.lineTo(Math.cos(fa) * (fr + 6 + Math.sin(t * 4 + fl) * 3), Math.sin(fa) * (fr + 6));
                ctx.stroke();
            }
        }

        // HP bar for multi-hit enemies
        if (e.maxHp > 1 && !flash) {
            const barW = e.w;
            const hpRatio = e.hp / e.maxHp;
            ctx.fillStyle = '#333';
            ctx.fillRect(-barW / 2, e.h / 2 + 3, barW, 3);
            ctx.fillStyle = hpRatio > 0.5 ? '#44ff44' : hpRatio > 0.25 ? '#ffff00' : '#ff4444';
            ctx.fillRect(-barW / 2, e.h / 2 + 3, barW * hpRatio, 3);
        }

        ctx.restore();
    }

    // Swooping logic
    function startSwoop(enemy) {
        if (enemy.swooping || enemy.entering) return;
        enemy.swooping = true;
        enemy.swoopT = 0;

        // Create a swoop path toward player then back
        const startX = enemy.x;
        const startY = enemy.y;
        const targetX = player.x + (Math.random() - 0.5) * 80;
        const targetY = player.y - 40;
        const cp1x = startX + (Math.random() - 0.5) * 200;
        const cp1y = startY + 100;
        const cp2x = targetX + (Math.random() - 0.5) * 200;
        const cp2y = targetY - 60;

        enemy.swoopPath = {
            sx: startX, sy: startY,
            cp1x, cp1y, cp2x, cp2y,
            ex: enemy.homeX, ey: enemy.homeY,
            tx: targetX, ty: targetY
        };
    }

    function bezier(t, p0, p1, p2, p3) {
        const u = 1 - t;
        return u*u*u*p0 + 3*u*u*t*p1 + 3*u*t*t*p2 + t*t*t*p3;
    }

    function updateEnemies(dt) {
        if (waveTransition) return;

        // Move formation side to side
        let edgeHit = false;
        for (const e of enemies) {
            if (!e.swooping && !e.entering) {
                if (e.x + enemyDir * enemySpeed > W - 30 || e.x + enemyDir * enemySpeed < 30) {
                    edgeHit = true;
                    break;
                }
            }
        }
        if (edgeHit) enemyDir *= -1;

        for (const e of enemies) {
            e.animTimer += dt * 5;
            if (e.hitFlash > 0) e.hitFlash -= dt;

            if (e.entering) {
                e.y += (e.targetY - e.y) * 0.05;
                if (Math.abs(e.y - e.targetY) < 1) {
                    e.y = e.targetY;
                    e.entering = false;
                }
            } else if (e.swooping) {
                const sp = e.swoopPath;
                e.swoopT += dt * 0.7;

                if (e.swoopT < 0.5) {
                    // First half: swoop down toward player
                    const t = e.swoopT * 2;
                    e.x = bezier(t, sp.sx, sp.cp1x, sp.cp2x, sp.tx);
                    e.y = bezier(t, sp.sy, sp.cp1y, sp.cp2y, sp.ty);
                } else if (e.swoopT < 1.0) {
                    // Second half: return to formation
                    const t = (e.swoopT - 0.5) * 2;
                    e.x = bezier(t, sp.tx, sp.tx + 100, sp.ex - 50, sp.ex);
                    e.y = bezier(t, sp.ty, sp.ty - 100, sp.ey - 50, sp.ey);
                } else {
                    e.swooping = false;
                    e.x = e.homeX;
                    e.y = e.homeY;
                }

                // Enemy shoots during swoop
                if (e.swoopT > 0.2 && e.swoopT < 0.5 && Math.random() < 0.02) {
                    const swoopStyles = { boss: 'plasma', skull: 'ghost', wasp: 'stinger', mid: 'blood', worm: 'parasite', eye: 'laser', crab: 'bubble', dragon: 'dragonfire', demon: 'hellfire', grunt: 'acid' };
                    const swoopStyle = swoopStyles[e.type] || 'acid';
                    enemyBullets.push({
                        x: e.x,
                        y: e.y + e.h / 2,
                        vx: (player.x - e.x) * 0.01,
                        vy: 2 + wave * 0.12,
                        style: swoopStyle,
                        age: 0, split: false, active: true,
                        maxAge: swoopStyle === 'ghost' ? 3.5 : 99
                    });
                }
            } else {
                e.x += enemyDir * enemySpeed;
                e.homeX += enemyDir * enemySpeed;
            }
        }

        // Swooping disabled - enemies stay in formation

        // Enemy shooting from formation - each type has a different attack
        enemyShootTimer -= dt;
        if (enemyShootTimer <= 0) {
            const formationEnemies = enemies.filter(e => !e.swooping && !e.entering);
            if (formationEnemies.length > 0) {
                const shooter = formationEnemies[Math.floor(Math.random() * formationEnemies.length)];
                const speed = 1.8 + wave * 0.2;
                const dx = player.x - shooter.x;
                const dy = player.y - shooter.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (shooter.type === 'grunt') {
                    // Grunt: spits acid glob that splits into 2 tiny drops after falling a bit
                    enemyBullets.push({
                        x: shooter.x, y: shooter.y + shooter.h / 2,
                        vx: (dx / dist) * speed * 0.15,
                        vy: speed * 0.7,
                        style: 'acid',
                        age: 0, split: false
                    });
                } else if (shooter.type === 'wasp') {
                    // Wasp: quick 3-shot burst that angles toward the player
                    const waspAngle = Math.atan2(dy, dx);
                    for (let burst = 0; burst < 3; burst++) {
                        enemyBullets.push({
                            x: shooter.x, y: shooter.y + shooter.h / 2,
                            vx: Math.cos(waspAngle) * speed * 0.5,
                            vy: Math.sin(waspAngle) * speed * 0.5 + speed * 0.6,
                            style: 'stinger',
                            delay: burst * 0.12,
                            active: burst === 0
                        });
                    }
                } else if (shooter.type === 'mid') {
                    // Mid: blood spray - fan of 3 slow drops
                    for (let f = -1; f <= 1; f++) {
                        enemyBullets.push({
                            x: shooter.x, y: shooter.y + shooter.h / 2,
                            vx: f * 1.5,
                            vy: speed * 0.75,
                            style: 'blood',
                            age: 0
                        });
                    }
                } else if (shooter.type === 'skull') {
                    // Skull: homing ghost that slowly drifts toward player then fades
                    enemyBullets.push({
                        x: shooter.x, y: shooter.y + shooter.h / 2,
                        vx: 0, vy: speed * 0.45,
                        style: 'ghost',
                        age: 0, maxAge: 3.5
                    });
                } else if (shooter.type === 'worm') {
                    // Worm: rains down a curtain of 5 parasites across a wide area
                    for (let w = -2; w <= 2; w++) {
                        enemyBullets.push({
                            x: shooter.x + w * 25,
                            y: shooter.y + shooter.h / 2,
                            vx: w * 0.3,
                            vy: speed * 0.55,
                            style: 'parasite',
                            age: 0, bounces: 0
                        });
                    }
                } else if (shooter.type === 'eye') {
                    // Eye: laser beam - fast narrow line aimed at player
                    enemyBullets.push({
                        x: shooter.x, y: shooter.y + shooter.h / 2,
                        vx: (dx / dist) * speed * 0.7,
                        vy: (dy / dist) * speed * 0.7,
                        style: 'laser',
                        age: 0
                    });
                } else if (shooter.type === 'crab') {
                    // Crab: shoots 2 bubble projectiles that float side to side
                    enemyBullets.push({
                        x: shooter.x - 8, y: shooter.y,
                        vx: -0.8, vy: speed * 0.55,
                        style: 'bubble', age: 0
                    });
                    enemyBullets.push({
                        x: shooter.x + 8, y: shooter.y,
                        vx: 0.8, vy: speed * 0.55,
                        style: 'bubble', age: 0
                    });
                } else if (shooter.type === 'boss') {
                    // Boss: plasma ring that expands outward in a circle
                    const ringSpeed = speed * 0.6;
                    for (let a = 0; a < 5; a++) {
                        const angle = (a / 5) * Math.PI * 0.8 + Math.PI * 0.6;
                        enemyBullets.push({
                            x: shooter.x, y: shooter.y + shooter.h / 2,
                            vx: Math.cos(angle) * ringSpeed,
                            vy: Math.sin(angle) * ringSpeed,
                            style: 'plasma',
                            age: 0
                        });
                    }
                } else if (shooter.type === 'dragon') {
                    // Dragon: fire breath - 3 fireballs that spread and fall
                    for (let f = -1; f <= 1; f++) {
                        enemyBullets.push({
                            x: shooter.x, y: shooter.y + shooter.h / 2,
                            vx: f * 1.8 + (dx / dist) * speed * 0.15,
                            vy: speed * 0.65,
                            style: 'dragonfire',
                            age: 0
                        });
                    }
                } else if (shooter.type === 'demon') {
                    // Demon: hellfire burst - ring of 8 slow embers
                    for (let a = 0; a < 8; a++) {
                        const angle = (a / 8) * Math.PI * 2;
                        enemyBullets.push({
                            x: shooter.x, y: shooter.y,
                            vx: Math.cos(angle) * speed * 0.35,
                            vy: Math.sin(angle) * speed * 0.35 + speed * 0.3,
                            style: 'hellfire',
                            age: 0
                        });
                    }
                }
            }
            enemyShootTimer = Math.max(0.6, 2.4 - wave * 0.08);
        }
    }

    // Bullets
    function updateBullets(dt) {
        for (let i = bullets.length - 1; i >= 0; i--) {
            bullets[i].y -= 8;
            if (bullets[i].y < -10) bullets.splice(i, 1);
        }

        const newBullets = [];
        for (let i = enemyBullets.length - 1; i >= 0; i--) {
            const eb = enemyBullets[i];
            eb.age = (eb.age || 0) + dt;

            if (eb.style === 'stinger') {
                // Wasp burst: delayed activation
                if (!eb.active) {
                    eb.delay -= dt;
                    if (eb.delay <= 0) eb.active = true;
                    continue;
                }
                eb.x += eb.vx;
                eb.y += eb.vy;
            } else if (eb.style === 'acid') {
                // Acid: splits into 2 after 0.4s
                eb.x += eb.vx;
                eb.y += eb.vy;
                if (!eb.split && eb.age > 0.4) {
                    eb.split = true;
                    newBullets.push({
                        x: eb.x, y: eb.y,
                        vx: -1.3, vy: eb.vy * 0.9,
                        style: 'acid_drop', age: 0
                    });
                    newBullets.push({
                        x: eb.x, y: eb.y,
                        vx: 1.3, vy: eb.vy * 0.9,
                        style: 'acid_drop', age: 0
                    });
                }
            } else if (eb.style === 'ghost') {
                // Ghost: gently homes toward player, fades out after maxAge
                const gdx = player.x - eb.x;
                const gdy = player.y - eb.y;
                const gd = Math.sqrt(gdx * gdx + gdy * gdy) || 1;
                eb.vx += (gdx / gd) * 0.8 * dt;
                eb.vy += (gdy / gd) * 0.8 * dt;
                // Cap speed so it's not too fast
                const gspd = Math.sqrt(eb.vx * eb.vx + eb.vy * eb.vy);
                if (gspd > 2.5) { eb.vx *= 2.5/gspd; eb.vy *= 2.5/gspd; }
                eb.x += eb.vx;
                eb.y += eb.vy;
                if (eb.age > eb.maxAge) { enemyBullets.splice(i, 1); continue; }
            } else if (eb.style === 'blood') {
                // Blood: affected by gravity, drips down and arcs
                eb.vy += 1.5 * dt;
                eb.x += eb.vx;
                eb.y += eb.vy;
            } else if (eb.style === 'plasma') {
                eb.x += eb.vx;
                eb.y += eb.vy;
            } else if (eb.style === 'parasite') {
                // Bounces off side walls
                eb.x += eb.vx;
                eb.y += eb.vy;
                if (eb.x < 5 || eb.x > W - 5) {
                    eb.vx *= -1;
                    eb.bounces++;
                    if (eb.bounces > 3) { enemyBullets.splice(i, 1); continue; }
                }
            } else if (eb.style === 'laser') {
                eb.x += eb.vx;
                eb.y += eb.vy;
            } else if (eb.style === 'bubble') {
                // Float side to side
                eb.age += dt * 3;
                eb.x += Math.sin(eb.age * 2) * 1.2;
                eb.y += eb.vy;
            } else if (eb.style === 'dragonfire') {
                // Slightly affected by gravity
                eb.vy += 0.8 * dt;
                eb.x += eb.vx;
                eb.y += eb.vy;
            } else if (eb.style === 'hellfire') {
                // Slow embers that drift
                eb.x += eb.vx;
                eb.y += eb.vy;
                eb.vx *= 0.998;
            } else {
                eb.x += eb.vx;
                eb.y += eb.vy;
            }
            if (eb.y > H + 10 || eb.x < -10 || eb.x > W + 10) {
                enemyBullets.splice(i, 1);
            }
        }
        for (const nb of newBullets) enemyBullets.push(nb);
    }

    function drawBullets() {
        // Player bullets
        ctx.fillStyle = '#00ffff';
        for (const b of bullets) {
            ctx.fillRect(b.x - 2, b.y - 6, 4, 12);
        }

        // Enemy bullets - unique look per monster (no shadowBlur for performance)
        const now = Date.now();
        for (const b of enemyBullets) {
            if (b.style === 'stinger' && !b.active) continue;
            if (b.style === 'acid' || b.style === 'acid_drop') {
                const sz = b.style === 'acid' ? 5 : 3;
                ctx.fillStyle = '#33ff00';
                ctx.beginPath();
                ctx.arc(b.x, b.y, sz, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#aaff44';
                ctx.beginPath();
                ctx.arc(b.x, b.y, sz * 0.4, 0, Math.PI * 2);
                ctx.fill();
            } else if (b.style === 'stinger') {
                ctx.strokeStyle = '#ffdd00';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(b.x, b.y - 7);
                ctx.lineTo(b.x, b.y + 5);
                ctx.stroke();
                ctx.fillStyle = '#ff4400';
                ctx.beginPath();
                ctx.moveTo(b.x - 3, b.y + 3);
                ctx.lineTo(b.x, b.y + 8);
                ctx.lineTo(b.x + 3, b.y + 3);
                ctx.closePath();
                ctx.fill();
            } else if (b.style === 'blood') {
                ctx.fillStyle = '#880000';
                ctx.beginPath();
                ctx.arc(b.x, b.y, 3.5, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#cc2222';
                ctx.beginPath();
                ctx.arc(b.x - 1, b.y - 1, 1.5, 0, Math.PI * 2);
                ctx.fill();
            } else if (b.style === 'ghost') {
                const fade = 1 - (b.age / b.maxAge);
                ctx.globalAlpha = fade * 0.7;
                ctx.fillStyle = '#ccddff';
                ctx.beginPath();
                ctx.ellipse(b.x, b.y, 7, 9, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#112';
                ctx.beginPath();
                ctx.ellipse(b.x - 2.5, b.y - 2, 1.8, 2.2, 0, 0, Math.PI * 2);
                ctx.ellipse(b.x + 2.5, b.y - 2, 1.8, 2.2, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(b.x, b.y + 3, 2, 1.5, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            } else if (b.style === 'plasma') {
                ctx.fillStyle = '#aa22ff';
                ctx.beginPath();
                ctx.arc(b.x, b.y, 4.5, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#ff88ff';
                ctx.beginPath();
                ctx.arc(b.x, b.y, 2, 0, Math.PI * 2);
                ctx.fill();
            } else if (b.style === 'parasite') {
                ctx.fillStyle = '#ee66aa';
                ctx.beginPath();
                ctx.ellipse(b.x, b.y, 4, 3.5, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#cc4488';
                ctx.lineWidth = 0.5;
                ctx.beginPath();
                ctx.arc(b.x, b.y - 1, 2.5, 0.3, 2.8);
                ctx.stroke();
            } else if (b.style === 'laser') {
                ctx.strokeStyle = '#ff8800';
                ctx.lineWidth = 2.5;
                ctx.beginPath();
                ctx.moveTo(b.x - b.vx * 3, b.y - b.vy * 3);
                ctx.lineTo(b.x + b.vx * 2, b.y + b.vy * 2);
                ctx.stroke();
                ctx.strokeStyle = '#ffcc44';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(b.x - b.vx * 2, b.y - b.vy * 2);
                ctx.lineTo(b.x + b.vx * 1, b.y + b.vy * 1);
                ctx.stroke();
            } else if (b.style === 'bubble') {
                ctx.strokeStyle = '#44ddff';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.arc(b.x, b.y, 5, 0, Math.PI * 2);
                ctx.stroke();
                ctx.fillStyle = 'rgba(50, 200, 255, 0.2)';
                ctx.fill();
            } else if (b.style === 'dragonfire') {
                ctx.fillStyle = '#ff4400';
                ctx.beginPath();
                ctx.arc(b.x, b.y, 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#ffaa00';
                ctx.beginPath();
                ctx.arc(b.x, b.y, 2.5, 0, Math.PI * 2);
                ctx.fill();
            } else if (b.style === 'hellfire') {
                ctx.fillStyle = '#881100';
                ctx.beginPath();
                ctx.arc(b.x, b.y, 3.5, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#ff4400';
                ctx.beginPath();
                ctx.arc(b.x, b.y, 1.5, 0, Math.PI * 2);
                ctx.fill();
            } else {
                ctx.fillStyle = '#ff4444';
                ctx.beginPath();
                ctx.arc(b.x, b.y, 3, 0, Math.PI * 2);
                ctx.fill();
            }
        }
    }

    // Particles
    const MAX_PARTICLES = 80;
    function spawnExplosion(x, y, color, count) {
        // Cap total particles for performance
        count = Math.min(count, MAX_PARTICLES - particles.length);
        for (let i = 0; i < count; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 1 + Math.random() * 4;
            particles.push({
                x, y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                life: 0.5 + Math.random() * 0.5,
                maxLife: 0.5 + Math.random() * 0.5,
                color: color,
                size: 2 + Math.random() * 3
            });
        }
    }

    function updateParticles(dt) {
        for (let i = particles.length - 1; i >= 0; i--) {
            const p = particles[i];
            p.x += p.vx;
            p.y += p.vy;
            p.life -= dt;
            if (p.life <= 0) particles.splice(i, 1);
        }
    }

    function drawParticles() {
        for (const p of particles) {
            const alpha = p.life / p.maxLife;
            ctx.globalAlpha = alpha;
            ctx.fillStyle = p.color;
            ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
        }
        ctx.globalAlpha = 1;
    }

    // Powerups
    function spawnPowerup(x, y) {
        if (Math.random() < 0.08) {
            const types = ['rapid', 'spread', 'shield'];
            powerups.push({
                x, y,
                type: types[Math.floor(Math.random() * types.length)],
                vy: 1.5,
                timer: 0
            });
        }
    }

    function updatePowerups(dt) {
        for (let i = powerups.length - 1; i >= 0; i--) {
            powerups[i].y += powerups[i].vy;
            powerups[i].timer += dt;
            if (powerups[i].y > H + 20) {
                powerups.splice(i, 1);
                continue;
            }

            // Check collision with player
            const p = powerups[i];
            const dx = p.x - player.x;
            const dy = p.y - player.y;
            if (Math.abs(dx) < 20 && Math.abs(dy) < 20) {
                activatePowerup(p.type);
                powerups.splice(i, 1);
                playSound('powerup');
            }
        }
    }

    let activePowerups = {}; // { rapid: 8, spread: 5, shield: 3 } etc

    function activatePowerup(type) {
        activePowerups[type] = (activePowerups[type] || 0) + 8; // add 8 seconds
    }

    function hasPowerup(type) {
        return (activePowerups[type] || 0) > 0;
    }

    function drawPowerups() {
        for (const p of powerups) {
            ctx.save();
            ctx.translate(p.x, p.y);
            const glow = 0.5 + 0.5 * Math.sin(p.timer * 5);

            let color;
            let label;
            if (p.type === 'rapid') { color = '#00ff88'; label = 'R'; }
            else if (p.type === 'spread') { color = '#ff8800'; label = 'S'; }
            else { color = '#00aaff'; label = 'I'; }

            ctx.shadowColor = color;
            ctx.shadowBlur = 10 + glow * 10;
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(0, 0, 10, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            ctx.fillStyle = '#000';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(label, 0, 0);

            ctx.restore();
        }
    }

    // Collisions
    function checkCollisions() {
        // Player bullets vs enemies
        for (let bi = bullets.length - 1; bi >= 0; bi--) {
            const b = bullets[bi];
            for (let ei = enemies.length - 1; ei >= 0; ei--) {
                const e = enemies[ei];
                if (Math.abs(b.x - e.x) < e.w / 2 + 2 && Math.abs(b.y - e.y) < e.h / 2 + 6) {
                    bullets.splice(bi, 1);
                    e.hp--;
                    e.hitFlash = 0.1;
                    if (e.hp <= 0) {
                        score += e.score;
                        spawnExplosion(e.x, e.y, e.color1, 8);
                        spawnPowerup(e.x, e.y);
                        enemies.splice(ei, 1);
                        playSound('enemyHit');
                        updateHUD();
                    }
                    break;
                }
            }
        }

        if (invincibleTimer > 0) return;

        // Enemy bullets vs player
        for (let i = enemyBullets.length - 1; i >= 0; i--) {
            const b = enemyBullets[i];
            if (Math.abs(b.x - player.x) < player.w / 2 && Math.abs(b.y - player.y) < player.h / 2) {
                if (hasPowerup('shield')) {
                    enemyBullets.splice(i, 1);
                    spawnExplosion(b.x, b.y, '#00aaff', 8);
                } else {
                    playerDie();
                }
                return;
            }
        }

        // Enemy body vs player
        for (const e of enemies) {
            if (Math.abs(e.x - player.x) < (e.w + player.w) / 2 &&
                Math.abs(e.y - player.y) < (e.h + player.h) / 2) {
                if (hasPowerup('shield')) {
                    e.hp = 0;
                    score += e.score;
                    spawnExplosion(e.x, e.y, e.color1, 8);
                    enemies.splice(enemies.indexOf(e), 1);
                    playSound('enemyHit');
                    updateHUD();
                } else {
                    playerDie();
                }
                return;
            }
        }
    }

    function playerDie() {
        lives--;
        spawnExplosion(player.x, player.y, playerColor, 12);
        playSound('playerHit');
        invincibleTimer = 2;
        player.x = W / 2;
        updateHUD();

        if (lives <= 0) {
            endGame();
        }
    }

    // HUD
    function updateHUD() {
        document.getElementById('scoreDisplay').textContent = score;
        document.getElementById('waveDisplay').textContent = wave;
        let heartsHtml = '';
        for (let i = 0; i < lives; i++) heartsHtml += '\u2764 ';
        document.getElementById('livesDisplay').innerHTML = heartsHtml;
    }

    // Wave management
    function checkWaveComplete() {
        if (enemies.length === 0 && !waveTransition) {
            waveTransition = true;
            waveTransitionTimer = 2;
            playSound('wave');
        }
    }

    function updateWaveTransition(dt) {
        if (!waveTransition) return;
        waveTransitionTimer -= dt;
        if (waveTransitionTimer <= 0) {
            wave++;
            waveTransition = false;
            createEnemyFormation();
            enemyBullets = [];
            updateHUD();
        }
    }

    const NEW_ENEMY_WAVES = {
        2: 'WASP',
        4: 'FLESH-MOTH',
        6: 'BRAIN WORM',
        8: 'DEMON SKULL',
        10: 'EVIL EYE',
        12: 'TERROR CRAB',
        14: 'ELDRITCH BOSS',
        16: 'FIRE DRAGON',
        18: 'ARCH DEMON'
    };

    function drawWaveTransition() {
        if (!waveTransition) return;
        ctx.save();
        ctx.fillStyle = '#ffff00';
        ctx.font = 'bold 36px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.shadowColor = '#ffff00';
        ctx.shadowBlur = 20;
        ctx.fillText(`WAVE ${wave + 1}`, W / 2, H / 2 - 20);

        // Show new enemy warning
        const nextWave = wave + 1;
        if (NEW_ENEMY_WAVES[nextWave]) {
            ctx.fillStyle = '#ff4444';
            ctx.font = 'bold 22px Arial';
            ctx.shadowColor = '#ff0000';
            ctx.shadowBlur = 15;
            const blink = Math.sin(Date.now() * 0.008) > 0;
            if (blink) {
                ctx.fillText(`NEW ENEMY: ${NEW_ENEMY_WAVES[nextWave]}!`, W / 2, H / 2 + 25);
            }
        }
        ctx.restore();
    }

    // Draw active powerup indicators
    const POWERUP_DISPLAY = {
        rapid: { color: '#00ff88', label: 'RAPID FIRE' },
        spread: { color: '#ff8800', label: 'SPREAD SHOT' },
        shield: { color: '#00aaff', label: 'INVINCIBLE' }
    };

    function drawPowerupIndicator() {
        const active = Object.keys(activePowerups);
        if (active.length === 0) return;
        ctx.save();
        ctx.font = 'bold 13px Arial';
        ctx.textAlign = 'center';
        ctx.globalAlpha = 0.8;
        let yOff = 0;
        for (const type of active) {
            const info = POWERUP_DISPLAY[type];
            if (!info) continue;
            ctx.fillStyle = info.color;
            ctx.fillText(`${info.label} ${activePowerups[type].toFixed(1)}s`, W / 2, H - 10 - yOff);
            yOff += 16;
        }
        ctx.restore();
    }

    // Draw shield effect
    function drawShield() {
        if (!hasPowerup('shield')) return;
        ctx.save();
        ctx.strokeStyle = playerColor;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(player.x, player.y, 22, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
    }

    // Main loop
    let lastTime = 0;

    function gameLoop(timestamp) {
        if (!gameRunning) return;
        const dt = Math.min((timestamp - lastTime) / 1000, 0.05);
        lastTime = timestamp;

        if (!paused && !gameOver) {
            // Input
            if (keys['ArrowLeft'] || keys['KeyA']) player.x -= player.speed;
            if (keys['ArrowRight'] || keys['KeyD']) player.x += player.speed;
            player.x = Math.max(player.w / 2, Math.min(W - player.w / 2, player.x));

            if (keys['Space'] && shootCooldown <= 0) {
                const cooldownTime = hasPowerup('rapid') ? 0.1 : 0.22;
                shootCooldown = cooldownTime;

                if (hasPowerup('spread')) {
                    bullets.push({ x: player.x, y: player.y - 14 });
                    bullets.push({ x: player.x - 10, y: player.y - 10 });
                    bullets.push({ x: player.x + 10, y: player.y - 10 });
                } else {
                    bullets.push({ x: player.x, y: player.y - 14 });
                }
                playSound('shoot');
            }
            shootCooldown -= dt;
            if (invincibleTimer > 0) invincibleTimer -= dt;

            // Powerup timers
            for (const type in activePowerups) {
                if (activePowerups[type] > 0) {
                    activePowerups[type] -= dt;
                    if (activePowerups[type] <= 0) {
                        delete activePowerups[type];
                    }
                }
            }

            updateStars();
            updateBullets(dt);
            updateEnemies(dt);
            updatePowerups(dt);
            updateParticles(dt);
            checkCollisions();
            checkWaveComplete();
            updateWaveTransition(dt);
        }

        // Draw
        ctx.clearRect(0, 0, W, H);
        drawStars();

        if (!gameOver) {
            drawBullets();
            for (const e of enemies) drawEnemy(e);
            drawPowerups();
            drawPlayer();
            drawShield();
            drawParticles();
            drawWaveTransition();
            drawPowerupIndicator();
        }

        if (paused && !gameOver) {
            ctx.save();
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.fillRect(0, 0, W, H);
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 40px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('PAUSED', W / 2, H / 2);
            ctx.restore();
        }

        animFrame = requestAnimationFrame(gameLoop);
    }

    // Game state management
    function showScreen(id) {
        document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
        document.getElementById(id).classList.add('active');
    }

    function startGame() {
        score = 0;
        lives = 5;
        wave = 1;
        paused = false;
        gameOver = false;
        gameRunning = true;
        waveTransition = false;
        activePowerups = {};

        bullets = [];
        enemyBullets = [];
        particles = [];
        powerups = [];

        initStars();
        initPlayer();
        createEnemyFormation();
        updateHUD();
        showScreen('gameScreen');

        ensureAudio();
        lastTime = performance.now();
        animFrame = requestAnimationFrame(gameLoop);
    }

    function endGame() {
        gameOver = true;
        gameRunning = false;
        cancelAnimationFrame(animFrame);

        if (score > highScoreVal) {
            highScoreVal = score;
            localStorage.setItem('galagaHighScore', highScoreVal);
        }

        document.getElementById('finalScore').textContent = score;
        document.getElementById('finalWave').textContent = wave;
        document.getElementById('highScore').textContent = highScoreVal;

        setTimeout(() => showScreen('gameOverScreen'), 1000);
    }

    // Event listeners
    document.addEventListener('keydown', (e) => {
        keys[e.code] = true;
        if (e.code === 'Space') e.preventDefault();
        if (e.code === 'KeyP' && gameRunning && !gameOver) {
            paused = !paused;
        }
    });

    document.addEventListener('keyup', (e) => {
        keys[e.code] = false;
    });

    // Color picker
    document.querySelectorAll('.color-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('selected'));
            btn.classList.add('selected');
            playerColor = btn.dataset.color;
        });
    });

    document.getElementById('startBtn').addEventListener('click', startGame);
    document.getElementById('restartBtn').addEventListener('click', startGame);
    </script>
</body>
</html>
