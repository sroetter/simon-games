<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Zombie Survival</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700;900&display=swap');
*{margin:0;padding:0;box-sizing:border-box}
body{background:#0a0a0f;color:#e0e0e0;font-family:'Cinzel',serif;overflow:hidden;height:100vh;display:flex;flex-direction:column;align-items:center;justify-content:center}
#bg-particles{position:fixed;top:0;left:0;width:100%;height:100%;z-index:0;pointer-events:none}
.back-btn{position:fixed;top:18px;left:24px;color:#aaa;text-decoration:none;font-size:14px;z-index:100;font-family:'Cinzel',serif;transition:color .3s}.back-btn:hover{color:#fff}
h1{font-family:'Cinzel',serif;font-weight:900;font-size:28px;text-align:center;margin-bottom:10px;z-index:2;text-shadow:0 0 20px rgba(200,30,30,.5)}
#game-wrapper{position:relative;z-index:2}
canvas#gameCanvas{display:block;border-radius:10px;cursor:crosshair;border:1px solid rgba(255,255,255,.08);box-shadow:0 0 40px rgba(0,0,0,.6)}
#hud-top{position:absolute;top:0;left:0;right:0;display:flex;align-items:center;justify-content:space-between;padding:6px 14px;background:rgba(0,0,0,.55);backdrop-filter:blur(8px);border-radius:10px 10px 0 0;border-bottom:1px solid rgba(255,255,255,.06);font-size:13px;z-index:5;pointer-events:none}
.hp-bar-outer{width:140px;height:14px;background:rgba(255,255,255,.1);border-radius:7px;overflow:hidden;border:1px solid rgba(255,255,255,.1)}
.hp-bar-inner{height:100%;background:linear-gradient(90deg,#c0392b,#e74c3c);border-radius:7px;transition:width .2s}
#hud-bottom{position:absolute;bottom:0;left:0;right:0;display:flex;align-items:center;justify-content:space-between;padding:6px 14px;background:rgba(0,0,0,.55);backdrop-filter:blur(8px);border-radius:0 0 10px 10px;border-top:1px solid rgba(255,255,255,.06);font-size:12px;z-index:5;pointer-events:none}
#build-menu,#shop-menu{position:absolute;right:8px;top:40px;background:rgba(0,0,0,.7);backdrop-filter:blur(10px);border:1px solid rgba(255,255,255,.1);border-radius:8px;padding:8px;font-size:11px;z-index:6;display:none;pointer-events:none;min-width:200px;max-height:460px;overflow-y:auto}
#shop-menu{right:auto;left:8px}
#build-menu .bm-item{padding:3px 0;display:flex;justify-content:space-between;gap:12px}
#build-menu .bm-item.selected{color:#f1c40f}
.overlay{position:absolute;top:0;left:0;width:100%;height:100%;display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:10;border-radius:10px}
.overlay-bg{background:rgba(0,0,0,.78);backdrop-filter:blur(6px)}
.overlay h2{font-family:'Cinzel',serif;font-weight:900;font-size:36px;margin-bottom:10px;text-shadow:0 0 30px rgba(200,30,30,.6)}
.overlay p{font-size:14px;margin:4px 0;color:#ccc}
.overlay .big-stat{font-size:20px;color:#f1c40f;margin:8px 0}
.overlay button{margin-top:16px;padding:10px 32px;font-family:'Cinzel',serif;font-weight:700;font-size:15px;background:linear-gradient(135deg,#8b0000,#c0392b);color:#fff;border:none;border-radius:6px;cursor:pointer;transition:transform .2s,box-shadow .2s;box-shadow:0 4px 15px rgba(200,30,30,.3)}.overlay button:hover{transform:scale(1.05);box-shadow:0 6px 20px rgba(200,30,30,.5)}
.gold-color{color:#f1c40f}
</style>
</head>
<body>
<canvas id="bg-particles"></canvas>
<a href="index.html" class="back-btn">&larr; Back to Gallery</a>
<h1>&#x1F9DF; Zombie Survival</h1>
<div id="game-wrapper">
<canvas id="gameCanvas" width="750" height="550"></canvas>
<div id="hud-top">
  <div style="display:flex;align-items:center;gap:8px">
    <span>HP</span>
    <div class="hp-bar-outer"><div class="hp-bar-inner" id="hp-bar" style="width:100%"></div></div>
    <span id="hp-text">200</span>
  </div>
  <span id="wave-text">Wave 1</span>
  <span id="kills-text">Kills: 0</span>
  <span class="gold-color" id="gold-text">Gold: 50</span>
</div>
<div id="hud-bottom">
  <span id="weapon-text">Pistol</span>
  <span id="ammo-text">Ammo: 60</span>
  <span id="build-text"></span>
</div>
<div id="build-menu">
  <div style="margin-bottom:4px;color:#f1c40f;font-weight:700">BUILD MENU (B)</div>
  <div class="bm-item" id="bm0">[1] Barricade <span>25g</span></div>
  <div class="bm-item" id="bm1">[2] Archer Tower <span>75g</span></div>
  <div class="bm-item" id="bm2">[3] Cannon Tower <span>150g</span></div>
  <div class="bm-item" id="bm3">[4] Spike Trap <span>40g</span></div>
  <div style="margin-top:4px;color:#888;font-size:10px">Right-click to sell (50%)</div>
</div>
<div id="shop-menu" style="display:none">
  <div id="shop-content"></div>
  <div style="margin-top:4px;color:#888;font-size:10px" id="shop-info"></div>
</div>

<div class="overlay overlay-bg" id="start-screen">
  <h2>&#x1F9DF; Zombie Survival</h2>
  <p>WASD to move &bull; Mouse to aim &bull; Click to shoot</p>
  <p>B to build &bull; U to shop (Tab pages) &bull; Q/E cycle weapons &bull; P to pause</p>
  <p>V to park/enter vehicle</p>
  <p>Survive the horde!</p>
  <p style="margin-top:8px;color:#999" id="hs-start"></p>
  <button id="start-btn">START GAME</button>
  <button id="load-btn" style="display:none;margin-top:8px;background:linear-gradient(135deg,#2c3e50,#3498db)">LOAD SAVE</button>
</div>

<div class="overlay overlay-bg" id="pause-screen" style="display:none">
  <h2>PAUSED</h2>
  <p>Press P or Escape to resume</p>
  <div style="margin-top:12px;display:flex;gap:10px">
    <button id="save-btn" style="padding:8px 20px;font-family:'Cinzel',serif;font-size:13px;background:linear-gradient(135deg,#27ae60,#2ecc71);color:#fff;border:none;border-radius:6px;cursor:pointer">SAVE GAME</button>
  </div>
  <p id="save-msg" style="color:#2ecc71;font-size:12px;margin-top:6px"></p>
</div>

<div class="overlay overlay-bg" id="gameover-screen" style="display:none">
  <h2>GAME OVER</h2>
  <p class="big-stat" id="go-wave">Wave 1</p>
  <p id="go-kills">Kills: 0</p>
  <p id="go-hs" class="gold-color"></p>
  <button id="restart-btn">PLAY AGAIN</button>
</div>
</div>

<script>
(function(){
"use strict";

/* ===================== BACKGROUND PARTICLES ===================== */
const bgC = document.getElementById('bg-particles');
const bgCtx = bgC.getContext('2d');
function resizeBg(){ bgC.width = window.innerWidth; bgC.height = window.innerHeight; }
resizeBg(); window.addEventListener('resize', resizeBg);
const bgDots = [];
for(let i = 0; i < 60; i++){
  bgDots.push({ x: Math.random()*bgC.width, y: Math.random()*bgC.height, r: Math.random()*2+.5,
    vx: (Math.random()-.5)*.3, vy: (Math.random()-.5)*.3, a: Math.random()*.25+.05 });
}
function drawBg(){
  bgCtx.clearRect(0,0,bgC.width,bgC.height);
  for(const p of bgDots){
    p.x += p.vx; p.y += p.vy;
    if(p.x < 0) p.x = bgC.width; if(p.x > bgC.width) p.x = 0;
    if(p.y < 0) p.y = bgC.height; if(p.y > bgC.height) p.y = 0;
    bgCtx.beginPath(); bgCtx.arc(p.x, p.y, p.r, 0, Math.PI*2);
    bgCtx.fillStyle = `rgba(180,40,40,${p.a})`; bgCtx.fill();
  }
  requestAnimationFrame(drawBg);
}
drawBg();

/* ===================== AUDIO ENGINE ===================== */
const AudioCtor = window.AudioContext || window.webkitAudioContext;
const audio = new AudioCtor();

function noise(duration, vol){
  const n = audio.createBufferSource();
  const buf = audio.createBuffer(1, audio.sampleRate * duration, audio.sampleRate);
  const d = buf.getChannelData(0);
  for(let i = 0; i < d.length; i++) d[i] = (Math.random()*2 - 1) * Math.pow(1 - i/d.length, 2);
  n.buffer = buf;
  const g = audio.createGain(); n.connect(g); g.connect(audio.destination);
  const t = audio.currentTime;
  g.gain.setValueAtTime(vol, t);
  g.gain.exponentialRampToValueAtTime(0.001, t + duration);
  n.start(t); n.stop(t + duration);
}

function tone(type, freq, freqEnd, dur, vol){
  if(audio.state === 'suspended') audio.resume();
  const o = audio.createOscillator(), g = audio.createGain();
  o.connect(g); g.connect(audio.destination);
  const t = audio.currentTime;
  o.type = type;
  o.frequency.setValueAtTime(freq, t);
  if(freqEnd !== null) o.frequency.exponentialRampToValueAtTime(Math.max(freqEnd,1), t + dur);
  g.gain.setValueAtTime(vol, t);
  g.gain.exponentialRampToValueAtTime(0.001, t + dur);
  o.start(t); o.stop(t + dur);
}

function sfx(name){
  if(audio.state === 'suspended') audio.resume();
  const t = audio.currentTime;
  switch(name){
    case 'pistol':    tone('square',600,100,.1,.25); break;
    case 'shotgun':   tone('sawtooth',300,50,.16,.3); noise(.1,.2); break;
    case 'machinegun':tone('square',800,200,.05,.2); break;
    case 'sniper':    tone('sawtooth',900,40,.22,.35); break;
    case 'arrow':     tone('sine',1200,400,.1,.15); break;
    case 'cannon':    tone('sawtooth',120,25,.3,.35); noise(.15,.25); break;
    case 'hit':       tone('triangle',200,80,.06,.12); break;
    case 'death':     tone('sawtooth',250,25,.3,.2); break;
    case 'build':     tone('sine',400,800,.12,.2); break;
    case 'destroy':   tone('sawtooth',300,35,.25,.25); noise(.15,.15); break;
    case 'gold':{
      const o=audio.createOscillator(),g=audio.createGain();
      o.connect(g);g.connect(audio.destination);o.type='sine';
      o.frequency.setValueAtTime(1000,t);o.frequency.setValueAtTime(1400,t+.05);
      g.gain.setValueAtTime(.15,t);g.gain.exponentialRampToValueAtTime(.001,t+.15);
      o.start(t);o.stop(t+.15); break;
    }
    case 'wave':{
      const o=audio.createOscillator(),g=audio.createGain();
      o.connect(g);g.connect(audio.destination);o.type='square';
      o.frequency.setValueAtTime(200,t);o.frequency.setValueAtTime(300,t+.15);o.frequency.setValueAtTime(400,t+.3);
      g.gain.setValueAtTime(.25,t);g.gain.exponentialRampToValueAtTime(.001,t+.5);
      o.start(t);o.stop(t+.5); break;
    }
    case 'gameover':  tone('sawtooth',400,40,1.2,.3); break;
    case 'explosion': noise(.3,.4); tone('sawtooth',100,20,.3,.3); break;
    case 'crossbow':  tone('sine',600,200,.12,.2); break;
    case 'flame':     noise(.06,.15); tone('sine',200,100,.06,.1); break;
    case 'rocket':    tone('sawtooth',200,60,.3,.3); noise(.15,.2); break;
    case 'laser':     tone('sine',1800,2200,.08,.2); break;
    case 'minigun':   tone('square',900,300,.04,.18); break;
    case 'grenade':   tone('sawtooth',150,40,.2,.25); noise(.1,.15); break;
    case 'plasma':    tone('sine',400,1600,.15,.3); tone('square',300,800,.1,.15); break;
    case 'tesla':     tone('square',1200,200,.08,.2); tone('sine',800,1500,.06,.15); noise(.05,.1); break;
    case 'railgun':   tone('sawtooth',100,2000,.25,.35); noise(.2,.25); break;
    case 'freeze':    tone('sine',2000,500,.15,.2); tone('triangle',1500,800,.1,.15); break;
    case 'bfg':       tone('sawtooth',60,30,.5,.4); noise(.4,.35); tone('sine',200,800,.3,.2); break;
    case 'vbuy':      tone('sine',300,600,.2,.25); tone('sine',500,800,.15,.2); break;
    case 'vdestroy':  noise(.4,.35); tone('sawtooth',200,30,.5,.3); break;
  }
}

/* ===================== CANVAS & CONSTANTS ===================== */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const W = 750, H = 550;
const TILE = 25;
const COLS = Math.floor(W / TILE), ROWS = Math.floor(H / TILE);

/* ===================== WEAPON DEFINITIONS ===================== */
const WEAPONS = [
  { name:'Pistol',           dmg:15, rate:280,  spd:12, color:'#fff',  trail:1, snd:'pistol',     spread:0,   count:1, cost:0 },
  { name:'Shotgun',          dmg:10, rate:600,  spd:10, color:'#ffa',  trail:1, snd:'shotgun',    spread:.28, count:5, cost:150 },
  { name:'Machine Gun',      dmg:8,  rate:85,   spd:14, color:'#aff',  trail:1, snd:'machinegun', spread:.09, count:1, cost:250 },
  { name:'Sniper',           dmg:60, rate:850,  spd:20, color:'#f5f',  trail:2, snd:'sniper',     spread:0,   count:1, cost:350 },
  { name:'Crossbow',         dmg:35, rate:700,  spd:11, color:'#a86',  trail:1, snd:'crossbow',   spread:0,   count:1, cost:175 },
  { name:'Flamethrower',     dmg:4,  rate:40,   spd:7,  color:'#f80',  trail:3, snd:'flame',      spread:.25, count:3, cost:300 },
  { name:'Rocket Launcher',  dmg:80, rate:1200, spd:8,  color:'#f44',  trail:3, snd:'rocket',     spread:0,   count:1, cost:500, splash:50 },
  { name:'Laser Gun',        dmg:25, rate:180,  spd:30, color:'#0ff',  trail:1, snd:'laser',      spread:0,   count:1, cost:400 },
  { name:'Minigun',          dmg:6,  rate:50,   spd:15, color:'#ff0',  trail:1, snd:'minigun',    spread:.12, count:1, cost:600 },
  { name:'Grenade Launcher', dmg:50, rate:1000, spd:6,  color:'#4a4',  trail:2, snd:'grenade',    spread:.05, count:1, cost:500, splash:70 },
  // --- SUPER WEAPONS ---
  { name:'Plasma Cannon',   dmg:100, rate:900,  spd:16, color:'#bf00ff', trail:4, snd:'plasma',  spread:0,   count:1, cost:1000, pierce:3 },
  { name:'Tesla Gun',       dmg:30,  rate:400,  spd:18, color:'#4df',    trail:2, snd:'tesla',   spread:0,   count:1, cost:1200, chain:4 },
  { name:'Rail Gun',        dmg:200, rate:1500, spd:50, color:'#f0f',    trail:3, snd:'railgun', spread:0,   count:1, cost:1500, pierce:99 },
  { name:'Freeze Ray',      dmg:12,  rate:100,  spd:12, color:'#aef',    trail:2, snd:'freeze',  spread:.15, count:2, cost:900,  freeze:true },
  { name:'B.F.G.',          dmg:150, rate:2000, spd:5,  color:'#0f0',    trail:5, snd:'bfg',     spread:0,   count:1, cost:2000, splash:120 }
];

/* ===================== VEHICLE DEFINITIONS ===================== */
const VEHICLES = [
  { name:'Motorcycle', cost:200, hp:80,  speed:6,   dmgBonus:0,  color:'#888',    desc:'Fast & light' },
  { name:'Jeep',       cost:400, hp:200, speed:4.5, dmgBonus:3,  color:'#556B2F', desc:'Sturdy all-rounder' },
  { name:'APC',        cost:600, hp:350, speed:3.5, dmgBonus:5,  color:'#2F4F4F', desc:'Heavy armor' },
  { name:'Tank',       cost:800, hp:500, speed:2,   dmgBonus:10, color:'#4a4a2a', desc:'Ultimate firepower' }
];

/* ===================== BUILDING DEFINITIONS ===================== */
const BUILDS = [
  { name:'Barricade',    cost:25,  hp:80,  color:'#8B4513', kind:'barricade' },
  { name:'Archer Tower', cost:75,  hp:60,  color:'#228B22', kind:'archer',  range:150, rate:1000, dmg:12 },
  { name:'Cannon Tower', cost:150, hp:100, color:'#555',    kind:'cannon',  range:180, rate:2500, dmg:40, splash:60 },
  { name:'Spike Trap',   cost:40,  hp:50,  color:'#888',    kind:'spike',   dmg:8, tick:500 }
];

/* ===================== GAME STATE ===================== */
let state = 'start'; // start | playing | paused | gameover
let highScore = parseInt(localStorage.getItem('zombieSurvivalHS')) || 0;

let player, bullets, zombies, buildings, obstacles, particles, drops, towerProj;
let bloodSplats, floatTexts, fogParts;
let wave, kills, gold;
let waveTimer, waveActive, zombiesLeft, zombiesToSpawn, spawnTimer;
let buildMode, buildSel;
let shopMode, shopPage;
let hasAutoCollect, speedLevel, hpLevel;
let unlockedWeapons;
let vehicle;       // active vehicle (riding in)
let parkedVehicle; // parked vehicle on the map (exited)
let grenades, nukes; // consumable throwables
let shakeX, shakeY, shakeT, hitFlash;
let keys = {};
let mouse = { x: W/2, y: H/2, down: false, rdown: false };

function initGame(){
  player = { x:W/2, y:H/2, hp:200, maxHp:200, spd:3, weap:0, ammo:40, lastShot:0 };
  bullets=[]; zombies=[]; buildings=[]; obstacles=[]; particles=[]; drops=[]; towerProj=[];
  bloodSplats=[]; floatTexts=[]; fogParts=[];
  wave=0; kills=0; gold=50;
  waveTimer=0; waveActive=false; zombiesLeft=0; zombiesToSpawn=0; spawnTimer=0;
  buildMode=false; buildSel=0;
  shopMode=false; shopPage=0; hasAutoCollect=false; speedLevel=0; hpLevel=0;
  unlockedWeapons=new Set([0]); // start with pistol only
  vehicle=null;
  parkedVehicle=null;
  grenades=0; nukes=0;
  shakeX=0; shakeY=0; shakeT=0; hitFlash=0;
  document.getElementById('build-menu').style.display='none';
  document.getElementById('shop-menu').style.display='none';
  for(let i=0;i<30;i++){
    fogParts.push({ x:Math.random()*W, y:Math.random()*H, r:Math.random()*40+20,
      vx:(Math.random()-.5)*.4, vy:(Math.random()-.5)*.2, a:Math.random()*.06+.02 });
  }
  // spawn obstacles
  const obstTypes = ['rock','rock','crate','crate','tree','barrel'];
  for(let i=0;i<18;i++){
    let ox, oy, tries=0;
    do {
      ox = 30 + Math.random()*(W-60);
      oy = 30 + Math.random()*(H-60);
      tries++;
    } while(Math.hypot(ox-W/2, oy-H/2) < 80 && tries < 50); // keep away from spawn
    const t = obstTypes[Math.floor(Math.random()*obstTypes.length)];
    const sz = t==='tree' ? 18 : t==='rock' ? 14+Math.random()*6 : 12;
    obstacles.push({ x:ox, y:oy, type:t, size:sz });
  }
}

/* ===================== WAVE SYSTEM ===================== */
function startWave(){
  wave++;
  waveActive = true;
  const count = 4 + wave * 2;
  zombiesToSpawn = count;
  zombiesLeft = count;
  spawnTimer = 0;
  sfx('wave');
  floatTexts.push({ x:W/2, y:H/2-40, text:'WAVE '+wave, color:'#fff', size:42, life:120, vy:-.3 });
}

/* ===================== INPUT ===================== */
document.addEventListener('keydown', e => {
  keys[e.key.toLowerCase()] = true;
  if(state === 'playing'){
    if(e.key.toLowerCase() === 'b'){
      buildMode = !buildMode;
      if(buildMode) shopMode = false;
      document.getElementById('build-menu').style.display = buildMode ? 'block' : 'none';
      document.getElementById('shop-menu').style.display = 'none';
    }
    if(e.key.toLowerCase() === 'u'){
      shopMode = !shopMode;
      if(shopMode){
        buildMode = false;
        state = 'paused';
        document.getElementById('pause-screen').style.display = 'none';
        updateShopUI();
      } else {
        state = 'playing';
      }
      document.getElementById('shop-menu').style.display = shopMode ? 'block' : 'none';
      document.getElementById('build-menu').style.display = 'none';
    }
    if(e.key.toLowerCase() === 'v'){
      if(vehicle){
        // park vehicle at current position
        parkedVehicle = { ...vehicle, x:player.x, y:player.y };
        vehicle = null;
        player.spd = 3 + speedLevel * .8;
        sfx('build');
        floatTexts.push({ x:player.x, y:player.y-10, text:'PARKED VEHICLE', color:'#aaa', size:14, life:50, vy:-.8 });
      } else if(parkedVehicle && Math.hypot(player.x-parkedVehicle.x, player.y-parkedVehicle.y) < 30){
        // re-enter parked vehicle
        vehicle = { type:parkedVehicle.type, hp:parkedVehicle.hp, maxHp:parkedVehicle.maxHp, speed:parkedVehicle.speed, dmgBonus:parkedVehicle.dmgBonus, color:parkedVehicle.color };
        parkedVehicle = null;
        player.spd = vehicle.speed + speedLevel * .4;
        sfx('vbuy');
        floatTexts.push({ x:player.x, y:player.y-10, text:'ENTERED '+vehicle.type.toUpperCase()+'!', color:'#3498db', size:14, life:50, vy:-.8 });
      }
    }
    if(e.key.toLowerCase() === 'g' && grenades > 0){
      grenades--;
      sfx('explosion'); shakeT=10;
      const gx=mouse.x, gy=mouse.y;
      for(let k=zombies.length-1;k>=0;k--){
        if(Math.hypot(gx-zombies[k].x, gy-zombies[k].y)<90){
          zombies[k].hp -= 60;
          if(zombies[k].hp<=0) killZombie(k);
        }
      }
      for(let k=0;k<25;k++) particles.push({ x:gx, y:gy, vx:(Math.random()-.5)*8,
        vy:(Math.random()-.5)*8, life:30, maxLife:30, color:'#fa0', size:3+Math.random()*4 });
      floatTexts.push({ x:gx, y:gy-10, text:'GRENADE!', color:'#ff6600', size:18, life:50, vy:-.8 });
    }
    if(e.key.toLowerCase() === 'n' && nukes > 0){
      nukes--;
      sfx('bfg'); sfx('explosion'); shakeT=25;
      for(let k=zombies.length-1;k>=0;k--){
        zombies[k].hp -= 500;
        if(zombies[k].hp<=0) killZombie(k);
      }
      for(let k=0;k<60;k++) particles.push({ x:W/2+(Math.random()-.5)*W, y:H/2+(Math.random()-.5)*H,
        vx:(Math.random()-.5)*6, vy:(Math.random()-.5)*6, life:40, maxLife:40,
        color:['#f00','#ff0','#fff','#fa0'][Math.floor(Math.random()*4)], size:4+Math.random()*5 });
      hitFlash = 15;
      floatTexts.push({ x:W/2, y:H/2-20, text:'NUKE!', color:'#ff0000', size:48, life:80, vy:-.3 });
    }
    if(e.key.toLowerCase() === 'q' || e.key.toLowerCase() === 'e'){
      if(!buildMode && !shopMode){
        const owned = [...unlockedWeapons].sort((a,b)=>a-b);
        if(owned.length > 1){
          const curIdx = owned.indexOf(player.weap);
          if(e.key.toLowerCase() === 'q') player.weap = owned[(curIdx - 1 + owned.length) % owned.length];
          else player.weap = owned[(curIdx + 1) % owned.length];
        }
      }
    }
    if(e.key === 'Tab'){ e.preventDefault(); }
    if(e.key >= '1' && e.key <= '9' || e.key === '0'){
      const num = e.key === '0' ? 10 : parseInt(e.key);
      if(buildMode && num <= 4){ buildSel = num-1; }
      else if(shopMode){ buyShopItem(num-1); }
      else {
        // switch weapon (1-0 = weapon indices 0-9)
        const wi = num - 1;
        if(wi < WEAPONS.length && unlockedWeapons.has(wi)){
          player.weap = wi;
        }
      }
    }
    if(e.key.toLowerCase() === 'p' || e.key === 'Escape'){
      state = 'paused';
      shopMode = false;
      document.getElementById('shop-menu').style.display = 'none';
      document.getElementById('pause-screen').style.display = 'flex';
      e.preventDefault();
    }
  } else if(state === 'paused'){
    if(e.key.toLowerCase() === 'p' || e.key === 'Escape'){
      state = 'playing';
      shopMode = false;
      document.getElementById('shop-menu').style.display = 'none';
      document.getElementById('pause-screen').style.display = 'none';
      e.preventDefault();
    }
    if(e.key === 'Tab' && shopMode){
      e.preventDefault();
      shopPage = (shopPage + 1) % 3;
      updateShopUI();
    }
    // allow shop purchases while paused in shop
    if(e.key.toLowerCase() === 'u'){
      if(shopMode){
        shopMode = false;
        state = 'playing';
        document.getElementById('shop-menu').style.display = 'none';
      }
    }
    if(shopMode && (e.key >= '1' && e.key <= '9' || e.key === '0')){
      const num = e.key === '0' ? 10 : parseInt(e.key);
      if(e.shiftKey && shopPage === 1 && num >= 1 && num <= 5){
        // Shift+1-5 buys super weapons (indices 10-14)
        buyWeapon(9 + num);
      } else {
        buyShopItem(num-1);
      }
    }
  }
});
document.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

canvas.addEventListener('mousemove', e => {
  const r = canvas.getBoundingClientRect();
  mouse.x = (e.clientX - r.left) * (W / r.width);
  mouse.y = (e.clientY - r.top) * (H / r.height);
});
canvas.addEventListener('mousedown', e => {
  e.preventDefault();
  if(e.button === 0) mouse.down = true;
  if(e.button === 2) mouse.rdown = true;
});
canvas.addEventListener('mouseup', e => {
  if(e.button === 0) mouse.down = false;
  if(e.button === 2) mouse.rdown = false;
});
canvas.addEventListener('contextmenu', e => e.preventDefault());

/* ===================== ZOMBIE SPAWNING ===================== */
function spawnZombie(){
  const pool = ['regular'];
  if(wave >= 3) pool.push('fast');
  if(wave >= 5) pool.push('tank');
  if(wave >= 7) pool.push('exploder');
  if(wave >= 8) pool.push('spitter');
  if(wave >= 10) pool.push('boss');
  if(wave >= 30) pool.push('mega_boss');
  const type = pool[Math.floor(Math.random() * pool.length)];
  let hp, speed, size, color, bldgDmg;
  switch(type){
    case 'regular':  hp=30;  speed=.5;  size=10; color='#2ecc40'; bldgDmg=10; break;
    case 'fast':     hp=20;  speed=1.1; size=8;  color='#b5cc18'; bldgDmg=12; break;
    case 'tank':     hp=120; speed=.3;  size=16; color='#8B5E3C'; bldgDmg=25; break;
    case 'exploder': hp=40;  speed=.6;  size=11; color='#e74c3c'; bldgDmg=15; break;
    case 'spitter':   hp=35;   speed=.7;  size=9;  color='#9b59b6'; bldgDmg=8;  break;
    case 'boss':      hp=500;  speed=.2;  size=22; color='#c0392b'; bldgDmg=40; break;
    case 'mega_boss': hp=2000; speed=.15; size=30; color='#8b0000'; bldgDmg=60; break;
  }
  hp = Math.floor(hp * (1 + wave * .06));
  let x, y;
  const side = Math.floor(Math.random()*4);
  if(side===0){ x=Math.random()*W; y=-20; }
  else if(side===1){ x=W+20; y=Math.random()*H; }
  else if(side===2){ x=Math.random()*W; y=H+20; }
  else { x=-20; y=Math.random()*H; }
  zombies.push({ x, y, hp, maxHp:hp, speed, size, color, type, bldgDmg, atkTimer:0, pAtkTimer:0, lastSpike:0, frozen:0 });
}

/* ===================== PLAYER SHOOTING ===================== */
function shoot(){
  const now = performance.now();
  const w = WEAPONS[player.weap];
  if(now - player.lastShot < w.rate) return;
  if(player.ammo <= 0) return;
  player.lastShot = now;
  player.ammo--;
  sfx(w.snd);
  const ang = Math.atan2(mouse.y - player.y, mouse.x - player.x);
  const bonusDmg = vehicle ? vehicle.dmgBonus : 0;
  for(let i = 0; i < w.count; i++){
    const a = ang + (Math.random()-.5) * w.spread * 2;
    bullets.push({ x:player.x, y:player.y, vx:Math.cos(a)*w.spd, vy:Math.sin(a)*w.spd,
      dmg:w.dmg+bonusDmg, life:60, trail:w.trail, color:w.color, splash:w.splash||0,
      pierce:w.pierce||0, chain:w.chain||0, freeze:w.freeze||false });
  }
  // muzzle flash particles
  for(let i = 0; i < 5; i++){
    const a2 = ang + (Math.random()-.5)*.5;
    particles.push({ x:player.x+Math.cos(ang)*14, y:player.y+Math.sin(ang)*14,
      vx:Math.cos(a2)*3+Math.random(), vy:Math.sin(a2)*3+Math.random(),
      life:8, maxLife:8, color:'#ff0', size:3 });
  }
}

/* ===================== BUILDING ===================== */
function tryBuild(){
  const gx = Math.floor(mouse.x/TILE), gy = Math.floor(mouse.y/TILE);
  if(gx<0||gx>=COLS||gy<0||gy>=ROWS) return;
  const bt = BUILDS[buildSel];
  if(gold < bt.cost) return;
  for(const b of buildings){ if(b.gx===gx && b.gy===gy) return; }
  const cx = gx*TILE + TILE/2, cy = gy*TILE + TILE/2;
  for(const o of obstacles){ if(Math.hypot(cx-o.x, cy-o.y) < o.size+TILE*.4) return; }
  if(Math.abs(cx-player.x)<TILE && Math.abs(cy-player.y)<TILE) return;
  gold -= bt.cost;
  buildings.push({ gx, gy, x:cx, y:cy, hp:bt.hp, maxHp:bt.hp, kind:bt.kind, color:bt.color,
    name:bt.name, cost:bt.cost, lastShot:0, range:bt.range||0, rate:bt.rate||0,
    dmg:bt.dmg||0, splash:bt.splash||0, tick:bt.tick||0 });
  sfx('build');
}

function trySell(){
  const gx = Math.floor(mouse.x/TILE), gy = Math.floor(mouse.y/TILE);
  for(let i = buildings.length-1; i >= 0; i--){
    if(buildings[i].gx===gx && buildings[i].gy===gy){
      const b = buildings[i];
      gold += Math.floor(b.cost / 2);
      sfx('gold');
      for(let j=0;j<8;j++) particles.push({ x:b.x, y:b.y, vx:(Math.random()-.5)*3,
        vy:(Math.random()-.5)*3, life:20, maxLife:20, color:b.color, size:3 });
      buildings.splice(i,1);
      return;
    }
  }
}

/* ===================== KILL ZOMBIE ===================== */
function killZombie(idx){
  const z = zombies[idx];
  kills++; zombiesLeft--;
  const g = 5 + Math.floor(Math.random()*11);
  gold += g;
  sfx('death');
  sfx('gold');

  // exploder chain
  if(z.type === 'exploder'){
    sfx('explosion');
    shakeT = 10;
    for(let k=0;k<20;k++) particles.push({ x:z.x, y:z.y, vx:(Math.random()-.5)*6,
      vy:(Math.random()-.5)*6, life:25, maxLife:25, color:'#f50', size:3+Math.random()*3 });
    for(let bi=buildings.length-1;bi>=0;bi--){
      const b=buildings[bi];
      if(Math.hypot(z.x-b.x, z.y-b.y) < 60){
        b.hp -= 30;
        if(b.hp <= 0) destroyBuilding(bi);
      }
    }
  }

  // death particles
  for(let k=0;k<8;k++) particles.push({ x:z.x, y:z.y, vx:(Math.random()-.5)*3,
    vy:(Math.random()-.5)*3, life:20, maxLife:20, color:z.color, size:2+Math.random()*2 });
  bloodSplats.push({ x:z.x, y:z.y, r:5+Math.random()*6, a:.5 });

  // floating gold
  floatTexts.push({ x:z.x, y:z.y-10, text:'+'+g+' gold', color:'#f1c40f', size:13, life:50, vy:-.8 });

  // drops (no weapon drops - buy them from shop)
  const rnd = Math.random();
  if(rnd < .08){
    drops.push({ x:z.x, y:z.y, kind:'health', label:'+30 HP', color:'#2ecc71', life:600 });
  } else if(rnd < .2){
    drops.push({ x:z.x, y:z.y, kind:'ammo', label:'+20 Ammo', color:'#3498db', life:600 });
  }

  zombies.splice(idx,1);
}

function destroyBuilding(idx){
  const b = buildings[idx];
  sfx('destroy');
  for(let k=0;k<12;k++) particles.push({ x:b.x, y:b.y, vx:(Math.random()-.5)*4,
    vy:(Math.random()-.5)*4, life:25, maxLife:25, color:b.color, size:3 });
  buildings.splice(idx,1);
}

/* ===================== GAME OVER ===================== */
function gameOver(){
  state = 'gameover';
  sfx('gameover');
  if(kills > highScore){ highScore = kills; localStorage.setItem('zombieSurvivalHS', highScore); }
  document.getElementById('go-wave').textContent = 'Wave ' + wave;
  document.getElementById('go-kills').textContent = 'Kills: ' + kills;
  document.getElementById('go-hs').textContent = 'High Score: ' + highScore + ' kills';
  document.getElementById('gameover-screen').style.display = 'flex';
}

/* ===================== SHOP / UPGRADES ===================== */
function buyShopItem(idx){
  if(shopPage === 0) buyUpgrade(idx);
  else if(shopPage === 1) buyWeapon(idx);
  else if(shopPage === 2) buyVehicle(idx);
}

function buyUpgrade(idx){
  const SPEED_COST = [150, 250, 400];
  const HP_COST = [200, 350, 500];
  switch(idx){
    case 0: // auto-collect
      if(hasAutoCollect) return;
      if(gold < 250) return;
      gold -= 250;
      hasAutoCollect = true;
      sfx('build');
      floatTexts.push({ x:W/2, y:H/2-20, text:'AUTO-COLLECT!', color:'#2ecc71', size:24, life:80, vy:-.5 });
      break;
    case 1: { // speed
      if(speedLevel >= 3) return;
      const cost = SPEED_COST[speedLevel];
      if(gold < cost) return;
      gold -= cost;
      speedLevel++;
      player.spd = 3 + speedLevel * .8;
      sfx('build');
      floatTexts.push({ x:W/2, y:H/2-20, text:'SPEED UP! (Lv'+speedLevel+')', color:'#3498db', size:22, life:80, vy:-.5 });
      break;
    }
    case 2: { // max HP up
      if(hpLevel >= 3) return;
      const cost = HP_COST[hpLevel];
      if(gold < cost) return;
      gold -= cost;
      hpLevel++;
      player.maxHp = 200 + hpLevel * 50;
      player.hp = Math.min(player.hp + 50, player.maxHp);
      sfx('build');
      floatTexts.push({ x:W/2, y:H/2-20, text:'MAX HP UP! ('+player.maxHp+')', color:'#e74c3c', size:22, life:80, vy:-.5 });
      break;
    }
    case 3: // heal full
      if(player.hp >= player.maxHp) return;
      if(gold < 100) return;
      gold -= 100;
      player.hp = player.maxHp;
      sfx('gold');
      floatTexts.push({ x:player.x, y:player.y-10, text:'FULL HEAL!', color:'#2ecc71', size:16, life:50, vy:-.8 });
      break;
    case 4: // 30 ammo
      if(gold < 80) return;
      gold -= 80;
      player.ammo += 30;
      sfx('gold');
      floatTexts.push({ x:player.x, y:player.y-10, text:'+30 Ammo', color:'#3498db', size:14, life:40, vy:-.8 });
      break;
    case 5: // 100 ammo
      if(gold < 250) return;
      gold -= 250;
      player.ammo += 100;
      sfx('gold');
      floatTexts.push({ x:player.x, y:player.y-10, text:'+100 Ammo', color:'#3498db', size:14, life:40, vy:-.8 });
      break;
    case 6: // grenade
      if(gold < 120) return;
      gold -= 120;
      grenades++;
      sfx('gold');
      floatTexts.push({ x:player.x, y:player.y-10, text:'+1 Grenade', color:'#ff6600', size:14, life:40, vy:-.8 });
      break;
    case 7: // nuke
      if(gold < 800) return;
      gold -= 800;
      nukes++;
      sfx('gold');
      floatTexts.push({ x:player.x, y:player.y-10, text:'+1 Nuke!', color:'#ff0000', size:16, life:50, vy:-.8 });
      break;
    case 8: // barricade - enter build mode
      buildSel = 0; buildMode = true; shopMode = false; state = 'playing';
      document.getElementById('shop-menu').style.display = 'none';
      document.getElementById('build-menu').style.display = 'block';
      return;
    case 9: // spike trap
      buildSel = 3; buildMode = true; shopMode = false; state = 'playing';
      document.getElementById('shop-menu').style.display = 'none';
      document.getElementById('build-menu').style.display = 'block';
      return;
  }
  updateShopUI();
}

function buyWeapon(idx){
  if(idx < 0 || idx >= WEAPONS.length) return;
  const w = WEAPONS[idx];
  if(unlockedWeapons.has(idx)) return;
  if(w.cost <= 0) return; // pistol is free/already owned
  if(gold < w.cost) return;
  gold -= w.cost;
  unlockedWeapons.add(idx);
  player.weap = idx;
  player.ammo += 20;
  sfx('build');
  floatTexts.push({ x:W/2, y:H/2-20, text:'GOT '+w.name.toUpperCase()+'!', color:'#e67e22', size:22, life:80, vy:-.5 });
  updateShopUI();
}

function buyVehicle(idx){
  if(idx < 0 || idx >= VEHICLES.length) return;
  const v = VEHICLES[idx];
  if(vehicle || parkedVehicle) return; // already have a vehicle
  if(gold < v.cost) return;
  gold -= v.cost;
  vehicle = { type:v.name, hp:v.hp, maxHp:v.hp, speed:v.speed, dmgBonus:v.dmgBonus, color:v.color };
  player.spd = v.speed + speedLevel * .4;
  sfx('vbuy');
  floatTexts.push({ x:W/2, y:H/2-20, text:'ENTERED '+v.name.toUpperCase()+'!', color:'#3498db', size:22, life:80, vy:-.5 });
  // close shop and resume
  shopMode = false; state = 'playing';
  document.getElementById('shop-menu').style.display = 'none';
}

function updateShopUI(){
  const SPEED_COST = [150, 250, 400];
  const HP_COST = [200, 350, 500];
  const content = document.getElementById('shop-content');
  const pageTitles = ['Upgrades','Weapons','Vehicles'];
  let html = '<div style="margin-bottom:4px;color:#f1c40f;font-weight:700">SHOP (U) - '+pageTitles[shopPage]+'</div>';
  html += '<div style="display:flex;gap:4px;margin-bottom:6px">';
  for(let p=0;p<3;p++){
    const active = p===shopPage;
    html += '<span style="padding:2px 6px;border-radius:4px;font-size:10px;'+(active?'background:rgba(255,200,50,.2);color:#f1c40f':'color:#666')+'">'+pageTitles[p]+'</span>';
  }
  html += '</div><div style="color:#666;font-size:9px;margin-bottom:4px">Press Tab to switch page</div>';

  if(shopPage === 0){
    html += '<div style="color:#aaa;margin-bottom:2px">-- UPGRADES --</div>';
    html += '<div class="bm-item">'+(hasAutoCollect?'[1] Auto-Collect <span style="color:#2ecc71">OWNED</span>':'[1] Auto-Collect <span>250g</span>')+'</div>';
    html += '<div class="bm-item">'+(speedLevel>=3?'[2] Speed (MAX) <span style="color:#2ecc71">MAXED</span>':'[2] Speed Lv'+(speedLevel+1)+' <span>'+SPEED_COST[speedLevel]+'g</span>')+'</div>';
    html += '<div class="bm-item">'+(hpLevel>=3?'[3] Max HP (MAX) <span style="color:#2ecc71">MAXED</span>':'[3] Max HP Lv'+(hpLevel+1)+' <span>'+HP_COST[hpLevel]+'g</span>')+'</div>';
    html += '<div class="bm-item">'+(player.hp>=player.maxHp?'[4] Heal Full <span style="color:#888">FULL</span>':'[4] Heal Full <span>100g</span>')+'</div>';
    html += '<div style="color:#aaa;margin:4px 0 2px">-- SUPPLIES --</div>';
    html += '<div class="bm-item">[5] 30 Ammo <span>80g</span></div>';
    html += '<div class="bm-item">[6] 100 Ammo <span>250g</span></div>';
    html += '<div style="color:#ff6600;margin:4px 0 2px">-- THROWABLES (G/N to use) --</div>';
    html += '<div class="bm-item">[7] Grenade x1 (have:'+grenades+') <span>120g</span></div>';
    html += '<div class="bm-item">[8] Nuke x1 (have:'+nukes+') <span>800g</span></div>';
    html += '<div style="color:#aaa;margin:4px 0 2px">-- BUILDINGS --</div>';
    html += '<div class="bm-item">[9] Barricade <span>25g</span></div>';
    html += '<div class="bm-item">[0] Spike Trap <span>40g</span></div>';
  } else if(shopPage === 1){
    html += '<div style="color:#aaa;margin-bottom:2px">-- WEAPONS [1-0] --</div>';
    for(let i=0;i<10;i++){
      const w = WEAPONS[i];
      const key = i===9?'0':''+(i+1);
      const owned = unlockedWeapons.has(i);
      if(owned) html += '<div class="bm-item">['+key+'] '+w.name+' <span style="color:#2ecc71">OWNED</span></div>';
      else html += '<div class="bm-item">['+key+'] '+w.name+' <span>'+w.cost+'g</span></div>';
    }
    html += '<div style="color:#ff6600;margin:6px 0 2px">-- SUPER WEAPONS --</div>';
    for(let i=10;i<WEAPONS.length;i++){
      const w = WEAPONS[i];
      const owned = unlockedWeapons.has(i);
      const desc = w.pierce?'Pierce':w.chain?'Chain':w.freeze?'Freeze':w.splash>100?'Mega Blast':'';
      if(owned) html += '<div class="bm-item">[Shift+'+(i-9)+'] '+w.name+' <span style="color:#2ecc71">OWNED</span></div>';
      else html += '<div class="bm-item">[Shift+'+(i-9)+'] '+w.name+' ('+desc+') <span style="color:#ff6600">'+w.cost+'g</span></div>';
    }
    html += '<div style="color:#666;font-size:9px;margin-top:4px">Use Q/E to cycle all weapons</div>';
  } else if(shopPage === 2){
    if(vehicle){
      html += '<div style="color:#3498db;margin-bottom:4px">Riding: '+vehicle.type+' ('+vehicle.hp+'/'+vehicle.maxHp+' HP)</div>';
      html += '<div style="color:#888;font-size:10px;margin-bottom:4px">Press V to park vehicle</div>';
    } else if(parkedVehicle){
      html += '<div style="color:#f39c12;margin-bottom:4px">Parked: '+parkedVehicle.type+' ('+parkedVehicle.hp+'/'+parkedVehicle.maxHp+' HP)</div>';
      html += '<div style="color:#888;font-size:10px;margin-bottom:4px">Walk to it & press V to enter</div>';
    }
    const hasVehicle = vehicle || parkedVehicle;
    for(let i=0;i<VEHICLES.length;i++){
      const v = VEHICLES[i];
      const key = ''+(i+1);
      if(hasVehicle) html += '<div class="bm-item" style="opacity:.4">['+key+'] '+v.name+' <span style="color:#888">HAVE VEHICLE</span></div>';
      else html += '<div class="bm-item">['+key+'] '+v.name+' ('+v.hp+'HP, spd'+v.speed+') <span>'+v.cost+'g</span></div>';
    }
  }

  content.innerHTML = html;
  document.getElementById('shop-info').textContent = 'Gold: '+gold+' | '+WEAPONS[player.weap].name+(vehicle?' | '+vehicle.type+' '+vehicle.hp+'HP':'')+(grenades?' | G:'+grenades:'')+(nukes?' | N:'+nukes:'');
}

/* ===================== UPDATE ===================== */
function update(){
  if(state !== 'playing') return;
  const now = performance.now();

  // screen shake
  if(shakeT > 0){ shakeT--; shakeX=(Math.random()-.5)*shakeT*.5; shakeY=(Math.random()-.5)*shakeT*.5; }
  else { shakeX=0; shakeY=0; }
  if(hitFlash > 0) hitFlash--;

  // wave logic
  if(!waveActive){
    waveTimer++;
    if(waveTimer >= 300){ waveTimer=0; startWave(); }
  } else {
    if(zombiesToSpawn > 0){
      spawnTimer++;
      const rate = Math.max(10, 40 - wave*2);
      if(spawnTimer >= rate){ spawnTimer=0; spawnZombie(); zombiesToSpawn--; }
    }
    if(zombiesLeft <= 0 && zombiesToSpawn <= 0){ waveActive=false; waveTimer=0; }
  }

  // player movement
  let dx=0, dy=0;
  if(keys['w']||keys['arrowup']) dy=-1;
  if(keys['s']||keys['arrowdown']) dy=1;
  if(keys['a']||keys['arrowleft']) dx=-1;
  if(keys['d']||keys['arrowright']) dx=1;
  if(dx!==0 && dy!==0){ dx*=.707; dy*=.707; }
  const nx = player.x + dx*player.spd;
  const ny = player.y + dy*player.spd;
  let blocked = false;
  for(const b of buildings){
    if(b.kind==='spike') continue;
    if(Math.abs(nx-b.x)<TILE*.8 && Math.abs(ny-b.y)<TILE*.8){ blocked=true; break; }
  }
  if(!blocked){
    for(const o of obstacles){
      if(Math.hypot(nx-o.x, ny-o.y) < o.size+8){ blocked=true; break; }
    }
  }
  if(!blocked){
    player.x = Math.max(12, Math.min(W-12, nx));
    player.y = Math.max(12, Math.min(H-12, ny));
  }

  // shooting / building
  if(mouse.down && !buildMode) shoot();
  if(mouse.down && buildMode){ mouse.down=false; tryBuild(); }
  if(mouse.rdown && buildMode){ mouse.rdown=false; trySell(); }

  // update bullets
  for(let i=bullets.length-1; i>=0; i--){
    const b = bullets[i];
    b.x += b.vx; b.y += b.vy; b.life--;
    if(b.life<=0 || b.x<0 || b.x>W || b.y<0 || b.y>H){ bullets.splice(i,1); continue; }
    // bullet hits obstacle
    let hitObs = false;
    for(const o of obstacles){
      if(Math.hypot(b.x-o.x, b.y-o.y) < o.size){
        particles.push({ x:b.x, y:b.y, vx:(Math.random()-.5)*2, vy:(Math.random()-.5)*2, life:10, maxLife:10, color:'#888', size:2 });
        hitObs=true; break;
      }
    }
    if(hitObs){ bullets.splice(i,1); continue; }
    let hit = false;
    for(let j=zombies.length-1; j>=0; j--){
      const z = zombies[j];
      if(b.hitSet && b.hitSet.has(j)) continue; // already hit by pierce
      if(Math.hypot(b.x-z.x, b.y-z.y) < z.size+3){
        if(b.splash > 0){
          // splash damage (rocket/grenade/BFG)
          sfx('explosion'); shakeT=6;
          for(let k=zombies.length-1;k>=0;k--){
            if(Math.hypot(b.x-zombies[k].x, b.y-zombies[k].y) < b.splash){
              zombies[k].hp -= b.dmg;
              if(b.freeze && zombies[k]) zombies[k].frozen = 120;
              if(zombies[k].hp <= 0) killZombie(k);
            }
          }
          for(let k=0;k<12;k++) particles.push({ x:b.x, y:b.y, vx:(Math.random()-.5)*5,
            vy:(Math.random()-.5)*5, life:20, maxLife:20, color:b.color, size:3+Math.random()*2 });
          hit = true; break;
        }

        z.hp -= b.dmg;
        sfx('hit');
        // freeze effect
        if(b.freeze) z.frozen = 120;
        for(let k=0;k<3;k++) particles.push({ x:z.x, y:z.y, vx:(Math.random()-.5)*2,
          vy:(Math.random()-.5)*2, life:20+Math.random()*10, maxLife:30, color:b.freeze?'#aef':'#900', size:2+Math.random()*2 });
        bloodSplats.push({ x:z.x+(Math.random()-.5)*8, y:z.y+(Math.random()-.5)*8, r:3+Math.random()*4, a:.4 });

        // chain lightning (Tesla Gun)
        if(b.chain && b.chain > 0){
          let cx=z.x, cy=z.y, remaining=b.chain;
          const chained = new Set([j]);
          while(remaining > 0){
            let nearest=-1, nd=Infinity;
            for(let k=0;k<zombies.length;k++){
              if(chained.has(k)) continue;
              const d=Math.hypot(zombies[k].x-cx, zombies[k].y-cy);
              if(d<100 && d<nd){ nd=d; nearest=k; }
            }
            if(nearest<0) break;
            chained.add(nearest);
            const nz=zombies[nearest];
            nz.hp -= Math.floor(b.dmg*.7);
            // draw chain arc
            particles.push({ x:(cx+nz.x)/2, y:(cy+nz.y)/2, vx:0, vy:0, life:8, maxLife:8, color:'#4df', size:nd*.15 });
            if(nz.hp<=0) killZombie(nearest);
            cx=nz.x; cy=nz.y; remaining--;
          }
        }

        if(z.hp <= 0) killZombie(j);

        // pierce: bullet continues through
        if(b.pierce && b.pierce > 0){
          if(!b.hitSet) b.hitSet = new Set();
          b.hitSet.add(j);
          b.pierce--;
          continue; // don't break, check next zombie
        }
        hit = true; break;
      }
    }
    if(hit) bullets.splice(i,1);
  }

  // update zombies
  for(let i=zombies.length-1; i>=0; i--){
    const z = zombies[i];
    // freeze countdown
    if(z.frozen > 0) z.frozen--;
    const spdMult = z.frozen > 0 ? 0.2 : 1;
    const ang = Math.atan2(player.y-z.y, player.x-z.x);
    const mx = Math.cos(ang)*z.speed*spdMult;
    const my = Math.sin(ang)*z.speed*spdMult;
    const zx = z.x+mx, zy = z.y+my;

    // obstacle collision for zombies
    let hitObst = false;
    for(const o of obstacles){
      if(Math.hypot(zx-o.x, zy-o.y) < o.size+z.size*.5){
        // slide around obstacle
        const oa = Math.atan2(z.y-o.y, z.x-o.x);
        z.x += Math.cos(oa)*z.speed*.6;
        z.y += Math.sin(oa)*z.speed*.6;
        hitObst=true; break;
      }
    }

    // building collision
    let hitBldg = null;
    for(const b of buildings){
      if(b.kind==='spike') continue;
      if(Math.abs(zx-b.x)<TILE*.6 && Math.abs(zy-b.y)<TILE*.6){ hitBldg=b; break; }
    }
    if(hitObst){} else if(hitBldg){
      z.atkTimer++;
      if(z.atkTimer >= 30){
        z.atkTimer = 0;
        hitBldg.hp -= z.bldgDmg;
        sfx('hit');
        if(hitBldg.hp <= 0){
          const idx2 = buildings.indexOf(hitBldg);
          if(idx2 >= 0) destroyBuilding(idx2);
        }
      }
    } else {
      z.x = zx; z.y = zy;
      z.atkTimer = 0;
    }

    // spike trap
    for(const b of buildings){
      if(b.kind==='spike' && Math.abs(z.x-b.x)<TILE*.5 && Math.abs(z.y-b.y)<TILE*.5){
        if(now - z.lastSpike > b.tick){
          z.lastSpike = now;
          z.hp -= b.dmg;
          particles.push({ x:z.x, y:z.y, vx:0, vy:-1, life:15, maxLife:15, color:'#f00', size:2 });
          if(z.hp <= 0){ killZombie(i); break; }
        }
      }
    }
    if(i >= zombies.length) continue; // zombie was killed by spike

    // spitter ranged attack
    if(z.type === 'spitter'){
      const dist = Math.hypot(z.x-player.x, z.y-player.y);
      if(dist < 200 && dist > 40){
        z.pAtkTimer++;
        if(z.pAtkTimer >= 80){
          z.pAtkTimer = 0;
          const sa = Math.atan2(player.y-z.y, player.x-z.x);
          towerProj.push({ x:z.x, y:z.y, vx:Math.cos(sa)*5, vy:Math.sin(sa)*5,
            dmg:8, splash:0, life:60, kind:'acid', color:'#9b59b6', size:4, hostile:true });
          sfx('hit');
        }
      }
    }
    // mega boss: ranged attack + spawns minions
    if(z.type === 'mega_boss'){
      if(!z.spawnTimer) z.spawnTimer = 0;
      if(!z.shootTimer) z.shootTimer = 0;
      z.shootTimer++;
      z.spawnTimer++;
      // triple shot ranged attack
      if(z.shootTimer >= 50){
        z.shootTimer = 0;
        const sa = Math.atan2(player.y-z.y, player.x-z.x);
        for(let s2=-1;s2<=1;s2++){
          towerProj.push({ x:z.x, y:z.y, vx:Math.cos(sa+s2*.2)*6, vy:Math.sin(sa+s2*.2)*6,
            dmg:15, splash:0, life:80, kind:'acid', color:'#ff0000', size:5, hostile:true });
        }
        sfx('cannon');
      }
      // spawn minions every 3 seconds
      if(z.spawnTimer >= 180){
        z.spawnTimer = 0;
        for(let m=0;m<3;m++){
          const ma = Math.random()*Math.PI*2;
          const mhp = Math.floor(20*(1+wave*.06));
          zombies.push({ x:z.x+Math.cos(ma)*30, y:z.y+Math.sin(ma)*30, hp:mhp, maxHp:mhp, speed:.8, size:7, color:'#cc4444', type:'fast', bldgDmg:8, atkTimer:0, pAtkTimer:0, lastSpike:0, frozen:0 });
          zombiesLeft++;
        }
        sfx('wave');
        floatTexts.push({ x:z.x, y:z.y-20, text:'SUMMON!', color:'#ff0000', size:16, life:40, vy:-.8 });
      }
    }

    // damage player (vehicle absorbs hits first)
    if(Math.hypot(z.x-player.x, z.y-player.y) < z.size+10){
      z.pAtkTimer++;
      if(z.pAtkTimer >= 20){
        z.pAtkTimer = 0;
        hitFlash = 8;
        sfx('hit');
        if(vehicle){
          vehicle.hp -= 3;
          if(vehicle.hp <= 0){
            vehicle = null;
            player.spd = 3 + speedLevel * .8;
            sfx('vdestroy');
            floatTexts.push({ x:player.x, y:player.y-10, text:'VEHICLE DESTROYED!', color:'#ff4444', size:16, life:60, vy:-.8 });
          }
        } else {
          player.hp -= 3;
          if(player.hp <= 0){ gameOver(); return; }
        }
      }
    }

    // cleanup far off-screen
    if(z.x<-100||z.x>W+100||z.y<-100||z.y>H+100){ zombies.splice(i,1); zombiesLeft--; }
  }

  // tower AI
  for(const b of buildings){
    if(b.kind !== 'archer' && b.kind !== 'cannon') continue;
    if(now - b.lastShot < b.rate) continue;
    let nearest = null, nd = Infinity;
    for(const z of zombies){
      const d = Math.hypot(z.x-b.x, z.y-b.y);
      if(d < b.range && d < nd){ nd=d; nearest=z; }
    }
    if(nearest){
      b.lastShot = now;
      const a = Math.atan2(nearest.y-b.y, nearest.x-b.x);
      const spd = b.kind==='archer' ? 8 : 5;
      towerProj.push({ x:b.x, y:b.y, vx:Math.cos(a)*spd, vy:Math.sin(a)*spd,
        dmg:b.dmg, splash:b.splash, life:60, kind:b.kind,
        color:b.kind==='archer'?'#7CFC00':'#aaa', size:b.kind==='archer'?3:5 });
      sfx(b.kind==='archer'?'arrow':'cannon');
    }
  }

  // tower projectiles + hostile projectiles (acid)
  for(let i=towerProj.length-1; i>=0; i--){
    const p = towerProj[i];
    p.x += p.vx; p.y += p.vy; p.life--;
    if(p.life<=0||p.x<0||p.x>W||p.y<0||p.y>H){ towerProj.splice(i,1); continue; }

    // hostile projectiles (spitter acid) hit player
    if(p.hostile){
      if(Math.hypot(p.x-player.x, p.y-player.y) < 15){
        hitFlash = 6; sfx('hit');
        if(vehicle){ vehicle.hp -= p.dmg; if(vehicle.hp<=0){ vehicle=null; player.spd=3+speedLevel*.8; sfx('vdestroy'); floatTexts.push({x:player.x,y:player.y-10,text:'VEHICLE DESTROYED!',color:'#ff4444',size:16,life:60,vy:-.8}); } }
        else { player.hp -= p.dmg; if(player.hp<=0){ gameOver(); return; } }
        for(let k=0;k<5;k++) particles.push({ x:p.x, y:p.y, vx:(Math.random()-.5)*3, vy:(Math.random()-.5)*3, life:15, maxLife:15, color:p.color, size:2 });
        towerProj.splice(i,1); continue;
      }
      continue; // hostile projectiles don't hit zombies
    }

    let hitSomething = false;
    for(let j=zombies.length-1; j>=0; j--){
      const z = zombies[j];
      if(Math.hypot(p.x-z.x, p.y-z.y) < z.size+p.size){
        if(p.splash > 0){
          sfx('explosion'); shakeT=6;
          for(let k=zombies.length-1;k>=0;k--){
            if(Math.hypot(p.x-zombies[k].x, p.y-zombies[k].y) < p.splash){
              zombies[k].hp -= p.dmg;
              if(zombies[k].hp <= 0) killZombie(k);
            }
          }
          for(let k=0;k<15;k++) particles.push({ x:p.x, y:p.y, vx:(Math.random()-.5)*5,
            vy:(Math.random()-.5)*5, life:20, maxLife:20, color:'#fa0', size:3+Math.random()*2 });
        } else {
          z.hp -= p.dmg; sfx('hit');
          if(z.hp <= 0) killZombie(j);
        }
        hitSomething = true; break;
      }
    }
    if(hitSomething) towerProj.splice(i,1);
  }

  // particles
  for(let i=particles.length-1;i>=0;i--){
    const p=particles[i]; p.x+=p.vx; p.y+=p.vy; p.vx*=.95; p.vy*=.95; p.life--;
    if(p.life<=0) particles.splice(i,1);
  }

  // floating texts
  for(let i=floatTexts.length-1;i>=0;i--){
    floatTexts[i].y+=floatTexts[i].vy; floatTexts[i].life--;
    if(floatTexts[i].life<=0) floatTexts.splice(i,1);
  }

  // drops
  for(let i=drops.length-1;i>=0;i--){
    const d=drops[i]; d.life--;
    if(d.life<=0){ drops.splice(i,1); continue; }
    // auto-collect: pull drops toward player
    if(hasAutoCollect){
      const dist = Math.hypot(d.x-player.x, d.y-player.y);
      if(dist < 150 && dist > 5){
        const ang = Math.atan2(player.y-d.y, player.x-d.x);
        const pullSpd = Math.min(4, 150/dist);
        d.x += Math.cos(ang)*pullSpd;
        d.y += Math.sin(ang)*pullSpd;
      }
    }
    if(Math.hypot(d.x-player.x, d.y-player.y) < 20){
      if(d.kind==='health'){
        if(player.hp < player.maxHp) player.hp = Math.min(player.maxHp, player.hp+30);
        else if(vehicle) vehicle.hp = Math.min(vehicle.maxHp, vehicle.hp+10);
      }
      else if(d.kind==='ammo') player.ammo += 20;
      sfx('gold');
      floatTexts.push({ x:d.x, y:d.y, text:d.label, color:d.color, size:14, life:40, vy:-1 });
      drops.splice(i,1);
    }
  }

  // blood fade
  for(let i=bloodSplats.length-1;i>=0;i--){
    bloodSplats[i].a -= .0005;
    if(bloodSplats[i].a <= 0) bloodSplats.splice(i,1);
  }
  if(bloodSplats.length > 200) bloodSplats.splice(0, bloodSplats.length-200);

  // fog drift
  for(const f of fogParts){
    f.x += f.vx; f.y += f.vy;
    if(f.x<-50)f.x=W+50; if(f.x>W+50)f.x=-50;
    if(f.y<-50)f.y=H+50; if(f.y>H+50)f.y=-50;
  }

  updateHUD();
}

/* ===================== HUD ===================== */
function updateHUD(){
  const hpSource = vehicle ? vehicle : player;
  const hpMax = vehicle ? vehicle.maxHp : player.maxHp;
  const hpCur = vehicle ? vehicle.hp : player.hp;
  document.getElementById('hp-bar').style.width = (hpCur/hpMax*100)+'%';
  document.getElementById('hp-bar').style.background = vehicle ? 'linear-gradient(90deg,#2980b9,#3498db)' : 'linear-gradient(90deg,#c0392b,#e74c3c)';
  document.getElementById('hp-text').textContent = (vehicle?'[V]':'') + Math.max(0,Math.floor(hpCur)) + (vehicle?'':'/'+player.maxHp);
  document.getElementById('wave-text').textContent = 'Wave '+wave;
  document.getElementById('kills-text').textContent = 'Kills: '+kills;
  document.getElementById('gold-text').textContent = 'Gold: '+gold;
  document.getElementById('weapon-text').textContent = WEAPONS[player.weap].name;
  document.getElementById('ammo-text').textContent = 'Ammo: '+player.ammo;
  const throwInfo = (grenades>0?'[G]x'+grenades+' ':'')+(nukes>0?'[N]x'+nukes+' ':'');
  document.getElementById('build-text').textContent = buildMode ? 'BUILD MODE [B] | RClick sell' : shopMode ? 'SHOP [U] | Tab pages | 1-0 buy' : throwInfo+'[B]Build [U]Shop [Q/E]Wpn';
  for(let i=0;i<4;i++){
    document.getElementById('bm'+i).className = 'bm-item' + (i===buildSel?' selected':'');
  }
}

/* ===================== DRAW ===================== */
function draw(){
  ctx.save();
  ctx.translate(shakeX, shakeY);

  // ground
  ctx.fillStyle = '#1a1a1a';
  ctx.fillRect(0, 0, W, H);

  // blood splatters
  for(const s of bloodSplats){
    ctx.beginPath(); ctx.arc(s.x, s.y, s.r, 0, Math.PI*2);
    ctx.fillStyle = `rgba(120,0,0,${s.a})`; ctx.fill();
  }

  // fog
  for(const f of fogParts){
    ctx.beginPath(); ctx.arc(f.x, f.y, f.r, 0, Math.PI*2);
    ctx.fillStyle = `rgba(100,100,120,${f.a})`; ctx.fill();
  }

  // obstacles
  for(const o of obstacles){
    ctx.save(); ctx.translate(o.x, o.y);
    if(o.type === 'rock'){
      ctx.fillStyle = '#555';
      ctx.beginPath(); ctx.ellipse(0,2,o.size,o.size*.7,0,0,Math.PI*2); ctx.fill();
      ctx.fillStyle = '#666';
      ctx.beginPath(); ctx.ellipse(-2,-1,o.size*.7,o.size*.5,0,0,Math.PI*2); ctx.fill();
      ctx.fillStyle = '#777';
      ctx.beginPath(); ctx.ellipse(-1,-3,o.size*.3,o.size*.2,.3,0,Math.PI*2); ctx.fill();
    } else if(o.type === 'crate'){
      ctx.fillStyle = '#8B6914';
      ctx.fillRect(-o.size,-o.size,o.size*2,o.size*2);
      ctx.strokeStyle = '#5a4510'; ctx.lineWidth = 1.5;
      ctx.strokeRect(-o.size,-o.size,o.size*2,o.size*2);
      ctx.beginPath(); ctx.moveTo(-o.size,-o.size); ctx.lineTo(o.size,o.size); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(o.size,-o.size); ctx.lineTo(-o.size,o.size); ctx.stroke();
    } else if(o.type === 'tree'){
      ctx.fillStyle = '#3e2a14';
      ctx.fillRect(-3,0,6,10);
      ctx.fillStyle = '#1a5e1a';
      ctx.beginPath(); ctx.arc(0,-4,o.size*.7,0,Math.PI*2); ctx.fill();
      ctx.fillStyle = '#227722';
      ctx.beginPath(); ctx.arc(-3,-6,o.size*.4,0,Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(4,-3,o.size*.35,0,Math.PI*2); ctx.fill();
    } else if(o.type === 'barrel'){
      ctx.fillStyle = '#8B4513';
      ctx.beginPath(); ctx.ellipse(0,0,o.size,o.size*.8,0,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle = '#555'; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.ellipse(0,0,o.size,o.size*.8,0,0,Math.PI*2); ctx.stroke();
      ctx.strokeStyle = '#666'; ctx.lineWidth = 1;
      ctx.beginPath(); ctx.moveTo(-o.size*.6,0); ctx.lineTo(o.size*.6,0); ctx.stroke();
    }
    ctx.restore();
  }

  // build grid
  if(buildMode){
    ctx.strokeStyle = 'rgba(255,255,255,.06)'; ctx.lineWidth = .5;
    for(let x=0; x<=W; x+=TILE){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
    for(let y=0; y<=H; y+=TILE){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }
    const gx = Math.floor(mouse.x/TILE), gy = Math.floor(mouse.y/TILE);
    if(gx>=0 && gx<COLS && gy>=0 && gy<ROWS){
      const canBuild = gold>=BUILDS[buildSel].cost && !buildings.some(b=>b.gx===gx&&b.gy===gy);
      ctx.fillStyle = canBuild ? 'rgba(46,204,64,.15)' : 'rgba(231,76,60,.15)';
      ctx.fillRect(gx*TILE, gy*TILE, TILE, TILE);
      ctx.strokeStyle = canBuild ? 'rgba(46,204,64,.4)' : 'rgba(231,76,60,.4)';
      ctx.lineWidth = 1;
      ctx.strokeRect(gx*TILE, gy*TILE, TILE, TILE);
    }
  }

  // spike traps (under everything)
  for(const b of buildings){
    if(b.kind !== 'spike') continue;
    ctx.save(); ctx.translate(b.x, b.y);
    ctx.fillStyle = '#555';
    ctx.fillRect(-TILE/2+2, -TILE/2+2, TILE-4, TILE-4);
    ctx.fillStyle = '#bbb';
    for(let sx=-6;sx<=6;sx+=6) for(let sy=-6;sy<=6;sy+=6){
      ctx.beginPath(); ctx.moveTo(sx,sy-4); ctx.lineTo(sx-2,sy+2); ctx.lineTo(sx+2,sy+2); ctx.closePath(); ctx.fill();
    }
    ctx.restore();
    drawBldgHP(b);
  }

  // buildings
  for(const b of buildings){
    if(b.kind === 'spike') continue;
    ctx.save(); ctx.translate(b.x, b.y);
    if(b.kind === 'barricade'){
      ctx.fillStyle = b.color;
      ctx.fillRect(-TILE/2+1, -TILE/2+1, TILE-2, TILE-2);
      ctx.strokeStyle = 'rgba(0,0,0,.3)'; ctx.lineWidth = 1;
      ctx.beginPath(); ctx.moveTo(-TILE/2+3,0); ctx.lineTo(TILE/2-3,0); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(0,-TILE/2+3); ctx.lineTo(0,TILE/2-3); ctx.stroke();
    } else if(b.kind === 'archer'){
      ctx.fillStyle = '#1a5c1a';
      ctx.fillRect(-TILE/2+1, -TILE/2+1, TILE-2, TILE-2);
      ctx.fillStyle = b.color;
      ctx.beginPath(); ctx.arc(0,0,6,0,Math.PI*2); ctx.fill();
      ctx.fillStyle = '#0f0'; ctx.fillRect(-1,-8,2,6);
      if(buildMode){ ctx.strokeStyle='rgba(34,139,34,.2)'; ctx.lineWidth=1; ctx.beginPath(); ctx.arc(0,0,b.range,0,Math.PI*2); ctx.stroke(); }
    } else if(b.kind === 'cannon'){
      ctx.fillStyle = '#333';
      ctx.fillRect(-TILE/2+1, -TILE/2+1, TILE-2, TILE-2);
      ctx.fillStyle = '#666'; ctx.beginPath(); ctx.arc(0,0,7,0,Math.PI*2); ctx.fill();
      ctx.fillStyle = '#888'; ctx.beginPath(); ctx.arc(0,0,3,0,Math.PI*2); ctx.fill();
      if(buildMode){ ctx.strokeStyle='rgba(100,100,100,.2)'; ctx.lineWidth=1; ctx.beginPath(); ctx.arc(0,0,b.range,0,Math.PI*2); ctx.stroke(); }
    }
    ctx.restore();
    drawBldgHP(b);
  }

  // parked vehicle
  if(parkedVehicle){
    ctx.save(); ctx.translate(parkedVehicle.x, parkedVehicle.y);
    ctx.globalAlpha = .7;
    ctx.fillStyle = parkedVehicle.color;
    if(parkedVehicle.type === 'Motorcycle'){
      ctx.fillRect(-4,-12,8,24);
      ctx.fillStyle = '#555'; ctx.fillRect(-5,-14,10,4);
    } else if(parkedVehicle.type === 'Jeep'){
      ctx.fillRect(-10,-16,20,32);
      ctx.fillStyle = '#333';
      ctx.fillRect(-12,-12,4,8); ctx.fillRect(8,-12,4,8);
      ctx.fillRect(-12,4,4,8); ctx.fillRect(8,4,4,8);
    } else if(parkedVehicle.type === 'APC'){
      ctx.fillRect(-13,-18,26,36);
      ctx.fillStyle = '#1a3a1a';
      ctx.fillRect(-15,-14,4,10); ctx.fillRect(11,-14,4,10);
      ctx.fillRect(-15,4,4,10); ctx.fillRect(11,4,4,10);
    } else if(parkedVehicle.type === 'Tank'){
      ctx.fillStyle = '#333'; ctx.fillRect(-17,-18,6,36); ctx.fillRect(11,-18,6,36);
      ctx.fillStyle = parkedVehicle.color; ctx.fillRect(-14,-16,28,32);
      ctx.fillStyle = '#5a5a3a'; ctx.beginPath(); ctx.arc(0,-2,9,0,Math.PI*2); ctx.fill();
      ctx.fillStyle = '#777'; ctx.fillRect(-2,-22,4,16);
    }
    ctx.globalAlpha = 1;
    // HP bar
    const vhp = parkedVehicle.hp / parkedVehicle.maxHp;
    ctx.fillStyle = 'rgba(0,0,0,.5)'; ctx.fillRect(-18,-24,36,4);
    ctx.fillStyle = vhp>.5?'#3498db':vhp>.25?'#f39c12':'#e74c3c';
    ctx.fillRect(-18,-24,36*vhp,4);
    // "Press V" hint if player is near
    if(Math.hypot(player.x-parkedVehicle.x, player.y-parkedVehicle.y) < 30){
      ctx.fillStyle = '#ffd700'; ctx.font = 'bold 10px Cinzel'; ctx.textAlign = 'center';
      ctx.fillText('[V] Enter', 0, -30);
    }
    ctx.restore();
  }

  // drops
  for(const d of drops){
    const pulse = 1 + Math.sin(performance.now()*.005)*.15;
    ctx.save(); ctx.translate(d.x, d.y); ctx.scale(pulse, pulse);
    ctx.fillStyle = d.color;
    if(d.kind==='health'){ ctx.fillRect(-4,-1,8,2); ctx.fillRect(-1,-4,2,8); }
    else if(d.kind==='ammo'){ ctx.fillRect(-3,-5,6,10); ctx.fillStyle='#c0a030'; ctx.fillRect(-2,-3,4,6); }
    else { ctx.beginPath(); ctx.moveTo(0,-6); ctx.lineTo(5,3); ctx.lineTo(-5,3); ctx.closePath(); ctx.fill(); }
    ctx.restore();
  }

  // zombies
  const now2 = performance.now();
  for(const z of zombies){
    ctx.save(); ctx.translate(z.x, z.y);
    const fa = Math.atan2(player.y-z.y, player.x-z.x);
    ctx.rotate(fa + Math.PI/2);
    const s = z.size;
    const wobble = Math.sin(now2*.006 + z.x*3)*.15; // shamble wobble

    // shadow
    ctx.fillStyle = 'rgba(0,0,0,.25)';
    ctx.beginPath(); ctx.ellipse(0,2,s*.9,s*.5,0,0,Math.PI*2); ctx.fill();

    // arms (reaching forward, with wobble)
    ctx.strokeStyle = z.color; ctx.lineWidth = s*.35; ctx.lineCap = 'round';
    ctx.beginPath(); ctx.moveTo(-s*.6, -s*.2); ctx.lineTo(-s*.8+Math.sin(wobble*3)*2, -s*1.1); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(s*.6, -s*.2); ctx.lineTo(s*.8+Math.cos(wobble*3)*2, -s*1.1); ctx.stroke();

    // freeze overlay
    if(z.frozen > 0){
      ctx.fillStyle = 'rgba(150,220,255,.25)';
      ctx.beginPath(); ctx.arc(0,0,s*1.2,0,Math.PI*2); ctx.fill();
    }

    // body
    ctx.fillStyle = z.type==='tank'?'#6B4226':z.type==='exploder'?'#992222':z.type==='fast'?'#7a9918':z.type==='spitter'?'#6c3483':z.type==='mega_boss'?'#3a0505':z.type==='boss'?'#641E16':'#335533';
    ctx.beginPath(); ctx.ellipse(0,s*.15,s*.65,s*.8,wobble,0,Math.PI*2); ctx.fill();

    // torn clothing detail
    ctx.strokeStyle = z.type==='tank'?'#4a2e18':z.type==='exploder'?'#661111':z.type==='mega_boss'?'#1a0000':z.type==='boss'?'#3a0a0a':'#223322';
    ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(-s*.4,s*.3); ctx.lineTo(-s*.3,s*.7); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(s*.3,s*.2); ctx.lineTo(s*.5,s*.6); ctx.stroke();

    // head
    ctx.fillStyle = z.color;
    ctx.beginPath(); ctx.arc(0, -s*.5, s*.45, 0, Math.PI*2); ctx.fill();
    // head outline
    ctx.strokeStyle = 'rgba(0,0,0,.3)'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.arc(0, -s*.5, s*.45, 0, Math.PI*2); ctx.stroke();

    // eyes (glowing)
    ctx.fillStyle = z.type==='exploder'?'#ff4444':z.type==='spitter'?'#cc66ff':z.type==='mega_boss'?'#ff0':z.type==='boss'?'#ff0000':'#aaff00';
    ctx.shadowColor = z.type==='exploder'?'#ff0000':z.type==='spitter'?'#9933ff':z.type==='mega_boss'?'#ff0':z.type==='boss'?'#ff0000':'#88ff00'; ctx.shadowBlur = (z.type==='boss'||z.type==='mega_boss')?8:4;
    ctx.beginPath(); ctx.arc(-s*.15, -s*.55, s*.1, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(s*.15, -s*.55, s*.1, 0, Math.PI*2); ctx.fill();
    ctx.shadowBlur = 0;

    // pupils
    ctx.fillStyle = '#111';
    ctx.beginPath(); ctx.arc(-s*.15, -s*.55, s*.05, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(s*.15, -s*.55, s*.05, 0, Math.PI*2); ctx.fill();

    // mouth scar
    ctx.strokeStyle = '#300'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(-s*.15,-s*.35); ctx.lineTo(s*.1,-s*.32); ctx.stroke();

    // blood/wound detail for tanks
    if(z.type==='tank'){
      ctx.fillStyle = 'rgba(120,0,0,.5)';
      ctx.beginPath(); ctx.arc(s*.2, 0, s*.15, 0, Math.PI*2); ctx.fill();
    }
    // exploder glow
    if(z.type==='exploder'){
      ctx.fillStyle = 'rgba(255,60,0,.15)';
      ctx.beginPath(); ctx.arc(0,0,s*1.3,0,Math.PI*2); ctx.fill();
    }
    // spitter acid drool
    if(z.type==='spitter'){
      ctx.fillStyle = '#9b59b6';
      ctx.beginPath(); ctx.arc(-s*.05, -s*.25, s*.12, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = 'rgba(155,89,182,.2)';
      ctx.beginPath(); ctx.arc(0,0,s*1.1,0,Math.PI*2); ctx.fill();
    }
    // boss horns + red aura
    if(z.type==='boss'){
      ctx.fillStyle = 'rgba(200,0,0,.12)';
      ctx.beginPath(); ctx.arc(0,0,s*1.5,0,Math.PI*2); ctx.fill();
      ctx.fillStyle = '#441111';
      ctx.beginPath(); ctx.moveTo(-s*.3,-s*.85); ctx.lineTo(-s*.15,-s*1.3); ctx.lineTo(0,-s*.85); ctx.fill();
      ctx.beginPath(); ctx.moveTo(0,-s*.85); ctx.lineTo(s*.15,-s*1.3); ctx.lineTo(s*.3,-s*.85); ctx.fill();
    }
    // mega boss: huge aura, crown, pulsing glow
    if(z.type==='mega_boss'){
      const pulse = 1+Math.sin(now2*.004)*.15;
      ctx.fillStyle = 'rgba(200,0,0,'+(0.08*pulse)+')';
      ctx.beginPath(); ctx.arc(0,0,s*2,0,Math.PI*2); ctx.fill();
      ctx.fillStyle = 'rgba(255,50,0,.1)';
      ctx.beginPath(); ctx.arc(0,0,s*1.6,0,Math.PI*2); ctx.fill();
      // crown
      ctx.fillStyle = '#ffd700';
      ctx.beginPath();
      ctx.moveTo(-s*.4,-s*.9); ctx.lineTo(-s*.35,-s*1.4); ctx.lineTo(-s*.15,-s*1.1);
      ctx.lineTo(0,-s*1.5); ctx.lineTo(s*.15,-s*1.1);
      ctx.lineTo(s*.35,-s*1.4); ctx.lineTo(s*.4,-s*.9);
      ctx.closePath(); ctx.fill();
      // skull marks on body
      ctx.fillStyle = 'rgba(200,0,0,.4)';
      ctx.beginPath(); ctx.arc(-s*.2, s*.1, s*.12, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(s*.15, s*.2, s*.1, 0, Math.PI*2); ctx.fill();
    }

    ctx.rotate(-(fa + Math.PI/2)); // reset rotation for hp bar

    // hp bar
    if(z.hp < z.maxHp){
      ctx.fillStyle = 'rgba(0,0,0,.5)'; ctx.fillRect(-s, -s-8, s*2, 3);
      ctx.fillStyle = '#e74c3c'; ctx.fillRect(-s, -s-8, s*2*(z.hp/z.maxHp), 3);
    }
    ctx.restore();
  }

  // player + vehicle
  ctx.save(); ctx.translate(player.x, player.y);
  const pAng = Math.atan2(mouse.y-player.y, mouse.x-player.x);

  // draw vehicle if in one
  if(vehicle){
    ctx.save(); ctx.rotate(pAng);
    ctx.fillStyle = vehicle.color;
    if(vehicle.type === 'Motorcycle'){
      ctx.fillRect(-4,-12,8,24);
      ctx.fillStyle = '#555'; ctx.fillRect(-5,-14,10,4);
      ctx.fillStyle = '#333'; ctx.beginPath(); ctx.arc(0,-14,3,0,Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(0,12,3,0,Math.PI*2); ctx.fill();
    } else if(vehicle.type === 'Jeep'){
      ctx.fillRect(-10,-16,20,32);
      ctx.fillStyle = '#333';
      ctx.fillRect(-12,-12,4,8); ctx.fillRect(8,-12,4,8);
      ctx.fillRect(-12,4,4,8); ctx.fillRect(8,4,4,8);
      ctx.fillStyle = 'rgba(200,220,255,.3)'; ctx.fillRect(-7,-15,14,5);
    } else if(vehicle.type === 'APC'){
      ctx.fillRect(-13,-18,26,36);
      ctx.fillStyle = '#1a3a1a';
      ctx.fillRect(-15,-14,4,10); ctx.fillRect(11,-14,4,10);
      ctx.fillRect(-15,4,4,10); ctx.fillRect(11,4,4,10);
      ctx.fillStyle = '#3a5a3a'; ctx.fillRect(-8,-20,16,6);
    } else if(vehicle.type === 'Tank'){
      // tracks
      ctx.fillStyle = '#333';
      ctx.fillRect(-17,-18,6,36); ctx.fillRect(11,-18,6,36);
      // body
      ctx.fillStyle = vehicle.color;
      ctx.fillRect(-14,-16,28,32);
      // turret base
      ctx.fillStyle = '#5a5a3a';
      ctx.beginPath(); ctx.arc(0,-2,9,0,Math.PI*2); ctx.fill();
      // barrel
      ctx.fillStyle = '#777'; ctx.fillRect(-2,-24,4,16);
      // barrel tip
      ctx.fillStyle = '#999'; ctx.fillRect(-3,-26,6,3);
    }
    ctx.restore();

    // vehicle HP bar (above player)
    const vhpPct = vehicle.hp / vehicle.maxHp;
    ctx.fillStyle = 'rgba(0,0,0,.5)'; ctx.fillRect(-20,-28,40,4);
    ctx.fillStyle = vhpPct>.5?'#3498db':vhpPct>.25?'#f39c12':'#e74c3c';
    ctx.fillRect(-20,-28,40*vhpPct,4);
  }

  // player body
  ctx.fillStyle = '#3498db';
  ctx.beginPath(); ctx.arc(0,0,10,0,Math.PI*2); ctx.fill();
  ctx.strokeStyle = '#2980b9'; ctx.lineWidth = 2;
  ctx.beginPath(); ctx.arc(0,0,10,0,Math.PI*2); ctx.stroke();
  // gun barrel
  ctx.strokeStyle = '#ccc'; ctx.lineWidth = 3;
  ctx.beginPath(); ctx.moveTo(Math.cos(pAng)*8, Math.sin(pAng)*8);
  ctx.lineTo(Math.cos(pAng)*18, Math.sin(pAng)*18); ctx.stroke();
  ctx.restore();

  // bullets
  for(const b of bullets){
    ctx.save(); ctx.translate(b.x, b.y);
    ctx.fillStyle = b.color;
    ctx.beginPath(); ctx.arc(0,0,b.trail+1,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle = b.color; ctx.globalAlpha = .4; ctx.lineWidth = b.trail;
    ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(-b.vx*2,-b.vy*2); ctx.stroke();
    ctx.globalAlpha = 1;
    ctx.restore();
  }

  // tower projectiles
  for(const p of towerProj){
    ctx.save(); ctx.translate(p.x, p.y);
    ctx.fillStyle = p.color;
    if(p.kind==='cannon'){
      ctx.beginPath(); ctx.arc(0,0,p.size,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle='#666'; ctx.lineWidth=1; ctx.beginPath(); ctx.arc(0,0,p.size,0,Math.PI*2); ctx.stroke();
    } else {
      const a = Math.atan2(p.vy, p.vx);
      ctx.rotate(a);
      ctx.fillRect(-6,-1,12,2);
      ctx.beginPath(); ctx.moveTo(6,0); ctx.lineTo(3,-3); ctx.lineTo(3,3); ctx.closePath(); ctx.fill();
    }
    ctx.restore();
  }

  // particles
  for(const p of particles){
    const frac = p.life / (p.maxLife||20);
    ctx.globalAlpha = frac;
    ctx.fillStyle = p.color;
    ctx.beginPath(); ctx.arc(p.x, p.y, p.size*frac, 0, Math.PI*2); ctx.fill();
  }
  ctx.globalAlpha = 1;

  // floating texts
  for(const t of floatTexts){
    ctx.globalAlpha = Math.min(1, t.life/20);
    ctx.font = `bold ${t.size}px Cinzel`;
    ctx.textAlign = 'center';
    if(t.size > 20){
      ctx.strokeStyle = 'rgba(0,0,0,.7)'; ctx.lineWidth = 3;
      ctx.strokeText(t.text, t.x, t.y);
    }
    ctx.fillStyle = t.color;
    ctx.fillText(t.text, t.x, t.y);
  }
  ctx.globalAlpha = 1;

  // hit flash
  if(hitFlash > 0){
    ctx.fillStyle = `rgba(255,0,0,${hitFlash/20})`;
    ctx.fillRect(0,0,W,H);
  }

  // wave break countdown
  if(!waveActive && wave > 0 && state === 'playing'){
    const sec = Math.ceil((300-waveTimer)/60);
    ctx.fillStyle = 'rgba(255,255,255,.5)';
    ctx.font = '14px Cinzel'; ctx.textAlign = 'center';
    ctx.fillText('Next wave in '+sec+'s', W/2, H-30);
  }
  if(wave === 0 && state === 'playing'){
    const sec = Math.ceil((300-waveTimer)/60);
    ctx.fillStyle = 'rgba(255,255,255,.5)';
    ctx.font = '14px Cinzel'; ctx.textAlign = 'center';
    ctx.fillText('First wave in '+sec+'s', W/2, H/2);
  }

  ctx.restore();
}

function drawBldgHP(b){
  if(b.hp < b.maxHp){
    ctx.fillStyle = 'rgba(0,0,0,.5)'; ctx.fillRect(b.x-TILE/2, b.y-TILE/2-5, TILE, 3);
    ctx.fillStyle = '#2ecc71'; ctx.fillRect(b.x-TILE/2, b.y-TILE/2-5, TILE*(b.hp/b.maxHp), 3);
  }
}

/* ===================== GAME LOOP ===================== */
function gameLoop(){
  update();
  draw();
  requestAnimationFrame(gameLoop);
}

/* ===================== SAVE / LOAD ===================== */
function saveGame(){
  const data = {
    player: { x:player.x, y:player.y, hp:player.hp, maxHp:player.maxHp, spd:player.spd, weap:player.weap, ammo:player.ammo },
    wave, kills, gold, grenades, nukes,
    hasAutoCollect, speedLevel, hpLevel,
    unlockedWeapons: [...unlockedWeapons],
    vehicle: vehicle ? {...vehicle} : null,
    parkedVehicle: parkedVehicle ? {...parkedVehicle} : null,
    buildings: buildings.map(b => ({ gx:b.gx, gy:b.gy, x:b.x, y:b.y, hp:b.hp, maxHp:b.maxHp, kind:b.kind, color:b.color, name:b.name, cost:b.cost, range:b.range, rate:b.rate, dmg:b.dmg, splash:b.splash, tick:b.tick })),
    obstacles: obstacles.map(o => ({ x:o.x, y:o.y, type:o.type, size:o.size }))
  };
  localStorage.setItem('zombieSurvivalSave', JSON.stringify(data));
}

function loadGame(){
  const raw = localStorage.getItem('zombieSurvivalSave');
  if(!raw) return false;
  try {
    const data = JSON.parse(raw);
    initGame(); // reset everything first
    player.x=data.player.x; player.y=data.player.y; player.hp=data.player.hp;
    player.maxHp=data.player.maxHp; player.spd=data.player.spd;
    player.weap=data.player.weap; player.ammo=data.player.ammo;
    wave=data.wave; kills=data.kills; gold=data.gold;
    grenades=data.grenades||0; nukes=data.nukes||0;
    hasAutoCollect=data.hasAutoCollect; speedLevel=data.speedLevel; hpLevel=data.hpLevel;
    unlockedWeapons=new Set(data.unlockedWeapons);
    vehicle=data.vehicle; parkedVehicle=data.parkedVehicle;
    buildings = data.buildings.map(b => ({ ...b, lastShot:0 }));
    obstacles = data.obstacles;
    // start between waves
    waveActive=false; waveTimer=200;
    return true;
  } catch(e){ return false; }
}

function hasSave(){ return !!localStorage.getItem('zombieSurvivalSave'); }

/* ===================== START / RESTART ===================== */
function startPlaying(){
  document.getElementById('start-screen').style.display = 'none';
  document.getElementById('gameover-screen').style.display = 'none';
  state = 'playing';
  if(audio.state === 'suspended') audio.resume();
}

document.getElementById('hs-start').textContent = highScore > 0 ? 'High Score: '+highScore+' kills' : '';
if(hasSave()) document.getElementById('load-btn').style.display = 'inline-block';

document.getElementById('start-btn').addEventListener('click', () => {
  initGame();
  startPlaying();
});

document.getElementById('load-btn').addEventListener('click', () => {
  if(loadGame()){
    startPlaying();
    floatTexts.push({ x:W/2, y:H/2-20, text:'GAME LOADED!', color:'#2ecc71', size:24, life:80, vy:-.5 });
  }
});

document.getElementById('save-btn').addEventListener('click', () => {
  saveGame();
  document.getElementById('save-msg').textContent = 'Game saved! (Wave '+wave+', '+kills+' kills)';
  sfx('gold');
  setTimeout(() => { document.getElementById('save-msg').textContent = ''; }, 3000);
});

document.getElementById('restart-btn').addEventListener('click', () => {
  initGame();
  startPlaying();
});

// Auto-load save on page open, or show start screen
if(hasSave()){
  loadGame();
  startPlaying();
  floatTexts.push({ x:W/2, y:H/2-20, text:'GAME LOADED!', color:'#2ecc71', size:24, life:80, vy:-.5 });
} else {
  initGame();
}
gameLoop();

})();
</script>
</body>
</html>
