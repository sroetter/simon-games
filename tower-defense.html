<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tower Defense - Simon's Game Gallery</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700;900&display=swap');
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0e1a;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            color: white;
            overflow-x: hidden;
        }
        #bgCanvas {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 0;
            pointer-events: none;
        }
        .header {
            text-align: center;
            padding: 15px;
            position: relative;
            z-index: 1;
        }
        .header h1 {
            font-family: 'Cinzel', serif;
            font-size: 36px;
            font-weight: 900;
            background: linear-gradient(180deg, #6db3f8 0%, #2a6dd4 40%, #c8a2ff 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            filter: drop-shadow(0 0 20px rgba(80,140,255,0.3));
        }
        .back-btn {
            position: absolute;
            top: 15px;
            left: 15px;
            text-decoration: none;
            color: #7ea8e0;
            background: rgba(10,15,40,0.8);
            border: 1px solid rgba(100,150,255,0.2);
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.3s;
            z-index: 10;
        }
        .back-btn:hover { background: rgba(30,60,150,0.5); border-color: rgba(100,150,255,0.5); color: white; }

        .controls-bar {
            display: flex;
            gap: 8px;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
            padding: 4px 10px;
            position: relative;
            z-index: 1;
        }
        .music-btn {
            background: rgba(30,50,100,0.5);
            border: 1px solid rgba(80,130,255,0.15);
            border-radius: 4px;
            color: #7ea8e0;
            padding: 3px 10px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s;
        }
        .music-btn:hover { background: rgba(40,70,160,0.5); }
        .music-btn.active { border-color: #4a8ef5; color: #6db3f8; background: rgba(40,80,200,0.3); }
        .vol-slider {
            -webkit-appearance: none;
            width: 50px; height: 4px;
            background: rgba(80,130,255,0.2);
            border-radius: 2px;
            outline: none;
        }
        .vol-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 10px; height: 10px;
            background: #4a8ef5;
            border-radius: 50%;
            cursor: pointer;
        }
        .save-btn {
            background: linear-gradient(135deg, #1a4a2a, #2a7a3a);
            border: 1px solid rgba(50,200,80,0.3);
            border-radius: 5px;
            color: #90ffb0;
            padding: 3px 12px;
            cursor: pointer;
            font-size: 11px;
            font-weight: bold;
            transition: all 0.2s;
        }
        .save-btn:hover { box-shadow: 0 0 10px rgba(50,200,80,0.2); }
        .save-btn.load { background: linear-gradient(135deg, #1a3a6a, #2a5a9a); border-color: rgba(60,140,255,0.3); color: #90c0ff; }
        .save-msg { font-size: 10px; color: #2ecc71; opacity: 0; transition: opacity 0.3s; }
        .save-msg.show { opacity: 1; }

        .game-area {
            display: flex;
            gap: 15px;
            align-items: flex-start;
            flex-wrap: wrap;
            justify-content: center;
            position: relative;
            z-index: 1;
        }
        canvas#game {
            border: 2px solid rgba(80,130,255,0.2);
            border-radius: 10px;
            cursor: crosshair;
            background: #2d5a1e;
            box-shadow: 0 0 30px rgba(40,100,30,0.2);
        }
        .sidebar {
            background: linear-gradient(170deg, rgba(15,22,50,0.95), rgba(10,15,35,0.95));
            border: 1px solid rgba(80,130,255,0.12);
            border-radius: 10px;
            padding: 15px;
            width: 200px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 30px rgba(0,0,0,0.4);
        }
        .stats {
            display: flex;
            flex-direction: column;
            gap: 6px;
            font-size: 16px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(80,130,255,0.15);
        }
        .stats span { display: flex; justify-content: space-between; }
        .stats .value { font-weight: bold; color: #6db3f8; }
        .tower-shop { display: flex; flex-direction: column; gap: 8px; }
        .tower-shop h3 {
            font-family: 'Cinzel', serif;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: #556;
        }
        .tower-btn {
            background: linear-gradient(135deg, rgba(20,35,70,0.6), rgba(15,25,55,0.5));
            border: 1px solid rgba(80,130,255,0.1);
            border-radius: 8px;
            padding: 10px;
            color: white;
            cursor: pointer;
            text-align: left;
            transition: all 0.2s;
            font-size: 13px;
        }
        .tower-btn:hover { background: rgba(30,60,140,0.5); border-color: rgba(80,140,255,0.3); }
        .tower-btn.selected { border-color: #4a8ef5; background: rgba(40,80,200,0.3); box-shadow: 0 0 12px rgba(70,130,255,0.2); }
        .tower-btn.too-expensive { opacity: 0.3; cursor: not-allowed; }
        .tower-btn .tower-name { font-weight: bold; font-size: 14px; color: #8db8f0; }
        .tower-btn .tower-cost { color: #6db3f8; }
        .tower-btn .tower-desc { color: #556; font-size: 11px; margin-top: 3px; }
        .controls { display: flex; flex-direction: column; gap: 6px; padding-top: 10px; border-top: 1px solid rgba(80,130,255,0.15); }
        .ctrl-btn {
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 8px;
            padding: 10px;
            color: white;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.2s;
        }
        .ctrl-btn:hover { filter: brightness(1.15); }
        .ctrl-btn.start { background: linear-gradient(135deg, #1a5c30, #22763e); border-color: rgba(40,180,80,0.3); }
        .ctrl-btn.speed { background: linear-gradient(135deg, #1a3d6e, #2255a0); border-color: rgba(60,130,255,0.3); }
        .upgrade-panel {
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 10px;
            font-size: 13px;
            display: none;
            border: 1px solid rgba(80,130,255,0.1);
        }
        .upgrade-panel h4 { color: #6db3f8; margin-bottom: 6px; }
        .upgrade-panel .upgrade-btn {
            background: linear-gradient(135deg, #4a1a7a, #6a2aaa);
            border: 1px solid rgba(160,80,255,0.3);
            border-radius: 6px;
            padding: 6px 10px;
            color: #d0b0ff;
            cursor: pointer;
            font-size: 12px;
            margin-top: 4px;
            width: 100%;
        }
        .upgrade-panel .sell-btn {
            background: linear-gradient(135deg, #8b1a1a, #b02020);
            border: 1px solid rgba(220,60,60,0.3);
            border-radius: 6px;
            padding: 6px 10px;
            color: #ffaaaa;
            cursor: pointer;
            font-size: 12px;
            margin-top: 4px;
            width: 100%;
        }
        .overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(5,8,20,0.9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 100;
            backdrop-filter: blur(8px);
        }
        .overlay.show { display: flex; }
        .overlay-box {
            background: linear-gradient(170deg, rgba(15,22,50,0.98), rgba(10,15,35,0.98));
            border: 1px solid rgba(80,130,255,0.2);
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0,0,0,0.6);
        }
        .overlay-box h2 { font-family: 'Cinzel', serif; font-size: 36px; margin-bottom: 15px; color: #6db3f8; }
        .overlay-box p { color: #aaa; margin-bottom: 20px; font-size: 18px; }
        .overlay-box button {
            background: linear-gradient(135deg, #1a5c30, #22763e);
            border: 1px solid rgba(40,180,80,0.3);
            border-radius: 10px;
            padding: 12px 30px;
            color: white;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
        }
        /* Save Gallery */
        .save-gallery {
            max-width: 700px;
            width: 90vw;
        }
        .save-gallery h2 {
            font-family: 'Cinzel', serif;
            font-size: 28px;
            color: #6db3f8;
            margin-bottom: 10px;
        }
        .save-gallery .save-hint {
            color: #667;
            font-size: 13px;
            margin-bottom: 15px;
        }
        .save-gallery .save-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(190px, 1fr));
            gap: 12px;
            max-height: 55vh;
            overflow-y: auto;
            padding: 5px;
        }
        .save-card {
            background: linear-gradient(135deg, rgba(20,35,70,0.8), rgba(15,25,55,0.8));
            border: 1px solid rgba(80,130,255,0.15);
            border-radius: 10px;
            padding: 10px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: left;
        }
        .save-card:hover {
            border-color: #4a8ef5;
            box-shadow: 0 0 15px rgba(70,130,255,0.2);
            transform: translateY(-3px);
        }
        .save-card img {
            width: 100%;
            border-radius: 6px;
            margin-bottom: 8px;
            border: 1px solid rgba(80,130,255,0.1);
        }
        .save-card .save-name {
            font-weight: bold;
            color: #8db8f0;
            font-size: 13px;
            margin-bottom: 3px;
        }
        .save-card .save-details {
            color: #556;
            font-size: 11px;
            line-height: 1.4;
        }
        .save-card .save-delete {
            background: rgba(180,40,40,0.3);
            border: 1px solid rgba(220,60,60,0.3);
            border-radius: 4px;
            color: #ff8888;
            font-size: 10px;
            padding: 2px 8px;
            cursor: pointer;
            float: right;
            margin-top: 4px;
        }
        .save-card .save-delete:hover { background: rgba(200,50,50,0.5); }
        .save-gallery .close-btn {
            margin-top: 15px;
            background: rgba(40,50,80,0.5);
            border: 1px solid rgba(100,150,255,0.2);
            border-radius: 8px;
            padding: 8px 25px;
            color: #7ea8e0;
            cursor: pointer;
            font-size: 14px;
        }
        .save-gallery .close-btn:hover { background: rgba(50,70,120,0.5); }
        .save-gallery .no-saves {
            color: #556;
            font-style: italic;
            padding: 40px 0;
        }
    </style>
</head>
<body>
    <canvas id="bgCanvas"></canvas>
    <a href="index.html" class="back-btn">‚Üê Back to Gallery</a>
    <div class="header">
        <h1>üè∞ Tower Defense</h1>
    </div>

    <div class="controls-bar">
        <span style="font-size:11px;color:#556;">üéµ</span>
        <button class="music-btn active" onclick="setTrack('kingdom')" data-track="kingdom">Kingdom</button>
        <button class="music-btn" onclick="setTrack('battle')" data-track="battle">Battle</button>
        <button class="music-btn" onclick="setTrack('peace')" data-track="peace">Peace</button>
        <button class="music-btn" onclick="setTrack('off')" data-track="off">Off</button>
        <input type="range" class="vol-slider" min="0" max="100" value="30" oninput="setVolume(this.value)">
        <span style="color:#334;margin:0 4px;">|</span>
        <button class="save-btn" onclick="saveGame()">üíæ Save</button>
        <button class="save-btn load" onclick="loadGame()">üìÇ Load</button>
        <span class="save-msg" id="saveMsg"></span>
    </div>

    <div class="game-area">
        <canvas id="game" width="700" height="500"></canvas>
        <div class="sidebar">
            <div class="stats">
                <span>‚ù§Ô∏è Lives <span class="value" id="lives">20</span></span>
                <span>üí∞ Gold <span class="value" id="gold">100</span></span>
                <span>üåä Wave <span class="value" id="wave">0</span></span>
                <span>üíÄ Kills <span class="value" id="kills">0</span></span>
            </div>
            <div class="tower-shop">
                <h3>üîß Towers</h3>
                <button class="tower-btn" data-tower="archer" onclick="selectTower('archer')">
                    <div class="tower-name">üèπ Archer</div>
                    <div class="tower-cost">Cost: 25g</div>
                    <div class="tower-desc">Fast attack, medium range</div>
                </button>
                <button class="tower-btn" data-tower="cannon" onclick="selectTower('cannon')">
                    <div class="tower-name">üí£ Cannon</div>
                    <div class="tower-cost">Cost: 50g</div>
                    <div class="tower-desc">Splash damage, slow fire</div>
                </button>
                <button class="tower-btn" data-tower="frost" onclick="selectTower('frost')">
                    <div class="tower-name">‚ùÑÔ∏è Frost</div>
                    <div class="tower-cost">Cost: 35g</div>
                    <div class="tower-desc">Slows enemies down</div>
                </button>
                <button class="tower-btn" data-tower="lightning" onclick="selectTower('lightning')">
                    <div class="tower-name">‚ö° Lightning</div>
                    <div class="tower-cost">Cost: 75g</div>
                    <div class="tower-desc">Chain damage, long range</div>
                </button>
                <button class="tower-btn" data-tower="inferno" onclick="selectTower('inferno')">
                    <div class="tower-name">üî• Inferno</div>
                    <div class="tower-cost">Cost: 120g</div>
                    <div class="tower-desc">Huge splash, burns area</div>
                </button>
                <button class="tower-btn" data-tower="sniper" onclick="selectTower('sniper')">
                    <div class="tower-name">üéØ Sniper</div>
                    <div class="tower-cost">Cost: 150g</div>
                    <div class="tower-desc">Massive damage, huge range</div>
                </button>
                <button class="tower-btn" data-tower="poison" onclick="selectTower('poison')">
                    <div class="tower-name">‚ò†Ô∏è Poison</div>
                    <div class="tower-cost">Cost: 100g</div>
                    <div class="tower-desc">AoE poison + slow, DOT</div>
                </button>
                <button class="tower-btn" data-tower="tesla" onclick="selectTower('tesla')">
                    <div class="tower-name">üåÄ Tesla</div>
                    <div class="tower-cost">Cost: 200g</div>
                    <div class="tower-desc">Chain 5 targets + slow</div>
                </button>
            </div>
            <div class="upgrade-panel" id="upgradePanel">
                <h4 id="upgradeName">Tower Info</h4>
                <div id="upgradeInfo"></div>
                <button class="upgrade-btn" id="upgradeBtn" onclick="upgradeTower()">Upgrade</button>
                <button class="sell-btn" onclick="sellTower()">Sell</button>
            </div>
            <div class="controls">
                <button class="ctrl-btn start" id="waveBtn" onclick="startWave()">Start Wave 1</button>
                <button class="ctrl-btn speed" onclick="toggleSpeed()">Speed: 1x</button>
            </div>
        </div>
    </div>

    <div class="overlay" id="gameOverOverlay">
        <div class="overlay-box">
            <h2>üíÄ Game Over</h2>
            <p>You survived <span id="finalWave">0</span> waves and got <span id="finalKills">0</span> kills!</p>
            <button onclick="restartGame()">Play Again</button>
        </div>
    </div>
    <div class="overlay" id="winOverlay">
        <div class="overlay-box">
            <h2>üéâ Victory!</h2>
            <p>You defeated all 30 waves with <span id="winLives">0</span> lives remaining!</p>
            <button onclick="restartGame()">Play Again</button>
        </div>
    </div>

    <div class="overlay" id="loadOverlay">
        <div class="overlay-box save-gallery">
            <h2>üìÇ Saved Games</h2>
            <p class="save-hint">Click a save to load it</p>
            <div class="save-list" id="saveList"></div>
            <button class="close-btn" onclick="closeLoadGallery()">Close</button>
        </div>
    </div>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;
const TILE = 25;
const COLS = W / TILE, ROWS = H / TILE;

let gold, lives, waveNum, kills, towers, enemies, projectiles, particles;
let waveActive, waveEnemiesLeft, spawnTimer, gameOver, gameSpeed;
let selectedTowerType, selectedTower, hoveredCell;
let path, pathSet;

const TOWER_TYPES = {
    archer: { name: 'üèπ Archer', cost: 25, range: 100, damage: 8, fireRate: 30, color: '#2ecc71', splash: 0, slow: 0, chain: 0, poison: 0 },
    cannon: { name: 'üí£ Cannon', cost: 50, range: 90, damage: 25, fireRate: 60, color: '#e74c3c', splash: 40, slow: 0, chain: 0, poison: 0 },
    frost:  { name: '‚ùÑÔ∏è Frost',  cost: 35, range: 90, damage: 5,  fireRate: 25, color: '#3498db', splash: 0, slow: 0.5, chain: 0, poison: 0 },
    lightning: { name: '‚ö° Lightning', cost: 75, range: 130, damage: 15, fireRate: 45, color: '#f1c40f', splash: 0, slow: 0, chain: 3, poison: 0 },
    inferno: { name: 'üî• Inferno', cost: 120, range: 80, damage: 40, fireRate: 50, color: '#ff6b35', splash: 55, slow: 0, chain: 0, poison: 0 },
    sniper:  { name: 'üéØ Sniper',  cost: 150, range: 200, damage: 80, fireRate: 90, color: '#1abc9c', splash: 0, slow: 0, chain: 0, poison: 0 },
    poison:  { name: '‚ò†Ô∏è Poison',  cost: 100, range: 95, damage: 3, fireRate: 20, color: '#27ae60', splash: 35, slow: 0.3, chain: 0, poison: 4 },
    tesla:   { name: 'üåÄ Tesla',   cost: 200, range: 110, damage: 30, fireRate: 35, color: '#9b59b6', splash: 0, slow: 0.2, chain: 5, poison: 0 }
};

const UPGRADE_MULT = { damage: 1.4, range: 1.15, fireRate: 0.85 };

function buildPath() {
    const pts = [
        [0,4],[3,4],[3,2],[7,2],[7,6],[4,6],[4,10],[8,10],[8,8],[12,8],
        [12,12],[9,12],[9,16],[14,16],[14,12],[18,12],[18,8],[22,8],[22,4],
        [26,4],[26,10],[22,10],[22,16],[18,16],[18,19],[28,19]
    ];
    path = [];
    for (let i = 0; i < pts.length - 1; i++) {
        const [x1,y1] = pts[i], [x2,y2] = pts[i+1];
        const dx = Math.sign(x2-x1), dy = Math.sign(y2-y1);
        let cx = x1, cy = y1;
        while (cx !== x2 || cy !== y2) { path.push([cx, cy]); cx += dx; cy += dy; }
    }
    path.push(pts[pts.length-1]);
    pathSet = new Set(path.map(p => p[0]+','+p[1]));
}

function isPath(col, row) { return pathSet.has(col+','+row); }

function initGame() {
    gold = 100; lives = 20; waveNum = 0; kills = 0;
    towers = []; enemies = []; projectiles = []; particles = [];
    waveActive = false; waveEnemiesLeft = 0; spawnTimer = 0;
    gameOver = false; gameSpeed = 1;
    selectedTowerType = null; selectedTower = null; hoveredCell = null;
    buildPath();
    document.getElementById('gameOverOverlay').classList.remove('show');
    document.getElementById('winOverlay').classList.remove('show');
    updateUI();
}

function updateUI() {
    document.getElementById('lives').textContent = lives;
    document.getElementById('gold').textContent = gold;
    document.getElementById('wave').textContent = waveNum;
    document.getElementById('kills').textContent = kills;
    document.getElementById('waveBtn').textContent = waveActive ? 'Wave in progress...' : `Start Wave ${waveNum+1}`;
    document.getElementById('waveBtn').disabled = waveActive;
    document.querySelectorAll('.tower-btn').forEach(btn => {
        const type = btn.dataset.tower;
        btn.classList.toggle('too-expensive', gold < TOWER_TYPES[type].cost);
    });
}

function selectTower(type) {
    if (gold < TOWER_TYPES[type].cost) return;
    selectedTowerType = selectedTowerType === type ? null : type;
    selectedTower = null;
    document.getElementById('upgradePanel').style.display = 'none';
    document.querySelectorAll('.tower-btn').forEach(btn => btn.classList.toggle('selected', btn.dataset.tower === selectedTowerType));
}

function getWaveEnemies(wave) {
    const count = 6 + wave * 3;
    const hp = 30 + wave * 25 + Math.floor(wave * wave * 0.8);
    const speed = 1.1 + Math.min(wave * 0.07, 2.0);
    const reward = 5 + Math.floor(wave / 2);
    let types = ['normal'];
    if (wave >= 2) types.push('fast');
    if (wave >= 4) types.push('tank');
    if (wave >= 6) types.push('boss');
    if (wave >= 10) types.push('swarm');
    if (wave >= 15) types.push('juggernaut');
    if (wave >= 20) types.push('demon');
    return { count, hp, speed, reward, types };
}

function spawnEnemy(waveInfo) {
    const type = waveInfo.types[Math.floor(Math.random() * waveInfo.types.length)];
    let hp = waveInfo.hp, speed = waveInfo.speed, size = 8, color = '#e74c3c', reward = waveInfo.reward;
    if (type === 'fast') { hp *= 0.6; speed *= 1.6; size = 6; color = '#f39c12'; reward = Math.floor(reward * 0.8); }
    if (type === 'tank') { hp *= 2.5; speed *= 0.6; size = 12; color = '#8e44ad'; reward = Math.floor(reward * 1.5); }
    if (type === 'boss') { hp *= 5; speed *= 0.4; size = 15; color = '#c0392b'; reward = Math.floor(reward * 3); }
    if (type === 'swarm') { hp *= 0.3; speed *= 2.0; size = 5; color = '#e67e22'; reward = Math.floor(reward * 0.5); }
    if (type === 'juggernaut') { hp *= 8; speed *= 0.3; size = 16; color = '#2c3e50'; reward = Math.floor(reward * 4); }
    if (type === 'demon') { hp *= 6; speed *= 0.8; size = 14; color = '#8b0000'; reward = Math.floor(reward * 5); }
    enemies.push({ x: path[0][0]*TILE+TILE/2, y: path[0][1]*TILE+TILE/2, pathIdx: 0, hp, maxHp: hp, speed, size, color, reward, type, slowTimer: 0, slowAmount: 0, poisonTimer: 0, poisonDmg: 0 });
}

function startWave() {
    if (waveActive || gameOver) return;
    waveNum++;
    waveActive = true;
    const info = getWaveEnemies(waveNum);
    waveEnemiesLeft = info.count;
    spawnTimer = 0;
    updateUI();
}

function toggleSpeed() {
    gameSpeed = gameSpeed === 1 ? 2 : gameSpeed === 2 ? 3 : 1;
    document.querySelector('.speed').textContent = `Speed: ${gameSpeed}x`;
}

canvas.addEventListener('mousemove', e => {
    const rect = canvas.getBoundingClientRect();
    hoveredCell = { col: Math.floor((e.clientX-rect.left)/TILE), row: Math.floor((e.clientY-rect.top)/TILE), mx: e.clientX-rect.left, my: e.clientY-rect.top };
});
canvas.addEventListener('mouseleave', () => { hoveredCell = null; });

canvas.addEventListener('click', e => {
    const rect = canvas.getBoundingClientRect();
    const col = Math.floor((e.clientX-rect.left)/TILE), row = Math.floor((e.clientY-rect.top)/TILE);
    const clickedTower = towers.find(t => t.col === col && t.row === row);
    if (clickedTower && !selectedTowerType) { selectedTower = clickedTower; showUpgradePanel(clickedTower); return; }
    if (!selectedTowerType) { selectedTower = null; document.getElementById('upgradePanel').style.display = 'none'; return; }
    if (isPath(col, row) || towers.find(t => t.col === col && t.row === row)) return;
    if (col < 0 || col >= COLS || row < 0 || row >= ROWS) return;
    const type = TOWER_TYPES[selectedTowerType];
    if (gold < type.cost) return;
    gold -= type.cost;
    towers.push({ col, row, x: col*TILE+TILE/2, y: row*TILE+TILE/2, type: selectedTowerType, level: 1, range: type.range, damage: type.damage, fireRate: type.fireRate, splash: type.splash, slow: type.slow, chain: type.chain, poison: type.poison, color: type.color, cooldown: 0, totalCost: type.cost });
    updateUI();
});

function showUpgradePanel(tower) {
    const panel = document.getElementById('upgradePanel');
    const cost = Math.floor(tower.totalCost * 0.6);
    panel.style.display = 'block';
    document.getElementById('upgradeName').textContent = TOWER_TYPES[tower.type].name + ` Lv${tower.level}`;
    document.getElementById('upgradeInfo').innerHTML = `DMG: ${Math.floor(tower.damage)} | Range: ${Math.floor(tower.range)}<br>Sell: ${Math.floor(tower.totalCost * 0.6)}g`;
    const btn = document.getElementById('upgradeBtn');
    if (tower.level >= 5) { btn.textContent = 'MAX LEVEL'; btn.disabled = true; }
    else { btn.textContent = `Upgrade (${cost}g)`; btn.disabled = gold < cost; }
}

function upgradeTower() {
    if (!selectedTower || selectedTower.level >= 5) return;
    const cost = Math.floor(selectedTower.totalCost * 0.6);
    if (gold < cost) return;
    gold -= cost;
    selectedTower.level++;
    selectedTower.damage *= UPGRADE_MULT.damage;
    selectedTower.range *= UPGRADE_MULT.range;
    selectedTower.fireRate *= UPGRADE_MULT.fireRate;
    selectedTower.totalCost += cost;
    showUpgradePanel(selectedTower);
    updateUI();
}

function sellTower() {
    if (!selectedTower) return;
    gold += Math.floor(selectedTower.totalCost * 0.6);
    towers = towers.filter(t => t !== selectedTower);
    selectedTower = null;
    document.getElementById('upgradePanel').style.display = 'none';
    updateUI();
}

function dist(a, b) { return Math.hypot(a.x - b.x, a.y - b.y); }

function addParticles(x, y, color, count) {
    for (let i = 0; i < count; i++) {
        particles.push({ x, y, vx: (Math.random()-0.5)*3, vy: (Math.random()-0.5)*3, life: 15+Math.random()*10, color, size: 2+Math.random()*2 });
    }
}

function update() {
    if (gameOver) return;
    for (let s = 0; s < gameSpeed; s++) {
        if (waveActive && waveEnemiesLeft > 0) {
            spawnTimer--;
            if (spawnTimer <= 0) { spawnEnemy(getWaveEnemies(waveNum)); waveEnemiesLeft--; spawnTimer = 30; }
        }
        for (let i = enemies.length - 1; i >= 0; i--) {
            const e = enemies[i];
            // Poison tick damage
            if (e.poisonTimer > 0) { e.hp -= e.poisonDmg; e.poisonTimer--; if (i % 5 === 0) addParticles(e.x, e.y, '#27ae60', 1); }
            let spd = e.speed;
            if (e.slowTimer > 0) { spd *= (1 - e.slowAmount); e.slowTimer--; }
            const target = path[e.pathIdx + 1];
            if (!target) { lives--; enemies.splice(i, 1); if (lives <= 0) { endGame(false); return; } continue; }
            const tx = target[0]*TILE+TILE/2, ty = target[1]*TILE+TILE/2;
            const dx = tx-e.x, dy = ty-e.y, d = Math.hypot(dx, dy);
            if (d < spd*2) { e.x = tx; e.y = ty; e.pathIdx++; }
            else { e.x += (dx/d)*spd; e.y += (dy/d)*spd; }
        }
        towers.forEach(t => {
            if (t.cooldown > 0) { t.cooldown--; return; }
            const target = enemies.find(e => dist(t, e) <= t.range);
            if (!target) return;
            t.cooldown = Math.floor(t.fireRate);
            if (t.chain > 0) {
                let dmgTargets = [target]; let last = target;
                for (let c = 0; c < t.chain; c++) { const next = enemies.find(e => !dmgTargets.includes(e) && dist(last, e) < 80); if (next) { dmgTargets.push(next); last = next; } }
                dmgTargets.forEach(e => { e.hp -= t.damage; addParticles(e.x, e.y, '#f1c40f', 3); });
                projectiles.push({ type: 'chain', targets: dmgTargets.map(e => ({x:e.x,y:e.y})), timer: 8, color: t.color });
            } else {
                projectiles.push({ type: 'bullet', x: t.x, y: t.y, target, speed: 5, damage: t.damage, splash: t.splash, slow: t.slow, poison: t.poison || 0, color: t.color });
            }
        });
        for (let i = projectiles.length - 1; i >= 0; i--) {
            const p = projectiles[i];
            if (p.type === 'chain') { p.timer--; if (p.timer <= 0) projectiles.splice(i, 1); continue; }
            if (!p.target || p.target.hp <= 0) { projectiles.splice(i, 1); continue; }
            const dx = p.target.x-p.x, dy = p.target.y-p.y, d = Math.hypot(dx, dy);
            if (d < p.speed*2) {
                p.target.hp -= p.damage;
                if (p.slow > 0) { p.target.slowTimer = 60; p.target.slowAmount = p.slow; }
                if (p.poison > 0) { p.target.poisonTimer = 90; p.target.poisonDmg = p.poison; }
                if (p.splash > 0) {
                    enemies.forEach(e => {
                        if (e !== p.target && dist(p.target, e) < p.splash) {
                            e.hp -= p.damage*0.5;
                            if (p.slow > 0) { e.slowTimer = 60; e.slowAmount = p.slow; }
                            if (p.poison > 0) { e.poisonTimer = 90; e.poisonDmg = p.poison; }
                            addParticles(e.x, e.y, p.color, 2);
                        }
                    });
                    addParticles(p.target.x, p.target.y, p.color, 8);
                }
                else { addParticles(p.target.x, p.target.y, p.color, 3); }
                projectiles.splice(i, 1);
            } else { p.x += (dx/d)*p.speed; p.y += (dy/d)*p.speed; }
        }
        for (let i = enemies.length - 1; i >= 0; i--) {
            if (enemies[i].hp <= 0) { const e = enemies[i]; gold += e.reward; kills++; addParticles(e.x, e.y, e.color, 10); enemies.splice(i, 1); }
        }
        for (let i = particles.length - 1; i >= 0; i--) { const p = particles[i]; p.x += p.vx; p.y += p.vy; p.life--; if (p.life <= 0) particles.splice(i, 1); }
        if (waveActive && waveEnemiesLeft <= 0 && enemies.length === 0) {
            waveActive = false; gold += 10 + waveNum * 2;
            if (waveNum >= 30) { endGame(true); return; }
        }
    }
    updateUI();
}

function endGame(won) {
    gameOver = true;
    if (won) { document.getElementById('winLives').textContent = lives; document.getElementById('winOverlay').classList.add('show'); }
    else { document.getElementById('finalWave').textContent = waveNum; document.getElementById('finalKills').textContent = kills; document.getElementById('gameOverOverlay').classList.add('show'); }
}

function restartGame() { initGame(); }

function draw() {
    ctx.clearRect(0, 0, W, H);
    ctx.strokeStyle = 'rgba(0,0,0,0.08)';
    for (let x = 0; x < W; x += TILE) { ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
    for (let y = 0; y < H; y += TILE) { ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }
    path.forEach(([col,row]) => { ctx.fillStyle = 'rgba(139,119,80,0.7)'; ctx.fillRect(col*TILE, row*TILE, TILE, TILE); });
    ctx.fillStyle = 'rgba(255,255,255,0.06)';
    for (let i = 0; i < path.length; i += 3) { const [col,row] = path[i]; ctx.beginPath(); ctx.arc(col*TILE+TILE/2, row*TILE+TILE/2, 2, 0, Math.PI*2); ctx.fill(); }
    if (path.length > 0) { ctx.fillStyle = '#2ecc71'; ctx.font = '16px sans-serif'; ctx.textAlign = 'center'; ctx.fillText('‚ñ∂', path[0][0]*TILE+TILE/2, path[0][1]*TILE+TILE/2+5); const end = path[path.length-1]; ctx.fillStyle = '#e74c3c'; ctx.fillText('üè†', end[0]*TILE+TILE/2, end[1]*TILE+TILE/2+5); }
    if (hoveredCell && selectedTowerType) {
        const {col, row} = hoveredCell;
        const canPlace = !isPath(col,row) && !towers.find(t=>t.col===col&&t.row===row) && col>=0 && col<COLS && row>=0 && row<ROWS;
        ctx.fillStyle = canPlace ? 'rgba(46,204,113,0.3)' : 'rgba(231,76,60,0.3)';
        ctx.fillRect(col*TILE, row*TILE, TILE, TILE);
        if (canPlace) { ctx.beginPath(); ctx.arc(col*TILE+TILE/2, row*TILE+TILE/2, TOWER_TYPES[selectedTowerType].range, 0, Math.PI*2); ctx.strokeStyle = 'rgba(255,255,255,0.15)'; ctx.stroke(); }
    }
    towers.forEach(t => {
        if (selectedTower === t) { ctx.beginPath(); ctx.arc(t.x, t.y, t.range, 0, Math.PI*2); ctx.strokeStyle = 'rgba(255,255,255,0.2)'; ctx.lineWidth = 1; ctx.stroke(); }
        drawTower(t);
    });
    enemies.forEach(e => {
        drawKnight(e);
        const barW = e.size*2.5, hpPct = e.hp/e.maxHp;
        ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(e.x-barW/2, e.y-e.size-8, barW, 3);
        ctx.fillStyle = hpPct > 0.5 ? '#2ecc71' : hpPct > 0.25 ? '#f39c12' : '#e74c3c';
        ctx.fillRect(e.x-barW/2, e.y-e.size-8, barW*hpPct, 3);
    });
    projectiles.forEach(p => {
        if (p.type === 'chain') { ctx.strokeStyle = p.color; ctx.lineWidth = 2; ctx.globalAlpha = p.timer/8; for (let i = 0; i < p.targets.length-1; i++) { ctx.beginPath(); ctx.moveTo(p.targets[i].x, p.targets[i].y); ctx.lineTo(p.targets[i+1].x, p.targets[i+1].y); ctx.stroke(); } ctx.globalAlpha = 1; ctx.lineWidth = 1; }
        else { ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, 3, 0, Math.PI*2); ctx.fill(); }
    });
    particles.forEach(p => { ctx.globalAlpha = p.life/25; ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.fill(); });
    ctx.globalAlpha = 1;
}

function drawTower(t) {
    const cx = t.x, cy = t.y, s = TILE;
    const dark = shadeColor(t.color, -40);
    const light = shadeColor(t.color, 30);
    // Shadow
    ctx.fillStyle = 'rgba(0,0,0,0.25)';
    ctx.fillRect(t.col*TILE+3, t.row*TILE+4, s-4, s-3);
    // Base stone
    ctx.fillStyle = dark;
    ctx.fillRect(t.col*TILE+2, t.row*TILE+s*0.4, s-4, s*0.6);
    // Main tower body
    ctx.fillStyle = t.color;
    ctx.fillRect(t.col*TILE+4, t.row*TILE+2, s-8, s-4);
    // Battlements (top crenellations)
    ctx.fillStyle = light;
    const bw = 4, gap = 3;
    for (let bx = t.col*TILE+3; bx < t.col*TILE+s-3; bx += bw+gap) {
        ctx.fillRect(bx, t.row*TILE, Math.min(bw, t.col*TILE+s-3-bx), 4);
    }
    // Window/slit
    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    ctx.fillRect(cx-1, cy-1, 3, 5);
    // Type-specific details
    if (t.type === 'archer') {
        // Bow on top
        ctx.strokeStyle = '#8B4513';
        ctx.lineWidth = 1.5;
        ctx.beginPath(); ctx.arc(cx, t.row*TILE+3, 5, Math.PI*0.3, Math.PI*0.7); ctx.stroke();
        ctx.lineWidth = 1;
    } else if (t.type === 'cannon') {
        // Cannon barrel
        ctx.fillStyle = '#333';
        ctx.fillRect(cx-1, cy-3, 8, 3);
        ctx.fillStyle = '#555';
        ctx.beginPath(); ctx.arc(cx+7, cy-1.5, 2, 0, Math.PI*2); ctx.fill();
    } else if (t.type === 'frost') {
        // Icy glow
        ctx.fillStyle = 'rgba(100,200,255,0.3)';
        ctx.beginPath(); ctx.arc(cx, cy-2, 6, 0, Math.PI*2); ctx.fill();
        // Crystal on top
        ctx.fillStyle = '#aee';
        ctx.beginPath(); ctx.moveTo(cx, t.row*TILE-2); ctx.lineTo(cx-3, t.row*TILE+4); ctx.lineTo(cx+3, t.row*TILE+4); ctx.closePath(); ctx.fill();
    } else if (t.type === 'lightning') {
        // Lightning rod
        ctx.strokeStyle = '#f1c40f';
        ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(cx, t.row*TILE-1); ctx.lineTo(cx, t.row*TILE+5); ctx.stroke();
        // Spark
        ctx.fillStyle = 'rgba(241,196,15,0.4)';
        ctx.beginPath(); ctx.arc(cx, t.row*TILE, 4, 0, Math.PI*2); ctx.fill();
        ctx.lineWidth = 1;
    } else if (t.type === 'inferno') {
        // Fire glow
        ctx.fillStyle = 'rgba(255,100,0,0.25)';
        ctx.beginPath(); ctx.arc(cx, cy, 10, 0, Math.PI*2); ctx.fill();
        // Flames on top
        ctx.fillStyle = '#ff4500';
        ctx.beginPath(); ctx.moveTo(cx-4, t.row*TILE+3); ctx.lineTo(cx, t.row*TILE-4); ctx.lineTo(cx+4, t.row*TILE+3); ctx.closePath(); ctx.fill();
        ctx.fillStyle = '#ffaa00';
        ctx.beginPath(); ctx.moveTo(cx-2, t.row*TILE+3); ctx.lineTo(cx, t.row*TILE-1); ctx.lineTo(cx+2, t.row*TILE+3); ctx.closePath(); ctx.fill();
    } else if (t.type === 'sniper') {
        // Long barrel / scope
        ctx.strokeStyle = '#0e6655';
        ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(cx, cy-2); ctx.lineTo(cx+12, cy-6); ctx.stroke();
        // Scope lens
        ctx.fillStyle = '#1abc9c';
        ctx.beginPath(); ctx.arc(cx+12, cy-6, 2.5, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = 'rgba(26,188,156,0.2)';
        ctx.beginPath(); ctx.arc(cx+12, cy-6, 5, 0, Math.PI*2); ctx.fill();
        ctx.lineWidth = 1;
    } else if (t.type === 'poison') {
        // Bubbling cauldron / poison glow
        ctx.fillStyle = 'rgba(39,174,96,0.3)';
        ctx.beginPath(); ctx.arc(cx, cy, 8, 0, Math.PI*2); ctx.fill();
        // Skull symbol
        ctx.fillStyle = '#145a32';
        ctx.beginPath(); ctx.arc(cx, t.row*TILE+3, 4, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#27ae60';
        ctx.beginPath(); ctx.arc(cx-1.5, t.row*TILE+2, 1, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(cx+1.5, t.row*TILE+2, 1, 0, Math.PI*2); ctx.fill();
        // Drip
        ctx.fillStyle = '#2ecc71';
        ctx.beginPath(); ctx.moveTo(cx, cy+5); ctx.lineTo(cx-1, cy+8); ctx.lineTo(cx+1, cy+8); ctx.closePath(); ctx.fill();
    } else if (t.type === 'tesla') {
        // Coil rings
        ctx.strokeStyle = '#9b59b6';
        ctx.lineWidth = 1.5;
        for (let r = 3; r <= 7; r += 2) {
            ctx.beginPath(); ctx.arc(cx, cy-2, r, 0, Math.PI*2); ctx.stroke();
        }
        // Electric spark on top
        ctx.fillStyle = 'rgba(155,89,182,0.4)';
        ctx.beginPath(); ctx.arc(cx, t.row*TILE+1, 5, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = '#d2b4de';
        ctx.beginPath(); ctx.moveTo(cx-3, t.row*TILE-1); ctx.lineTo(cx, t.row*TILE+2); ctx.lineTo(cx+3, t.row*TILE-1); ctx.stroke();
        ctx.lineWidth = 1;
    }
    // Level badge
    if (t.level > 1) {
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.beginPath(); ctx.arc(t.col*TILE+s-4, t.row*TILE+s-4, 5, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#fff'; ctx.font = 'bold 7px sans-serif'; ctx.textAlign = 'center';
        ctx.fillText(t.level, t.col*TILE+s-4, t.row*TILE+s-1.5);
    }
}

const _colorCache = {};
const _colorCtx = document.createElement('canvas').getContext('2d');
function shadeColor(color, amount) {
    const key = color + '|' + amount;
    if (_colorCache[key]) return _colorCache[key];
    _colorCtx.fillStyle = color;
    const hex = _colorCtx.fillStyle;
    let r = parseInt(hex.slice(1,3),16), g = parseInt(hex.slice(3,5),16), b = parseInt(hex.slice(5,7),16);
    r = Math.max(0, Math.min(255, r+amount));
    g = Math.max(0, Math.min(255, g+amount));
    b = Math.max(0, Math.min(255, b+amount));
    const result = `rgb(${r},${g},${b})`;
    _colorCache[key] = result;
    return result;
}

function drawKnight(e) {
    const x = e.x, y = e.y, s = e.size;
    const color = e.slowTimer > 0 ? '#85c1e9' : e.color;
    const dark = shadeColor(color, -50);
    // Shadow on ground
    ctx.fillStyle = 'rgba(0,0,0,0.25)';
    ctx.beginPath(); ctx.ellipse(x, y+s*0.9, s*0.6, s*0.2, 0, 0, Math.PI*2); ctx.fill();
    // Body / armor
    ctx.fillStyle = color;
    ctx.fillRect(x-s*0.3, y-s*0.2, s*0.6, s*0.7);
    // Legs
    ctx.fillStyle = dark;
    ctx.fillRect(x-s*0.25, y+s*0.5, s*0.2, s*0.35);
    ctx.fillRect(x+s*0.05, y+s*0.5, s*0.2, s*0.35);
    // Head (helmet)
    ctx.fillStyle = shadeColor(color, 20);
    ctx.beginPath(); ctx.arc(x, y-s*0.35, s*0.35, 0, Math.PI*2); ctx.fill();
    // Helmet visor
    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    ctx.fillRect(x-s*0.2, y-s*0.35, s*0.4, s*0.15);
    // Helmet plume varies by type
    if (e.type === 'boss') {
        ctx.fillStyle = '#ff4444';
        ctx.beginPath(); ctx.moveTo(x, y-s*0.7); ctx.lineTo(x-s*0.15, y-s*0.3); ctx.lineTo(x+s*0.3, y-s*0.5); ctx.closePath(); ctx.fill();
        ctx.beginPath(); ctx.moveTo(x, y-s*0.7); ctx.lineTo(x+s*0.15, y-s*0.3); ctx.lineTo(x-s*0.3, y-s*0.5); ctx.closePath(); ctx.fill();
    } else if (e.type === 'tank') {
        ctx.fillStyle = '#aa66cc';
        ctx.beginPath(); ctx.moveTo(x, y-s*0.65); ctx.lineTo(x-s*0.1, y-s*0.35); ctx.lineTo(x+s*0.1, y-s*0.35); ctx.closePath(); ctx.fill();
    } else if (e.type === 'swarm') {
        // Tiny horns
        ctx.fillStyle = '#e67e22';
        ctx.beginPath(); ctx.moveTo(x-s*0.2, y-s*0.55); ctx.lineTo(x-s*0.1, y-s*0.35); ctx.lineTo(x, y-s*0.45); ctx.closePath(); ctx.fill();
        ctx.beginPath(); ctx.moveTo(x+s*0.2, y-s*0.55); ctx.lineTo(x+s*0.1, y-s*0.35); ctx.lineTo(x, y-s*0.45); ctx.closePath(); ctx.fill();
    } else if (e.type === 'juggernaut') {
        // Big crown/helm with spikes
        ctx.fillStyle = '#1a252f';
        ctx.beginPath(); ctx.moveTo(x-s*0.3, y-s*0.35); ctx.lineTo(x-s*0.3, y-s*0.75); ctx.lineTo(x-s*0.1, y-s*0.55); ctx.lineTo(x, y-s*0.8); ctx.lineTo(x+s*0.1, y-s*0.55); ctx.lineTo(x+s*0.3, y-s*0.75); ctx.lineTo(x+s*0.3, y-s*0.35); ctx.closePath(); ctx.fill();
    } else if (e.type === 'demon') {
        // Fiery horns
        ctx.fillStyle = '#ff0000';
        ctx.beginPath(); ctx.moveTo(x-s*0.25, y-s*0.8); ctx.lineTo(x-s*0.15, y-s*0.35); ctx.lineTo(x-s*0.05, y-s*0.5); ctx.closePath(); ctx.fill();
        ctx.beginPath(); ctx.moveTo(x+s*0.25, y-s*0.8); ctx.lineTo(x+s*0.15, y-s*0.35); ctx.lineTo(x+s*0.05, y-s*0.5); ctx.closePath(); ctx.fill();
        // Fire glow
        ctx.fillStyle = 'rgba(255,0,0,0.15)';
        ctx.beginPath(); ctx.arc(x, y, s*1.2, 0, Math.PI*2); ctx.fill();
    } else {
        ctx.fillStyle = color;
        ctx.beginPath(); ctx.moveTo(x, y-s*0.6); ctx.lineTo(x-s*0.08, y-s*0.35); ctx.lineTo(x+s*0.08, y-s*0.35); ctx.closePath(); ctx.fill();
    }
    // Poison indicator
    if (e.poisonTimer > 0) {
        ctx.fillStyle = 'rgba(39,174,96,0.3)';
        ctx.beginPath(); ctx.arc(x, y, s*0.9, 0, Math.PI*2); ctx.fill();
    }
    // Shield (left side)
    ctx.fillStyle = dark;
    ctx.fillRect(x-s*0.5, y-s*0.2, s*0.2, s*0.45);
    ctx.strokeStyle = shadeColor(color, 40);
    ctx.lineWidth = 0.5;
    ctx.strokeRect(x-s*0.5, y-s*0.2, s*0.2, s*0.45);
    // Sword (right side)
    ctx.strokeStyle = '#ccc';
    ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.moveTo(x+s*0.4, y-s*0.4); ctx.lineTo(x+s*0.4, y+s*0.3); ctx.stroke();
    // Sword handle
    ctx.strokeStyle = '#8B4513';
    ctx.beginPath(); ctx.moveTo(x+s*0.3, y-s*0.1); ctx.lineTo(x+s*0.5, y-s*0.1); ctx.stroke();
    ctx.lineWidth = 1;
}

function gameLoop() { update(); draw(); requestAnimationFrame(gameLoop); }

// === ANIMATED BACKGROUND ===
const bgCanvas = document.getElementById('bgCanvas');
const bgCtx = bgCanvas.getContext('2d');
let bgParticles = [];
function resizeBg() { bgCanvas.width = window.innerWidth; bgCanvas.height = window.innerHeight; }
window.addEventListener('resize', resizeBg);
resizeBg();
for (let i = 0; i < 100; i++) {
    bgParticles.push({
        x: Math.random()*bgCanvas.width, y: Math.random()*bgCanvas.height,
        size: Math.random()*2.5+0.5,
        speedX: (Math.random()-0.5)*0.4, speedY: -Math.random()*0.5-0.1,
        opacity: Math.random()*0.5+0.15,
        color: Math.random()>0.6 ? `rgba(100,160,255,` : Math.random()>0.4 ? `rgba(200,160,100,` : `rgba(160,120,255,`
    });
}
function drawBg() {
    bgCtx.clearRect(0, 0, bgCanvas.width, bgCanvas.height);
    bgParticles.forEach(p => {
        p.x += p.speedX; p.y += p.speedY;
        if (p.y < -10) { p.y = bgCanvas.height+10; p.x = Math.random()*bgCanvas.width; }
        if (p.x < -10) p.x = bgCanvas.width+10;
        if (p.x > bgCanvas.width+10) p.x = -10;
        bgCtx.beginPath(); bgCtx.arc(p.x, p.y, p.size, 0, Math.PI*2);
        bgCtx.fillStyle = p.color+p.opacity+')'; bgCtx.fill();
    });
    requestAnimationFrame(drawBg);
}
drawBg();

// === MUSIC ===
let audioCtx, masterGain, currentTrack='kingdom', musicPlaying=false, oscillators=[];
function initAudio() { if (audioCtx) return; audioCtx = new (window.AudioContext||window.webkitAudioContext)(); masterGain = audioCtx.createGain(); masterGain.gain.value = 0.3; masterGain.connect(audioCtx.destination); }
function stopMusic() { oscillators.forEach(o => { try{o.stop();}catch(e){} }); oscillators = []; musicPlaying = false; }
function playTrack(name) {
    initAudio(); stopMusic();
    if (name === 'off') return;
    musicPlaying = true;
    const tracks = {
        kingdom: { notes:[261,293,329,349,392,349,329,293], tempo:0.6, type:'triangle', decay:0.5 },
        battle:  { notes:[196,220,261,196,233,261,196,174], tempo:0.35, type:'sawtooth', decay:0.3 },
        peace:   { notes:[329,392,440,523,440,392,349,329], tempo:0.8, type:'sine', decay:0.7 }
    };
    const t = tracks[name]; if(!t) return;
    let noteIdx = 0;
    function playNote() {
        if(!musicPlaying) return;
        const osc=audioCtx.createOscillator(), ng=audioCtx.createGain();
        osc.type=t.type; osc.frequency.value=t.notes[noteIdx%t.notes.length];
        ng.gain.setValueAtTime(0.15,audioCtx.currentTime); ng.gain.exponentialRampToValueAtTime(0.001,audioCtx.currentTime+t.decay);
        osc.connect(ng); ng.connect(masterGain); osc.start(); osc.stop(audioCtx.currentTime+t.decay);
        oscillators.push(osc); noteIdx++;
        setTimeout(playNote, t.tempo*1000);
    }
    playNote();
    const bass=audioCtx.createOscillator(), bg2=audioCtx.createGain();
    bass.type='sine'; bass.frequency.value=name==='battle'?65:name==='peace'?82:73;
    bg2.gain.value=0.04; bass.connect(bg2); bg2.connect(masterGain); bass.start(); oscillators.push(bass);
}
function setTrack(name) { currentTrack=name; document.querySelectorAll('.music-btn').forEach(b=>b.classList.toggle('active',b.dataset.track===name)); playTrack(name); }
function setVolume(val) { if(masterGain) masterGain.gain.value=val/100; }
document.addEventListener('click', ()=>{ if(!audioCtx&&currentTrack!=='off') playTrack(currentTrack); }, {once:true});

// === SAVE/LOAD (multi-slot with thumbnails) ===
function getSaveList() {
    try { return JSON.parse(localStorage.getItem('towerDefense_saves') || '[]'); }
    catch(e) { return []; }
}
function setSaveList(list) {
    localStorage.setItem('towerDefense_saves', JSON.stringify(list));
}

function saveGame() {
    // Capture a thumbnail of the current game canvas
    const thumb = canvas.toDataURL('image/png', 0.5);
    const now = new Date();
    const name = `Wave ${waveNum} - ${now.toLocaleDateString()} ${now.toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'})}`;
    const d = {
        name,
        thumb,
        date: now.toISOString(),
        gold, lives, waveNum, kills, gameSpeed,
        towers: towers.map(t=>({col:t.col,row:t.row,type:t.type,level:t.level,range:t.range,damage:t.damage,fireRate:t.fireRate,splash:t.splash,slow:t.slow,chain:t.chain,poison:t.poison||0,color:t.color,totalCost:t.totalCost}))
    };
    const saves = getSaveList();
    saves.unshift(d); // newest first
    if (saves.length > 20) saves.length = 20; // limit
    setSaveList(saves);
    showSaveMsg('Game saved!');
}

function loadGame() {
    const saves = getSaveList();
    // Also check for old single-slot save and migrate it
    const oldSave = localStorage.getItem('towerDefense_save');
    if (saves.length === 0 && !oldSave) { showSaveMsg('No saves found!'); return; }
    if (saves.length === 0 && oldSave) {
        try {
            const d = JSON.parse(oldSave);
            d.name = 'Old Save';
            d.thumb = '';
            d.date = new Date().toISOString();
            saves.push(d);
            setSaveList(saves);
            localStorage.removeItem('towerDefense_save');
        } catch(e) {}
    }
    showLoadGallery(saves);
}

function showLoadGallery(saves) {
    const list = document.getElementById('saveList');
    list.innerHTML = '';
    if (saves.length === 0) {
        list.innerHTML = '<p class="no-saves">No saved games yet. Click Save to create one!</p>';
    } else {
        saves.forEach((s, i) => {
            const card = document.createElement('div');
            card.className = 'save-card';
            const towerCount = s.towers ? s.towers.length : 0;
            card.innerHTML = `
                ${s.thumb ? `<img src="${s.thumb}" alt="Save thumbnail">` : '<div style="height:80px;background:rgba(0,0,0,0.2);border-radius:6px;margin-bottom:8px;display:flex;align-items:center;justify-content:center;color:#445;font-size:12px;">No preview</div>'}
                <div class="save-name">${s.name || 'Save ' + (i+1)}</div>
                <div class="save-details">
                    ‚ù§Ô∏è ${s.lives} lives ¬∑ üí∞ ${s.gold}g<br>
                    üè∞ ${towerCount} towers ¬∑ üíÄ ${s.kills} kills
                </div>
                <button class="save-delete" onclick="event.stopPropagation();deleteSave(${i})">üóë Delete</button>
            `;
            card.addEventListener('click', () => loadSaveSlot(i));
            list.appendChild(card);
        });
    }
    document.getElementById('loadOverlay').classList.add('show');
}

function closeLoadGallery() {
    document.getElementById('loadOverlay').classList.remove('show');
}

function loadSaveSlot(index) {
    const saves = getSaveList();
    const d = saves[index];
    if (!d) { showSaveMsg('Save not found!'); return; }
    try {
        gold=d.gold; lives=d.lives; waveNum=d.waveNum; kills=d.kills; gameSpeed=d.gameSpeed||1;
        enemies=[]; projectiles=[]; particles=[]; waveActive=false; waveEnemiesLeft=0; gameOver=false;
        selectedTowerType=null; selectedTower=null;
        towers=d.towers.map(t=>({...t, x:t.col*TILE+TILE/2, y:t.row*TILE+TILE/2, cooldown:0}));
        document.getElementById('gameOverOverlay').classList.remove('show');
        document.getElementById('winOverlay').classList.remove('show');
        closeLoadGallery();
        updateUI();
        showSaveMsg('Game loaded!');
    } catch(e) { showSaveMsg('Load failed!'); }
}

function deleteSave(index) {
    const saves = getSaveList();
    saves.splice(index, 1);
    setSaveList(saves);
    showLoadGallery(saves);
}

function showSaveMsg(text) { const el=document.getElementById('saveMsg'); el.textContent=text; el.classList.add('show'); setTimeout(()=>el.classList.remove('show'),2000); }

initGame();
gameLoop();
</script>
</body>
</html>
