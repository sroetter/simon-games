<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Dungeon Crawler - D&D Adventure</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700;900&display=swap');
*{margin:0;padding:0;box-sizing:border-box}
body{background:#0a0a0f;color:#e0e0e0;font-family:'Cinzel',serif;overflow:hidden;height:100vh;display:flex;flex-direction:column;align-items:center;justify-content:center}
#bg-particles{position:fixed;top:0;left:0;width:100%;height:100%;z-index:0;pointer-events:none}
.back-btn{position:fixed;top:18px;left:24px;color:#aaa;text-decoration:none;font-size:14px;z-index:100;font-family:'Cinzel',serif;transition:color .3s}.back-btn:hover{color:#fff}
h1{font-family:'Cinzel',serif;font-weight:900;font-size:26px;text-align:center;margin-bottom:8px;z-index:2;text-shadow:0 0 20px rgba(180,140,60,.5);color:#f1c40f}

#game-container{position:relative;z-index:2;display:flex;gap:12px;align-items:flex-start}

canvas#dungeon{display:block;border-radius:10px;border:1px solid rgba(255,255,255,.08);box-shadow:0 0 40px rgba(0,0,0,.6);image-rendering:pixelated}

#sidebar{width:240px;display:flex;flex-direction:column;gap:8px;font-size:12px}
.panel{background:rgba(10,10,20,.75);backdrop-filter:blur(8px);border:1px solid rgba(255,255,255,.08);border-radius:8px;padding:10px}
.panel h3{font-size:13px;color:#f1c40f;margin-bottom:6px;border-bottom:1px solid rgba(255,255,255,.08);padding-bottom:4px}
.stat-row{display:flex;justify-content:space-between;margin:2px 0;font-size:11px}
.stat-val{color:#8cf}
.bar-outer{width:100%;height:12px;background:rgba(255,255,255,.1);border-radius:6px;overflow:hidden;margin:3px 0}
.bar-inner{height:100%;border-radius:6px;transition:width .3s}
.hp-bar{background:linear-gradient(90deg,#8b0000,#e74c3c)}
.mana-bar{background:linear-gradient(90deg,#1a3a6a,#3498db)}
.xp-bar{background:linear-gradient(90deg,#5a5a10,#f1c40f)}
.gold-color{color:#f1c40f}
.heal-color{color:#2ecc71}
.dmg-color{color:#e74c3c}
.mana-color{color:#3498db}

#inventory-list{max-height:180px;overflow-y:auto;scrollbar-width:thin;scrollbar-color:#333 transparent}
#inventory-list::-webkit-scrollbar{width:4px}
#inventory-list::-webkit-scrollbar-thumb{background:#444;border-radius:2px}
.inv-item{padding:3px 4px;border-radius:4px;cursor:pointer;font-size:10px;margin:1px 0;display:flex;justify-content:space-between;align-items:center;transition:background .2s}
.inv-item:hover{background:rgba(255,255,255,.1)}
.inv-item.equipped{background:rgba(241,196,15,.15);border:1px solid rgba(241,196,15,.3)}
.inv-item .item-name{flex:1}
.inv-item .item-stat{color:#8cf;font-size:9px;margin-left:6px}

#combat-overlay{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.8);backdrop-filter:blur(6px);display:none;z-index:50;flex-direction:column;align-items:center;justify-content:center}
#combat-box{background:rgba(15,15,25,.95);border:1px solid rgba(241,196,15,.3);border-radius:12px;padding:24px;max-width:500px;width:90%;text-align:center;box-shadow:0 0 60px rgba(241,196,15,.1)}
#combat-box h2{font-size:22px;color:#f1c40f;margin-bottom:12px}
#combat-log{min-height:100px;max-height:200px;overflow-y:auto;text-align:left;font-size:12px;margin:10px 0;padding:8px;background:rgba(0,0,0,.4);border-radius:6px;line-height:1.6;scrollbar-width:thin;scrollbar-color:#333 transparent}
#combat-log .roll{color:#f1c40f}
#combat-log .hit{color:#e74c3c}
#combat-log .miss{color:#888}
#combat-log .heal{color:#2ecc71}
#combat-log .info{color:#8cf}
#combat-actions{display:flex;gap:8px;justify-content:center;flex-wrap:wrap;margin-top:10px}
#combat-actions button{padding:8px 20px;font-family:'Cinzel',serif;font-weight:700;font-size:13px;border:1px solid rgba(255,255,255,.2);border-radius:6px;cursor:pointer;transition:transform .2s,box-shadow .2s,background .2s;color:#fff}
#combat-actions button:hover{transform:scale(1.05)}
.btn-attack{background:linear-gradient(135deg,#8b0000,#c0392b)!important}
.btn-defend{background:linear-gradient(135deg,#1a3a6a,#2980b9)!important}
.btn-spell{background:linear-gradient(135deg,#4a0080,#8e44ad)!important}
.btn-flee{background:linear-gradient(135deg,#333,#555)!important}
.btn-continue{background:linear-gradient(135deg,#1a6a1a,#27ae60)!important}
.btn-attack:hover{box-shadow:0 4px 15px rgba(200,30,30,.4)}
.btn-defend:hover{box-shadow:0 4px 15px rgba(41,128,185,.4)}
.btn-spell:hover{box-shadow:0 4px 15px rgba(142,68,173,.4)}
.btn-flee:hover{box-shadow:0 4px 15px rgba(100,100,100,.4)}
button:disabled{opacity:.4;cursor:not-allowed;transform:none!important}

#char-select{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.9);backdrop-filter:blur(6px);display:flex;z-index:60;flex-direction:column;align-items:center;justify-content:center}
#char-select h2{font-size:30px;color:#f1c40f;margin-bottom:6px;text-shadow:0 0 30px rgba(241,196,15,.4)}
#char-select .subtitle{color:#888;font-size:13px;margin-bottom:20px}
.class-cards{display:flex;gap:16px;flex-wrap:wrap;justify-content:center}
.class-card{background:rgba(15,15,25,.9);border:1px solid rgba(255,255,255,.1);border-radius:10px;padding:20px;width:180px;cursor:pointer;transition:transform .2s,border-color .3s,box-shadow .3s;text-align:center}
.class-card:hover{transform:translateY(-4px);border-color:rgba(241,196,15,.5);box-shadow:0 8px 30px rgba(241,196,15,.15)}
.class-card .icon{font-size:48px;margin-bottom:8px}
.class-card .name{font-size:16px;font-weight:700;color:#f1c40f;margin-bottom:6px}
.class-card .desc{font-size:10px;color:#aaa;margin-bottom:8px;min-height:30px}
.class-card .stats{font-size:10px;color:#8cf;text-align:left}

#gameover-overlay{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.85);backdrop-filter:blur(6px);display:none;z-index:55;flex-direction:column;align-items:center;justify-content:center}
#gameover-box{background:rgba(15,15,25,.95);border:1px solid rgba(200,30,30,.4);border-radius:12px;padding:30px;max-width:400px;width:90%;text-align:center;box-shadow:0 0 60px rgba(200,30,30,.15)}
#gameover-box h2{font-size:28px;color:#e74c3c;margin-bottom:14px;text-shadow:0 0 20px rgba(200,30,30,.5)}
#gameover-stats{font-size:13px;line-height:2}
#gameover-box button{margin-top:18px;padding:10px 32px;font-family:'Cinzel',serif;font-weight:700;font-size:15px;background:linear-gradient(135deg,#8b0000,#c0392b);color:#fff;border:none;border-radius:6px;cursor:pointer;transition:transform .2s,box-shadow .2s}
#gameover-box button:hover{transform:scale(1.05);box-shadow:0 6px 20px rgba(200,30,30,.5)}

#msg-log{position:absolute;bottom:8px;left:8px;z-index:5;pointer-events:none;font-size:10px;max-width:300px}
.msg{padding:2px 6px;margin:1px 0;border-radius:3px;background:rgba(0,0,0,.7);animation:msgFade 3s forwards;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
@keyframes msgFade{0%{opacity:1}70%{opacity:1}100%{opacity:0}}

#minimap{position:absolute;top:8px;right:8px;border:1px solid rgba(255,255,255,.15);border-radius:4px;z-index:5}

#tooltip{position:fixed;background:rgba(10,10,20,.95);border:1px solid rgba(241,196,15,.3);border-radius:6px;padding:8px 10px;font-size:11px;z-index:70;pointer-events:none;display:none;max-width:200px;font-family:'Cinzel',serif}
#tooltip .tt-name{color:#f1c40f;font-weight:700;margin-bottom:3px}
#tooltip .tt-stat{color:#8cf}
#tooltip .tt-desc{color:#aaa;font-size:10px;margin-top:3px}

#sidebar{max-height:640px;overflow-y:auto;scrollbar-width:thin;scrollbar-color:#333 transparent}
#sidebar::-webkit-scrollbar{width:4px}
#sidebar::-webkit-scrollbar-thumb{background:#444;border-radius:2px}

.party-member{margin:4px 0;padding:4px 0;border-bottom:1px solid rgba(255,255,255,.05)}
.party-member:last-child{border-bottom:none}
.party-member .pm-header{display:flex;justify-content:space-between;align-items:center;font-size:10px;margin-bottom:2px}
.party-member .pm-name{color:#ccc}
.party-member .pm-class{color:#888;font-size:9px}
.party-member.pm-dead .pm-name{color:#555;text-decoration:line-through}
.party-member.pm-dead .pm-class{color:#444}
.party-member .bar-outer{height:8px;margin:1px 0}

#combat-party-info{display:flex;gap:8px;justify-content:center;flex-wrap:wrap;margin-bottom:8px}
.combat-pm{background:rgba(255,255,255,.05);border-radius:6px;padding:4px 8px;font-size:10px;min-width:100px;text-align:center}
.combat-pm.dead{opacity:.4;text-decoration:line-through}
.combat-pm .cpm-name{color:#ccc;font-weight:700}
.combat-pm .cpm-hp{color:#e74c3c;font-size:9px}

#charsheet-overlay{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.8);backdrop-filter:blur(6px);display:none;z-index:55;flex-direction:column;align-items:center;justify-content:center}
#charsheet-box{background:linear-gradient(135deg,#2a2218,#1e1a14,#2a2218);border:2px solid #8b7355;border-radius:12px;padding:28px 32px;max-width:560px;width:92%;max-height:85vh;overflow-y:auto;box-shadow:0 0 60px rgba(139,115,85,.2),inset 0 0 80px rgba(0,0,0,.4);font-family:'Cinzel',serif;position:relative;scrollbar-width:thin;scrollbar-color:#5a4a3a transparent}
#charsheet-box::-webkit-scrollbar{width:6px}
#charsheet-box::-webkit-scrollbar-thumb{background:#5a4a3a;border-radius:3px}
#charsheet-box::before{content:'';position:absolute;top:4px;left:4px;right:4px;bottom:4px;border:1px solid rgba(139,115,85,.3);border-radius:8px;pointer-events:none}
#charsheet-box h2{font-size:22px;color:#f1c40f;margin-bottom:4px;text-align:center;text-shadow:0 0 15px rgba(241,196,15,.3)}
#charsheet-box .cs-subtitle{text-align:center;color:#8b7355;font-size:11px;margin-bottom:16px;border-bottom:1px solid #5a4a3a;padding-bottom:8px}
.cs-section{margin-bottom:14px}
.cs-section h3{font-size:13px;color:#d4a855;margin-bottom:6px;border-bottom:1px solid rgba(139,115,85,.3);padding-bottom:3px}
.cs-grid{display:grid;grid-template-columns:1fr 1fr;gap:3px 16px;font-size:11px}
.cs-grid .cs-label{color:#8b7355}
.cs-grid .cs-value{color:#e0d0b8;text-align:right}
.cs-party-member{background:rgba(0,0,0,.25);border:1px solid rgba(139,115,85,.2);border-radius:6px;padding:8px;margin:4px 0;font-size:11px}
.cs-party-member.dead{opacity:.5}
.cs-party-member .cspm-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:3px}
.cs-party-member .cspm-name{color:#d4a855;font-weight:700}
.cs-party-member .cspm-status{font-size:9px}
.cs-close-hint{text-align:center;color:#5a4a3a;font-size:10px;margin-top:12px}
</style>
</head>
<body>
<canvas id="bg-particles"></canvas>
<a href="index.html" class="back-btn">&larr; Back to Gallery</a>
<h1>&#x2694;&#xFE0F; Dungeon Crawler</h1>

<div id="char-select">
  <h2>&#x2694;&#xFE0F; Choose Your Hero</h2>
  <p class="subtitle">Each class offers a unique playstyle</p>
  <div class="class-cards">
    <div class="class-card" onclick="selectClass('warrior')">
      <div class="icon">&#x1F6E1;&#xFE0F;</div>
      <div class="name">Warrior</div>
      <div class="desc">A stalwart defender, strong in melee combat with heavy armor.</div>
      <div class="stats">HP: 120 | ATK: 8 | DEF: 6<br>Mana: 20 | Spell: Shield Bash</div>
    </div>
    <div class="class-card" onclick="selectClass('mage')">
      <div class="icon">&#x1F9D9;</div>
      <div class="name">Mage</div>
      <div class="desc">Master of arcane arts, devastating spells but fragile body.</div>
      <div class="stats">HP: 70 | ATK: 4 | DEF: 3<br>Mana: 80 | Spell: Fireball</div>
    </div>
    <div class="class-card" onclick="selectClass('rogue')">
      <div class="icon">&#x1F5E1;&#xFE0F;</div>
      <div class="name">Rogue</div>
      <div class="desc">Swift and cunning, striking from the shadows with deadly precision.</div>
      <div class="stats">HP: 85 | ATK: 7 | DEF: 4<br>Mana: 40 | Spell: Backstab</div>
    </div>
  </div>
</div>

<div id="game-container" style="display:none">
  <div style="position:relative">
    <canvas id="dungeon" width="640" height="640"></canvas>
    <div id="msg-log"></div>
    <canvas id="minimap" width="100" height="100"></canvas>
  </div>
  <div id="sidebar">
    <div class="panel">
      <h3 id="player-name">Hero</h3>
      <div class="stat-row"><span>Level</span><span class="stat-val" id="s-level">1</span></div>
      <div class="stat-row"><span>Floor</span><span class="stat-val" id="s-floor">1</span></div>
      <div class="stat-row"><span>Gold</span><span class="gold-color" id="s-gold">0</span></div>
      <div style="margin-top:6px">
        <div class="stat-row"><span>HP</span><span id="s-hp">120/120</span></div>
        <div class="bar-outer"><div class="bar-inner hp-bar" id="bar-hp" style="width:100%"></div></div>
        <div class="stat-row"><span>Mana</span><span id="s-mana">20/20</span></div>
        <div class="bar-outer"><div class="bar-inner mana-bar" id="bar-mana" style="width:100%"></div></div>
        <div class="stat-row"><span>XP</span><span id="s-xp">0/20</span></div>
        <div class="bar-outer"><div class="bar-inner xp-bar" id="bar-xp" style="width:0%"></div></div>
      </div>
    </div>
    <div class="panel">
      <h3>Stats</h3>
      <div class="stat-row"><span>Attack</span><span class="stat-val" id="s-atk">8</span></div>
      <div class="stat-row"><span>Defense</span><span class="stat-val" id="s-def">6</span></div>
      <div class="stat-row"><span>AC</span><span class="stat-val" id="s-ac">12</span></div>
    </div>
    <div class="panel">
      <h3>Equipment</h3>
      <div class="stat-row"><span>Weapon:</span><span class="stat-val" id="s-weapon">Fists</span></div>
      <div class="stat-row"><span>Armor:</span><span class="stat-val" id="s-armor">Cloth</span></div>
    </div>
    <div class="panel">
      <h3>Inventory</h3>
      <div id="inventory-list"></div>
    </div>
    <div class="panel" id="party-panel" style="display:none">
      <h3>Party</h3>
      <div id="party-list"></div>
    </div>
    <div class="panel" style="font-size:10px;color:#666;text-align:center">
      WASD/Arrows: Move | I: Use potion<br>E: Equip best | C: Character Sheet<br>Space: Wait
    </div>
  </div>
</div>

<div id="combat-overlay">
  <div id="combat-box">
    <h2 id="combat-title">Combat!</h2>
    <div style="display:flex;justify-content:space-around;margin-bottom:10px">
      <div id="combat-player-info" style="text-align:center"></div>
      <div style="font-size:24px;align-self:center">&#x2694;&#xFE0F;</div>
      <div id="combat-enemy-info" style="text-align:center"></div>
    </div>
    <div id="combat-party-info"></div>
    <div id="combat-log"></div>
    <div id="combat-actions"></div>
  </div>
</div>

<div id="charsheet-overlay" onclick="if(event.target===this){toggleCharSheet()}">
  <div id="charsheet-box">
    <h2 id="cs-title">Character Sheet</h2>
    <div class="cs-subtitle" id="cs-subtitle"></div>
    <div id="cs-content"></div>
    <div class="cs-close-hint">Press C or Escape to close</div>
  </div>
</div>

<div id="gameover-overlay">
  <div id="gameover-box">
    <h2>&#x1F480; You Have Fallen</h2>
    <div id="gameover-stats"></div>
    <button onclick="location.reload()">Try Again</button>
  </div>
</div>

<div id="tooltip"><div class="tt-name"></div><div class="tt-stat"></div><div class="tt-desc"></div></div>

<script>
// ==================== PARTICLES ====================
(function(){
const c=document.getElementById('bg-particles'),x=c.getContext('2d');
function resize(){c.width=innerWidth;c.height=innerHeight}
resize();window.addEventListener('resize',resize);
const P=[];for(let i=0;i<60;i++)P.push({x:Math.random()*c.width,y:Math.random()*c.height,r:Math.random()*2+.5,dx:(Math.random()-.5)*.3,dy:(Math.random()-.5)*.3,a:Math.random()*.4+.1});
function draw(){x.clearRect(0,0,c.width,c.height);P.forEach(p=>{p.x+=p.dx;p.y+=p.dy;if(p.x<0)p.x=c.width;if(p.x>c.width)p.x=0;if(p.y<0)p.y=c.height;if(p.y>c.height)p.y=0;x.beginPath();x.arc(p.x,p.y,p.r,0,Math.PI*2);x.fillStyle=`rgba(241,196,15,${p.a})`;x.fill()});requestAnimationFrame(draw)}
draw();
})();

// ==================== AUDIO ====================
const AudioCtx = window.AudioContext || window.webkitAudioContext;
const audioCtx = new AudioCtx();

function playSound(type) {
  const g = audioCtx.createGain();
  g.connect(audioCtx.destination);
  const now = audioCtx.currentTime;

  if (type === 'hit') {
    const o = audioCtx.createOscillator();
    o.type = 'sawtooth'; o.frequency.setValueAtTime(200, now);
    o.frequency.exponentialRampToValueAtTime(80, now + 0.15);
    g.gain.setValueAtTime(0.15, now); g.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
    o.connect(g); o.start(now); o.stop(now + 0.2);
  } else if (type === 'miss') {
    const o = audioCtx.createOscillator();
    o.type = 'sine'; o.frequency.setValueAtTime(300, now);
    o.frequency.exponentialRampToValueAtTime(150, now + 0.1);
    g.gain.setValueAtTime(0.08, now); g.gain.exponentialRampToValueAtTime(0.001, now + 0.12);
    o.connect(g); o.start(now); o.stop(now + 0.12);
  } else if (type === 'crit') {
    const o = audioCtx.createOscillator();
    o.type = 'square'; o.frequency.setValueAtTime(400, now);
    o.frequency.exponentialRampToValueAtTime(100, now + 0.25);
    g.gain.setValueAtTime(0.18, now); g.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
    o.connect(g); o.start(now); o.stop(now + 0.3);
  } else if (type === 'levelup') {
    [523, 659, 784, 1047].forEach((f, i) => {
      const o = audioCtx.createOscillator();
      const g2 = audioCtx.createGain();
      o.type = 'sine'; o.frequency.value = f;
      g2.gain.setValueAtTime(0.12, now + i * 0.12);
      g2.gain.exponentialRampToValueAtTime(0.001, now + i * 0.12 + 0.2);
      o.connect(g2); g2.connect(audioCtx.destination);
      o.start(now + i * 0.12); o.stop(now + i * 0.12 + 0.2);
    });
  } else if (type === 'stairs') {
    [262, 330, 392, 523].forEach((f, i) => {
      const o = audioCtx.createOscillator();
      const g2 = audioCtx.createGain();
      o.type = 'triangle'; o.frequency.value = f;
      g2.gain.setValueAtTime(0.1, now + i * 0.1);
      g2.gain.exponentialRampToValueAtTime(0.001, now + i * 0.1 + 0.15);
      o.connect(g2); g2.connect(audioCtx.destination);
      o.start(now + i * 0.1); o.stop(now + i * 0.1 + 0.15);
    });
  } else if (type === 'potion') {
    const o = audioCtx.createOscillator();
    o.type = 'sine'; o.frequency.setValueAtTime(400, now);
    o.frequency.exponentialRampToValueAtTime(800, now + 0.2);
    g.gain.setValueAtTime(0.1, now); g.gain.exponentialRampToValueAtTime(0.001, now + 0.25);
    o.connect(g); o.start(now); o.stop(now + 0.25);
  } else if (type === 'pickup') {
    const o = audioCtx.createOscillator();
    o.type = 'sine'; o.frequency.setValueAtTime(600, now);
    o.frequency.exponentialRampToValueAtTime(900, now + 0.1);
    g.gain.setValueAtTime(0.08, now); g.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
    o.connect(g); o.start(now); o.stop(now + 0.15);
  } else if (type === 'death') {
    [200, 180, 150, 100].forEach((f, i) => {
      const o = audioCtx.createOscillator();
      const g2 = audioCtx.createGain();
      o.type = 'sawtooth'; o.frequency.value = f;
      g2.gain.setValueAtTime(0.12, now + i * 0.2);
      g2.gain.exponentialRampToValueAtTime(0.001, now + i * 0.2 + 0.3);
      o.connect(g2); g2.connect(audioCtx.destination);
      o.start(now + i * 0.2); o.stop(now + i * 0.2 + 0.3);
    });
  } else if (type === 'spell') {
    const o = audioCtx.createOscillator();
    o.type = 'sine';
    o.frequency.setValueAtTime(300, now);
    o.frequency.exponentialRampToValueAtTime(1200, now + 0.15);
    o.frequency.exponentialRampToValueAtTime(200, now + 0.35);
    g.gain.setValueAtTime(0.12, now); g.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
    o.connect(g); o.start(now); o.stop(now + 0.4);
  } else if (type === 'defend') {
    const o = audioCtx.createOscillator();
    o.type = 'triangle'; o.frequency.setValueAtTime(150, now);
    o.frequency.exponentialRampToValueAtTime(300, now + 0.1);
    g.gain.setValueAtTime(0.1, now); g.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
    o.connect(g); o.start(now); o.stop(now + 0.15);
  } else if (type === 'door') {
    const o = audioCtx.createOscillator();
    o.type = 'square'; o.frequency.setValueAtTime(120, now);
    o.frequency.exponentialRampToValueAtTime(80, now + 0.15);
    g.gain.setValueAtTime(0.06, now); g.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
    o.connect(g); o.start(now); o.stop(now + 0.2);
  }
}

// ==================== GAME CONSTANTS ====================
const TILE = 32;
const MAP_W = 50, MAP_H = 50;
const VIEW_TILES = 20; // tiles visible in canvas
const CANVAS_SIZE = 640;
const FOG_RADIUS = 5;

const T = { WALL: 0, FLOOR: 1, DOOR: 2, STAIRS: 3, CORRIDOR: 4 };

// ==================== CLASSES ====================
const CLASSES = {
  warrior: { name: 'Warrior', icon: '\u{1F6E1}\uFE0F', hp: 120, atk: 8, def: 6, mana: 20, manaMax: 20, spellName: 'Shield Bash', spellCost: 10, spellDesc: 'Stun + 1d8 damage' },
  mage:    { name: 'Mage',    icon: '\u{1F9D9}', hp: 70,  atk: 4, def: 3, mana: 80, manaMax: 80, spellName: 'Fireball', spellCost: 15, spellDesc: '3d6 fire damage' },
  rogue:   { name: 'Rogue',   icon: '\u{1F5E1}\uFE0F', hp: 85,  atk: 7, def: 4, mana: 40, manaMax: 40, spellName: 'Backstab', spellCost: 12, spellDesc: '2d8+DEX damage, high crit' }
};

// ==================== MONSTERS ====================
const MONSTER_TYPES = [
  { name: 'Rat',       icon: '\u{1F400}', hp: 8,   atk: 2,  def: 1,  ac: 8,  xp: 5,   gold: [1, 5],   minFloor: 1 },
  { name: 'Goblin',    icon: '\u{1F47A}', hp: 15,  atk: 4,  def: 2,  ac: 10, xp: 10,  gold: [2, 8],   minFloor: 1 },
  { name: 'Skeleton',  icon: '\u{1F480}', hp: 22,  atk: 5,  def: 3,  ac: 11, xp: 15,  gold: [3, 12],  minFloor: 2 },
  { name: 'Orc',       icon: '\u{1F479}', hp: 35,  atk: 7,  def: 4,  ac: 13, xp: 25,  gold: [5, 20],  minFloor: 3 },
  { name: 'Dark Elf',  icon: '\u{1F9DD}', hp: 28,  atk: 8,  def: 3,  ac: 14, xp: 30,  gold: [8, 25],  minFloor: 4 },
  { name: 'Troll',     icon: '\u{1F9CC}', hp: 50,  atk: 9,  def: 6,  ac: 12, xp: 40,  gold: [10, 30], minFloor: 5 },
  { name: 'Wraith',    icon: '\u{1F47B}', hp: 40,  atk: 10, def: 4,  ac: 15, xp: 45,  gold: [12, 35], minFloor: 6 },
  { name: 'Minotaur',  icon: '\u{1F402}', hp: 65,  atk: 12, def: 7,  ac: 14, xp: 60,  gold: [15, 45], minFloor: 7 },
  { name: 'Dragon',    icon: '\u{1F409}', hp: 100, atk: 15, def: 10, ac: 17, xp: 100, gold: [30, 80], minFloor: 9 },
  { name: 'Demon Lord',icon: '\u{1F608}', hp: 130, atk: 18, def: 12, ac: 18, xp: 150, gold: [50,120], minFloor: 11},
];

// ==================== LOOT TABLES ====================
const WEAPONS = [
  { name: 'Rusty Dagger',   atk: 2,  minFloor: 1, rarity: 'common' },
  { name: 'Short Sword',    atk: 3,  minFloor: 1, rarity: 'common' },
  { name: 'Mace',           atk: 4,  minFloor: 2, rarity: 'common' },
  { name: 'Longsword',      atk: 5,  minFloor: 3, rarity: 'uncommon' },
  { name: 'Battle Axe',     atk: 7,  minFloor: 4, rarity: 'uncommon' },
  { name: 'Warhammer',      atk: 8,  minFloor: 5, rarity: 'rare' },
  { name: 'Flame Blade',    atk: 10, minFloor: 6, rarity: 'rare' },
  { name: 'Vorpal Sword',   atk: 13, minFloor: 8, rarity: 'epic' },
  { name: 'Holy Avenger',   atk: 16, minFloor: 10, rarity: 'legendary' },
];

const ARMORS = [
  { name: 'Leather Vest',    def: 2,  minFloor: 1, rarity: 'common' },
  { name: 'Studded Leather', def: 3,  minFloor: 2, rarity: 'common' },
  { name: 'Chain Shirt',     def: 4,  minFloor: 3, rarity: 'uncommon' },
  { name: 'Scale Mail',      def: 5,  minFloor: 4, rarity: 'uncommon' },
  { name: 'Half Plate',      def: 7,  minFloor: 5, rarity: 'rare' },
  { name: 'Full Plate',      def: 9,  minFloor: 7, rarity: 'rare' },
  { name: 'Mithril Armor',   def: 11, minFloor: 9, rarity: 'epic' },
  { name: 'Dragon Scale',    def: 14, minFloor: 11, rarity: 'legendary' },
];

const RARITY_COLORS = { common: '#aaa', uncommon: '#2ecc71', rare: '#3498db', epic: '#9b59b6', legendary: '#f1c40f' };

// ==================== COMPANION NAMES ====================
const COMPANION_NAMES = [
  'Aldric', 'Brennan', 'Cassian', 'Dorian', 'Elara', 'Fenris',
  'Gwendolyn', 'Hadrian', 'Isolde', 'Jareth', 'Keira', 'Lysander',
  'Morgana', 'Nolan', 'Ophelia', 'Percival', 'Quinn', 'Rowan',
  'Seraphina', 'Theron', 'Ursula', 'Valen', 'Wren', 'Xander',
  'Yara', 'Zephyr', 'Astrid', 'Baldric', 'Cordelia', 'Darian'
];

// ==================== GAME STATE ====================
let player = null;
let party = []; // AI-controlled party members
let charSheetOpen = false;
let map = null;
let monsters = [];
let items = []; // items on the ground
let explored = null; // fog of war
let floor = 1;
let maxFloorReached = 1;
let gameActive = false;
let inCombat = false;
let combatEnemy = null;
let combatPlayerDefending = false;
let combatWaitingForTurns = false; // true while party/enemy turns are processing
let totalKills = 0;
let totalGoldEarned = 0;
let totalDamageDealt = 0;
let moveCount = 0;

const canvas = document.getElementById('dungeon');
const ctx = canvas.getContext('2d');
const miniCanvas = document.getElementById('minimap');
const miniCtx = miniCanvas.getContext('2d');

// ==================== DICE ROLLING ====================
function d(n) { return Math.floor(Math.random() * n) + 1; }
function rollDice(count, sides) {
  let total = 0;
  const rolls = [];
  for (let i = 0; i < count; i++) { const r = d(sides); rolls.push(r); total += r; }
  return { total, rolls, str: `${count}d${sides}[${rolls.join(',')}]=${total}` };
}

// ==================== CHARACTER CREATION ====================
function selectClass(cls) {
  const c = CLASSES[cls];
  player = {
    classId: cls,
    className: c.name,
    icon: c.icon,
    x: 0, y: 0,
    hp: c.hp, maxHp: c.hp,
    mana: c.mana, maxMana: c.manaMax,
    baseAtk: c.atk, baseDef: c.def,
    get atk() { return this.baseAtk + (this.weapon ? this.weapon.atk : 0); },
    get def() { return this.baseDef + (this.armor ? this.armor.def : 0); },
    get ac() { return 10 + this.def; },
    xp: 0, xpNext: 20, level: 1,
    gold: 0,
    weapon: null, armor: null,
    inventory: [],
    spellName: c.spellName,
    spellCost: c.spellCost,
    spellDesc: c.spellDesc,
    potions: 2,
  };
  // Give starting equipment
  if (cls === 'warrior') {
    player.weapon = { name: 'Iron Sword', atk: 3, type: 'weapon', rarity: 'common' };
    player.armor = { name: 'Chain Mail', def: 3, type: 'armor', rarity: 'common' };
  } else if (cls === 'mage') {
    player.weapon = { name: 'Oak Staff', atk: 2, type: 'weapon', rarity: 'common' };
    player.armor = { name: 'Cloth Robe', def: 1, type: 'armor', rarity: 'common' };
  } else {
    player.weapon = { name: 'Twin Daggers', atk: 3, type: 'weapon', rarity: 'common' };
    player.armor = { name: 'Leather Armor', def: 2, type: 'armor', rarity: 'common' };
  }
  player.inventory.push({ name: 'Health Potion', type: 'potion', healType: 'hp', amount: 25, rarity: 'common' });
  player.inventory.push({ name: 'Health Potion', type: 'potion', healType: 'hp', amount: 25, rarity: 'common' });

  // Generate party members
  generateParty(cls);

  document.getElementById('char-select').style.display = 'none';
  document.getElementById('game-container').style.display = 'flex';
  document.getElementById('player-name').textContent = `${c.icon} ${c.name}`;
  document.getElementById('party-panel').style.display = 'block';
  gameActive = true;
  generateFloor();
  render();
}

// ==================== PARTY GENERATION ====================
function generateParty(playerClassId) {
  party = [];
  const classIds = Object.keys(CLASSES);
  // Prefer classes different from the player
  const otherClasses = classIds.filter(c => c !== playerClassId);
  const partyClasses = [];
  // First two get different classes, third picks from any non-player if possible
  for (let i = 0; i < 3; i++) {
    if (i < otherClasses.length) {
      partyClasses.push(otherClasses[i]);
    } else {
      partyClasses.push(otherClasses[Math.floor(Math.random() * otherClasses.length)]);
    }
  }
  // Shuffle party classes
  for (let i = partyClasses.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [partyClasses[i], partyClasses[j]] = [partyClasses[j], partyClasses[i]];
  }

  const usedNames = new Set();
  for (let i = 0; i < 3; i++) {
    let name;
    do {
      name = COMPANION_NAMES[Math.floor(Math.random() * COMPANION_NAMES.length)];
    } while (usedNames.has(name));
    usedNames.add(name);

    const cls = partyClasses[i];
    const c = CLASSES[cls];
    const STAT_SCALE = 0.8; // 80% of player stats

    party.push({
      name: name,
      classId: cls,
      className: c.name,
      icon: c.icon,
      x: 0, y: 0,
      hp: Math.floor(c.hp * STAT_SCALE),
      maxHp: Math.floor(c.hp * STAT_SCALE),
      atk: Math.floor(c.atk * STAT_SCALE),
      def: Math.floor(c.def * STAT_SCALE),
      get ac() { return 10 + this.def; },
      alive: true,
      // Trail positions for following
      trailX: 0,
      trailY: 0,
    });
  }
}

// ==================== DUNGEON GENERATION ====================
function generateFloor() {
  map = Array.from({ length: MAP_H }, () => Array(MAP_W).fill(T.WALL));
  explored = Array.from({ length: MAP_H }, () => Array(MAP_W).fill(false));
  monsters = [];
  items = [];

  const rooms = [];
  const numRooms = 7 + Math.min(floor, 8);
  let attempts = 0;

  while (rooms.length < numRooms && attempts < 300) {
    attempts++;
    const w = 4 + Math.floor(Math.random() * 5);
    const h = 4 + Math.floor(Math.random() * 5);
    const x = 2 + Math.floor(Math.random() * (MAP_W - w - 4));
    const y = 2 + Math.floor(Math.random() * (MAP_H - h - 4));

    let overlap = false;
    for (const r of rooms) {
      if (x - 1 < r.x + r.w && x + w + 1 > r.x && y - 1 < r.y + r.h && y + h + 1 > r.y) {
        overlap = true; break;
      }
    }
    if (overlap) continue;

    rooms.push({ x, y, w, h, cx: Math.floor(x + w / 2), cy: Math.floor(y + h / 2) });
    for (let ry = y; ry < y + h; ry++)
      for (let rx = x; rx < x + w; rx++)
        map[ry][rx] = T.FLOOR;
  }

  // Connect rooms with corridors
  for (let i = 1; i < rooms.length; i++) {
    const a = rooms[i - 1], b = rooms[i];
    carveCorridor(a.cx, a.cy, b.cx, b.cy);
  }
  // Extra connections for loops
  for (let i = 0; i < Math.floor(rooms.length / 3); i++) {
    const a = rooms[Math.floor(Math.random() * rooms.length)];
    const b = rooms[Math.floor(Math.random() * rooms.length)];
    if (a !== b) carveCorridor(a.cx, a.cy, b.cx, b.cy);
  }

  // Place doors at room entrances
  for (const room of rooms) {
    for (let rx = room.x; rx < room.x + room.w; rx++) {
      checkDoor(rx, room.y - 1, room);
      checkDoor(rx, room.y + room.h, room);
    }
    for (let ry = room.y; ry < room.y + room.h; ry++) {
      checkDoor(room.x - 1, ry, room);
      checkDoor(room.x + room.w, ry, room);
    }
  }

  // Player start in first room
  player.x = rooms[0].cx;
  player.y = rooms[0].cy;

  // Position party members near player
  const partyOffsets = [[0, 1], [1, 0], [-1, 0], [0, -1], [1, 1], [-1, 1]];
  let offsetIdx = 0;
  for (const pm of party) {
    if (!pm.alive) continue;
    let placed = false;
    while (offsetIdx < partyOffsets.length && !placed) {
      const ox = player.x + partyOffsets[offsetIdx][0];
      const oy = player.y + partyOffsets[offsetIdx][1];
      if (ox >= 0 && ox < MAP_W && oy >= 0 && oy < MAP_H && map[oy][ox] !== T.WALL) {
        pm.x = ox;
        pm.y = oy;
        pm.trailX = ox;
        pm.trailY = oy;
        placed = true;
      }
      offsetIdx++;
    }
    if (!placed) {
      pm.x = player.x;
      pm.y = player.y;
      pm.trailX = player.x;
      pm.trailY = player.y;
    }
  }

  // Stairs in last room
  const lastRoom = rooms[rooms.length - 1];
  map[lastRoom.cy][lastRoom.cx] = T.STAIRS;

  // Place monsters
  const monsterCount = 5 + floor * 2 + Math.floor(Math.random() * 3);
  for (let i = 0; i < monsterCount; i++) {
    const room = rooms[1 + Math.floor(Math.random() * (rooms.length - 1))]; // not first room
    const mx = room.x + 1 + Math.floor(Math.random() * (room.w - 2));
    const my = room.y + 1 + Math.floor(Math.random() * (room.h - 2));
    const onPartyMember = party.some(pm => pm.alive && pm.x === mx && pm.y === my);
    if (map[my][mx] === T.FLOOR && !(mx === player.x && my === player.y) && !onPartyMember) {
      const eligible = MONSTER_TYPES.filter(m => m.minFloor <= floor);
      // Weight toward harder monsters on deeper floors
      const weights = eligible.map(m => {
        const diff = floor - m.minFloor;
        return diff <= 2 ? 3 : (diff <= 5 ? 2 : 1);
      });
      const totalW = weights.reduce((a, b) => a + b, 0);
      let r = Math.random() * totalW;
      let mType = eligible[0];
      for (let j = 0; j < eligible.length; j++) {
        r -= weights[j];
        if (r <= 0) { mType = eligible[j]; break; }
      }
      const scaling = 1 + (floor - 1) * 0.12;
      monsters.push({
        ...mType,
        x: mx, y: my,
        hp: Math.floor(mType.hp * scaling),
        maxHp: Math.floor(mType.hp * scaling),
        atk: Math.floor(mType.atk * scaling),
        def: Math.floor(mType.def * scaling),
        ac: mType.ac + Math.floor((floor - 1) / 3),
        xp: Math.floor(mType.xp * scaling),
        gold: [Math.floor(mType.gold[0] * scaling), Math.floor(mType.gold[1] * scaling)],
      });
    }
  }

  // Place ground items
  const itemCount = 3 + Math.floor(Math.random() * 3) + Math.floor(floor / 2);
  for (let i = 0; i < itemCount; i++) {
    const room = rooms[1 + Math.floor(Math.random() * (rooms.length - 1))];
    const ix = room.x + 1 + Math.floor(Math.random() * (room.w - 2));
    const iy = room.y + 1 + Math.floor(Math.random() * (room.h - 2));
    if (map[iy][ix] === T.FLOOR) {
      const r = Math.random();
      if (r < 0.4) {
        // Gold pile
        const amt = d(10) + floor * 3;
        items.push({ x: ix, y: iy, type: 'gold', amount: amt, icon: '\u{1FA99}', name: `${amt} Gold` });
      } else if (r < 0.65) {
        // Health Potion
        const amt = 20 + floor * 5;
        items.push({ x: ix, y: iy, type: 'potion', healType: 'hp', amount: amt, icon: '\u{1F9EA}', name: 'Health Potion', rarity: 'common' });
      } else if (r < 0.78) {
        // Mana Potion
        const amt = 15 + floor * 3;
        items.push({ x: ix, y: iy, type: 'potion', healType: 'mana', amount: amt, icon: '\u{1F4A7}', name: 'Mana Potion', rarity: 'common' });
      } else if (r < 0.9) {
        // Weapon
        const eligible = WEAPONS.filter(w => w.minFloor <= floor + 1);
        const w = eligible[Math.floor(Math.random() * eligible.length)];
        const bonus = Math.floor(Math.random() * Math.ceil(floor / 3));
        items.push({ x: ix, y: iy, type: 'weapon', atk: w.atk + bonus, icon: '\u2694\uFE0F', name: bonus > 0 ? `${w.name} +${bonus}` : w.name, rarity: w.rarity });
      } else {
        // Armor
        const eligible = ARMORS.filter(a => a.minFloor <= floor + 1);
        const a = eligible[Math.floor(Math.random() * eligible.length)];
        const bonus = Math.floor(Math.random() * Math.ceil(floor / 3));
        items.push({ x: ix, y: iy, type: 'armor', def: a.def + bonus, icon: '\u{1F6E1}\uFE0F', name: bonus > 0 ? `${a.name} +${bonus}` : a.name, rarity: a.rarity });
      }
    }
  }

  revealFog();
  updateHUD();
  addMessage(`Entered Floor ${floor}. Beware!`);
}

function carveCorridor(x1, y1, x2, y2) {
  let x = x1, y = y1;
  while (x !== x2) {
    if (map[y][x] === T.WALL) map[y][x] = T.CORRIDOR;
    x += x < x2 ? 1 : -1;
  }
  while (y !== y2) {
    if (map[y][x] === T.WALL) map[y][x] = T.CORRIDOR;
    y += y < y2 ? 1 : -1;
  }
  if (map[y][x] === T.WALL) map[y][x] = T.CORRIDOR;
}

function checkDoor(x, y, room) {
  if (x < 1 || x >= MAP_W - 1 || y < 1 || y >= MAP_H - 1) return;
  if (map[y][x] === T.CORRIDOR) {
    // Check if it's a transition from room to corridor
    const adjFloor = (map[y-1] && (map[y-1][x] === T.FLOOR)) || (map[y+1] && (map[y+1][x] === T.FLOOR)) ||
                     (map[y][x-1] === T.FLOOR) || (map[y][x+1] === T.FLOOR);
    if (adjFloor && Math.random() < 0.4) {
      map[y][x] = T.DOOR;
    }
  }
}

// ==================== FOG OF WAR ====================
function revealFog() {
  const px = player.x, py = player.y;
  const r = FOG_RADIUS;
  for (let dy = -r; dy <= r; dy++) {
    for (let dx = -r; dx <= r; dx++) {
      const nx = px + dx, ny = py + dy;
      if (nx >= 0 && nx < MAP_W && ny >= 0 && ny < MAP_H) {
        if (dx * dx + dy * dy <= r * r) {
          // Raycasting for line of sight
          if (hasLineOfSight(px, py, nx, ny)) {
            explored[ny][nx] = true;
          }
        }
      }
    }
  }
}

function hasLineOfSight(x0, y0, x1, y1) {
  const dx = Math.abs(x1 - x0), dy = Math.abs(y1 - y0);
  const sx = x0 < x1 ? 1 : -1, sy = y0 < y1 ? 1 : -1;
  let err = dx - dy;
  let x = x0, y = y0;
  while (true) {
    if (x === x1 && y === y1) return true;
    if (map[y][x] === T.WALL && !(x === x0 && y === y0)) return false;
    const e2 = 2 * err;
    if (e2 > -dy) { err -= dy; x += sx; }
    if (e2 < dx)  { err += dx; y += sy; }
  }
}

function isVisible(x, y) {
  const dx = x - player.x, dy = y - player.y;
  return dx * dx + dy * dy <= FOG_RADIUS * FOG_RADIUS;
}

// ==================== RENDERING ====================
const TILE_COLORS = {
  [T.WALL]:     '#1a1a2e',
  [T.FLOOR]:    '#2a2a3e',
  [T.DOOR]:     '#3a3020',
  [T.STAIRS]:   '#2a3a2a',
  [T.CORRIDOR]: '#252535',
};

const WALL_COLOR_VISIBLE = '#2a2a4e';
const WALL_BORDER = '#3a3a5e';

function render() {
  if (!gameActive) return;
  ctx.fillStyle = '#0a0a0f';
  ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

  // Camera centered on player
  const camX = player.x - Math.floor(VIEW_TILES / 2);
  const camY = player.y - Math.floor(VIEW_TILES / 2);

  for (let vy = 0; vy < VIEW_TILES; vy++) {
    for (let vx = 0; vx < VIEW_TILES; vx++) {
      const mx = camX + vx, my = camY + vy;
      if (mx < 0 || mx >= MAP_W || my < 0 || my >= MAP_H) continue;

      const px = vx * TILE, py = vy * TILE;
      const vis = isVisible(mx, my);
      const exp = explored[my][mx];

      if (!exp) continue;

      const tile = map[my][mx];
      const alpha = vis ? 1 : 0.35;

      ctx.globalAlpha = alpha;

      // Draw tile
      if (tile === T.WALL) {
        ctx.fillStyle = WALL_COLOR_VISIBLE;
        ctx.fillRect(px, py, TILE, TILE);
        ctx.strokeStyle = WALL_BORDER;
        ctx.lineWidth = 0.5;
        ctx.strokeRect(px + 0.5, py + 0.5, TILE - 1, TILE - 1);
        // Wall top shading
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.fillRect(px, py, TILE, TILE / 3);
      } else if (tile === T.FLOOR || tile === T.CORRIDOR) {
        ctx.fillStyle = TILE_COLORS[tile];
        ctx.fillRect(px, py, TILE, TILE);
        // Subtle grid
        ctx.strokeStyle = 'rgba(255,255,255,0.03)';
        ctx.lineWidth = 0.5;
        ctx.strokeRect(px, py, TILE, TILE);
      } else if (tile === T.DOOR) {
        ctx.fillStyle = TILE_COLORS[T.FLOOR];
        ctx.fillRect(px, py, TILE, TILE);
        ctx.fillStyle = '#6a5030';
        ctx.fillRect(px + 4, py + 2, TILE - 8, TILE - 4);
        ctx.fillStyle = '#f1c40f';
        ctx.fillRect(px + TILE / 2 - 1, py + TILE / 2 - 1, 3, 3);
      } else if (tile === T.STAIRS) {
        ctx.fillStyle = TILE_COLORS[T.STAIRS];
        ctx.fillRect(px, py, TILE, TILE);
        ctx.font = `${TILE - 6}px serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('\u{1FA9C}', px + TILE / 2, py + TILE / 2 + 2);
      }

      ctx.globalAlpha = 1;
    }
  }

  // Draw items on ground
  for (const item of items) {
    if (!isVisible(item.x, item.y)) continue;
    const sx = (item.x - camX) * TILE, sy = (item.y - camY) * TILE;
    if (sx < -TILE || sx > CANVAS_SIZE || sy < -TILE || sy > CANVAS_SIZE) continue;
    ctx.font = `${TILE - 10}px serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(item.icon, sx + TILE / 2, sy + TILE / 2 + 2);
  }

  // Draw monsters
  for (const m of monsters) {
    if (!isVisible(m.x, m.y)) continue;
    const sx = (m.x - camX) * TILE, sy = (m.y - camY) * TILE;
    if (sx < -TILE || sx > CANVAS_SIZE || sy < -TILE || sy > CANVAS_SIZE) continue;
    ctx.font = `${TILE - 6}px serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(m.icon, sx + TILE / 2, sy + TILE / 2 + 2);
    // HP bar above monster
    const hpPct = m.hp / m.maxHp;
    const barW = TILE - 4;
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.fillRect(sx + 2, sy - 2, barW, 4);
    ctx.fillStyle = hpPct > 0.5 ? '#2ecc71' : hpPct > 0.25 ? '#f39c12' : '#e74c3c';
    ctx.fillRect(sx + 2, sy - 2, barW * hpPct, 4);
  }

  // Draw party members
  for (const pm of party) {
    if (!pm.alive) continue;
    if (!isVisible(pm.x, pm.y)) continue;
    const sx = (pm.x - camX) * TILE, sy = (pm.y - camY) * TILE;
    if (sx < -TILE || sx > CANVAS_SIZE || sy < -TILE || sy > CANVAS_SIZE) continue;
    // Subtle blue glow for companions
    ctx.shadowColor = '#3498db';
    ctx.shadowBlur = 6;
    ctx.font = `${TILE - 6}px serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(pm.icon, sx + TILE / 2, sy + TILE / 2 + 2);
    ctx.shadowBlur = 0;
    // Small HP bar above companion
    const hpPct = pm.hp / pm.maxHp;
    const barW = TILE - 4;
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.fillRect(sx + 2, sy - 2, barW, 4);
    ctx.fillStyle = hpPct > 0.5 ? '#3498db' : hpPct > 0.25 ? '#f39c12' : '#e74c3c';
    ctx.fillRect(sx + 2, sy - 2, barW * hpPct, 4);
  }

  // Draw player
  {
    const sx = (player.x - camX) * TILE, sy = (player.y - camY) * TILE;
    // Glow effect
    ctx.shadowColor = '#f1c40f';
    ctx.shadowBlur = 10;
    ctx.font = `${TILE - 4}px serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(player.icon, sx + TILE / 2, sy + TILE / 2 + 2);
    ctx.shadowBlur = 0;
  }

  // Fog of war darkening
  for (let vy = 0; vy < VIEW_TILES; vy++) {
    for (let vx = 0; vx < VIEW_TILES; vx++) {
      const mx = camX + vx, my = camY + vy;
      if (mx < 0 || mx >= MAP_W || my < 0 || my >= MAP_H) continue;
      if (!explored[my][mx]) {
        ctx.fillStyle = '#0a0a0f';
        ctx.fillRect(vx * TILE, vy * TILE, TILE, TILE);
      }
    }
  }

  renderMinimap();
}

function renderMinimap() {
  const mw = miniCanvas.width, mh = miniCanvas.height;
  miniCtx.fillStyle = 'rgba(0,0,0,0.8)';
  miniCtx.fillRect(0, 0, mw, mh);
  const sx = mw / MAP_W, sy = mh / MAP_H;

  for (let y = 0; y < MAP_H; y++) {
    for (let x = 0; x < MAP_W; x++) {
      if (!explored[y][x]) continue;
      const tile = map[y][x];
      if (tile === T.WALL) continue;
      miniCtx.fillStyle = tile === T.STAIRS ? '#2ecc71' : tile === T.DOOR ? '#6a5030' : '#445';
      miniCtx.fillRect(x * sx, y * sy, Math.max(sx, 1.5), Math.max(sy, 1.5));
    }
  }

  // Monsters on minimap
  for (const m of monsters) {
    if (!explored[m.y][m.x]) continue;
    miniCtx.fillStyle = '#e74c3c';
    miniCtx.fillRect(m.x * sx, m.y * sy, Math.max(sx * 1.5, 2), Math.max(sy * 1.5, 2));
  }

  // Party members on minimap
  for (const pm of party) {
    if (!pm.alive) continue;
    if (!explored[pm.y] || !explored[pm.y][pm.x]) continue;
    miniCtx.fillStyle = '#3498db';
    miniCtx.fillRect(pm.x * sx, pm.y * sy, Math.max(sx * 1.5, 2), Math.max(sy * 1.5, 2));
  }

  // Player
  miniCtx.fillStyle = '#f1c40f';
  miniCtx.fillRect(player.x * sx - 1, player.y * sy - 1, Math.max(sx * 2, 3), Math.max(sy * 2, 3));
}

// ==================== HUD ====================
function updateHUD() {
  document.getElementById('s-level').textContent = player.level;
  document.getElementById('s-floor').textContent = floor;
  document.getElementById('s-gold').textContent = player.gold;
  document.getElementById('s-hp').textContent = `${player.hp}/${player.maxHp}`;
  document.getElementById('s-mana').textContent = `${player.mana}/${player.maxMana}`;
  document.getElementById('s-xp').textContent = `${player.xp}/${player.xpNext}`;
  document.getElementById('s-atk').textContent = player.atk;
  document.getElementById('s-def').textContent = player.def;
  document.getElementById('s-ac').textContent = player.ac;
  document.getElementById('s-weapon').textContent = player.weapon ? player.weapon.name : 'Fists';
  document.getElementById('s-armor').textContent = player.armor ? player.armor.name : 'None';
  document.getElementById('bar-hp').style.width = `${(player.hp / player.maxHp) * 100}%`;
  document.getElementById('bar-mana').style.width = `${(player.mana / player.maxMana) * 100}%`;
  document.getElementById('bar-xp').style.width = `${(player.xp / player.xpNext) * 100}%`;
  renderInventory();
  renderPartyPanel();
}

function renderInventory() {
  const el = document.getElementById('inventory-list');
  let html = '';
  // Show potions count
  const hpPots = player.inventory.filter(i => i.type === 'potion' && i.healType === 'hp');
  const manaPots = player.inventory.filter(i => i.type === 'potion' && i.healType === 'mana');
  if (hpPots.length > 0) {
    html += `<div class="inv-item" onclick="usePotion('hp')" title="Click or press I to use"><span class="item-name">\u{1F9EA} Health Potion x${hpPots.length}</span><span class="item-stat heal-color">+${hpPots[0].amount} HP</span></div>`;
  }
  if (manaPots.length > 0) {
    html += `<div class="inv-item" onclick="usePotion('mana')" title="Click to use"><span class="item-name">\u{1F4A7} Mana Potion x${manaPots.length}</span><span class="item-stat mana-color">+${manaPots[0].amount} MP</span></div>`;
  }

  // Equipment in inventory
  const equips = player.inventory.filter(i => i.type === 'weapon' || i.type === 'armor');
  equips.forEach((item, idx) => {
    const equipped = (item === player.weapon || item === player.armor);
    const color = RARITY_COLORS[item.rarity] || '#aaa';
    const stat = item.type === 'weapon' ? `+${item.atk} ATK` : `+${item.def} DEF`;
    const icon = item.type === 'weapon' ? '\u2694\uFE0F' : '\u{1F6E1}\uFE0F';
    html += `<div class="inv-item${equipped ? ' equipped' : ''}" onclick="equipItem(${idx})" title="${equipped ? 'Equipped' : 'Click to equip'}" style="color:${color}">
      <span class="item-name">${icon} ${item.name}${equipped ? ' [E]' : ''}</span><span class="item-stat">${stat}</span></div>`;
  });

  if (!html) html = '<div style="color:#555;text-align:center;padding:8px">Empty</div>';
  el.innerHTML = html;
}

function renderPartyPanel() {
  const el = document.getElementById('party-list');
  if (!el) return;
  let html = '';
  for (const pm of party) {
    const hpPct = pm.alive ? Math.max(0, (pm.hp / pm.maxHp) * 100) : 0;
    const barColor = !pm.alive ? '#555' : (hpPct > 50 ? '#3498db' : hpPct > 25 ? '#f39c12' : '#e74c3c');
    html += `<div class="party-member${pm.alive ? '' : ' pm-dead'}">
      <div class="pm-header">
        <span class="pm-name">${pm.icon} ${pm.name}</span>
        <span class="pm-class">${pm.className}${pm.alive ? '' : ' (Dead)'}</span>
      </div>
      <div style="display:flex;justify-content:space-between;font-size:9px;color:#888">
        <span>HP</span><span>${pm.alive ? pm.hp + '/' + pm.maxHp : 'Dead'}</span>
      </div>
      <div class="bar-outer"><div class="bar-inner" style="width:${hpPct}%;background:${barColor};border-radius:6px"></div></div>
    </div>`;
  }
  el.innerHTML = html;
}

function usePotion(type) {
  const idx = player.inventory.findIndex(i => i.type === 'potion' && i.healType === type);
  if (idx === -1) { addMessage('No potions of that type!'); return; }
  const pot = player.inventory[idx];
  player.inventory.splice(idx, 1);
  if (type === 'hp') {
    const healed = Math.min(pot.amount, player.maxHp - player.hp);
    player.hp += healed;
    addMessage(`Used Health Potion. +${healed} HP`, 'heal-color');
  } else {
    const restored = Math.min(pot.amount, player.maxMana - player.mana);
    player.mana += restored;
    addMessage(`Used Mana Potion. +${restored} Mana`, 'mana-color');
  }
  playSound('potion');
  updateHUD();
  render();
}

function equipItem(invIdx) {
  const equips = player.inventory.filter(i => i.type === 'weapon' || i.type === 'armor');
  const item = equips[invIdx];
  if (!item) return;
  if (item.type === 'weapon') {
    player.weapon = item;
    addMessage(`Equipped ${item.name}`);
  } else {
    player.armor = item;
    addMessage(`Equipped ${item.name}`);
  }
  playSound('pickup');
  updateHUD();
  render();
}

function autoEquipBest() {
  const weapons = player.inventory.filter(i => i.type === 'weapon');
  const armors = player.inventory.filter(i => i.type === 'armor');
  let changed = false;
  if (weapons.length) {
    const best = weapons.reduce((a, b) => a.atk >= b.atk ? a : b);
    if (!player.weapon || best.atk > player.weapon.atk) { player.weapon = best; changed = true; }
  }
  if (armors.length) {
    const best = armors.reduce((a, b) => a.def >= b.def ? a : b);
    if (!player.armor || best.def > player.armor.def) { player.armor = best; changed = true; }
  }
  if (changed) { addMessage('Equipped best gear!'); playSound('pickup'); }
  else addMessage('Already using best gear.');
  updateHUD();
  render();
}

// ==================== MESSAGES ====================
function addMessage(text, cls) {
  const log = document.getElementById('msg-log');
  const div = document.createElement('div');
  div.className = 'msg' + (cls ? ` ${cls}` : '');
  div.textContent = text;
  log.appendChild(div);
  if (log.children.length > 5) log.removeChild(log.firstChild);
  setTimeout(() => { if (div.parentNode) div.remove(); }, 3500);
}

// ==================== MOVEMENT ====================
function tryMove(dx, dy) {
  if (!gameActive || inCombat) return;
  const nx = player.x + dx, ny = player.y + dy;
  if (nx < 0 || nx >= MAP_W || ny < 0 || ny >= MAP_H) return;

  const tile = map[ny][nx];
  if (tile === T.WALL) return;

  // Check for monster
  const mon = monsters.find(m => m.x === nx && m.y === ny);
  if (mon) {
    startCombat(mon);
    return;
  }

  // Move party members (trail behind player)
  movePartyMembers(player.x, player.y);

  // Move
  player.x = nx;
  player.y = ny;
  moveCount++;

  if (tile === T.DOOR) {
    playSound('door');
    map[ny][nx] = T.FLOOR; // Open the door
    addMessage('You open a door.');
  }

  // Pick up items
  const groundItems = items.filter(i => i.x === nx && i.y === ny);
  for (const gi of groundItems) {
    if (gi.type === 'gold') {
      player.gold += gi.amount;
      totalGoldEarned += gi.amount;
      addMessage(`Found ${gi.amount} gold!`, 'gold-color');
      playSound('pickup');
    } else {
      player.inventory.push(gi);
      const color = RARITY_COLORS[gi.rarity] || '#aaa';
      addMessage(`Found ${gi.name}!`);
      playSound('pickup');
    }
    items.splice(items.indexOf(gi), 1);
  }

  // Stairs
  if (tile === T.STAIRS) {
    floor++;
    if (floor > maxFloorReached) maxFloorReached = floor;
    addMessage(`Descending to Floor ${floor}...`);
    playSound('stairs');
    // Small heal on floor change
    const healAmt = Math.floor(player.maxHp * 0.1);
    player.hp = Math.min(player.maxHp, player.hp + healAmt);
    const manaAmt = Math.floor(player.maxMana * 0.15);
    player.mana = Math.min(player.maxMana, player.mana + manaAmt);
    // Heal living party members too
    for (const pm of party) {
      if (pm.alive) {
        const pmHeal = Math.floor(pm.maxHp * 0.1);
        pm.hp = Math.min(pm.maxHp, pm.hp + pmHeal);
      }
    }
    generateFloor();
  }

  // Regenerate 1 mana per move
  if (player.mana < player.maxMana) player.mana = Math.min(player.maxMana, player.mana + 1);

  revealFog();
  moveMonsters();
  updateHUD();
  render();
}

function movePartyMembers(targetX, targetY) {
  // Party members chain-follow: first follows old player pos, second follows first's old pos, etc.
  let leaderX = targetX;
  let leaderY = targetY;
  for (const pm of party) {
    if (!pm.alive) continue;
    const dist = Math.abs(pm.x - leaderX) + Math.abs(pm.y - leaderY);
    if (dist > 1) {
      // Move toward leader position
      const dx = leaderX - pm.x;
      const dy = leaderY - pm.y;
      let mx = 0, my = 0;
      if (Math.abs(dx) > Math.abs(dy)) mx = dx > 0 ? 1 : -1;
      else if (dy !== 0) my = dy > 0 ? 1 : -1;
      else if (dx !== 0) mx = dx > 0 ? 1 : -1;

      const nx = pm.x + mx, ny = pm.y + my;
      if (nx >= 0 && nx < MAP_W && ny >= 0 && ny < MAP_H &&
          map[ny][nx] !== T.WALL &&
          !(nx === player.x && ny === player.y) &&
          !monsters.some(m => m.x === nx && m.y === ny) &&
          !party.some(op => op !== pm && op.alive && op.x === nx && op.y === ny)) {
        const oldX = pm.x, oldY = pm.y;
        pm.x = nx;
        pm.y = ny;
        leaderX = oldX;
        leaderY = oldY;
      } else {
        leaderX = pm.x;
        leaderY = pm.y;
      }
    } else {
      // Already adjacent, just chain
      leaderX = pm.x;
      leaderY = pm.y;
    }
  }
}

function moveMonsters() {
  for (const m of monsters) {
    const dx = player.x - m.x, dy = player.y - m.y;
    const dist = Math.abs(dx) + Math.abs(dy);
    if (dist <= 6 && dist > 1 && isVisible(m.x, m.y)) {
      // Chase player
      let mx = 0, my = 0;
      if (Math.abs(dx) > Math.abs(dy)) mx = dx > 0 ? 1 : -1;
      else my = dy > 0 ? 1 : -1;

      const nx = m.x + mx, ny = m.y + my;
      if (nx >= 0 && nx < MAP_W && ny >= 0 && ny < MAP_H &&
          map[ny][nx] !== T.WALL &&
          !(nx === player.x && ny === player.y) &&
          !monsters.some(om => om !== m && om.x === nx && om.y === ny) &&
          !party.some(pm => pm.alive && pm.x === nx && pm.y === ny)) {
        m.x = nx;
        m.y = ny;
      }

      // Check if adjacent to player now
      if (Math.abs(m.x - player.x) + Math.abs(m.y - player.y) === 1) {
        // Monster initiates combat
        startCombat(m);
        return;
      }
    }
  }
}

// ==================== COMBAT ====================
function startCombat(monster) {
  inCombat = true;
  combatEnemy = monster;
  combatPlayerDefending = false;
  const overlay = document.getElementById('combat-overlay');
  overlay.style.display = 'flex';
  document.getElementById('combat-title').textContent = `${monster.icon} ${monster.name} appears!`;
  document.getElementById('combat-log').innerHTML = `<div class="info">A ${monster.name} blocks your path! (AC ${monster.ac})</div>`;
  updateCombatInfo();
  showCombatActions();
}

function updateCombatInfo() {
  document.getElementById('combat-player-info').innerHTML = `
    <div style="font-size:32px">${player.icon}</div>
    <div style="color:#f1c40f">${player.className} Lv${player.level}</div>
    <div>HP: ${player.hp}/${player.maxHp}</div>
    <div style="color:#3498db">Mana: ${player.mana}/${player.maxMana}</div>
    <div style="color:#888">ATK: ${player.atk} | AC: ${player.ac}</div>`;
  document.getElementById('combat-enemy-info').innerHTML = `
    <div style="font-size:32px">${combatEnemy.icon}</div>
    <div style="color:#e74c3c">${combatEnemy.name}</div>
    <div>HP: ${combatEnemy.hp}/${combatEnemy.maxHp}</div>
    <div style="color:#888">AC: ${combatEnemy.ac}</div>`;

  // Update combat party info
  const partyEl = document.getElementById('combat-party-info');
  let partyHtml = '';
  for (const pm of party) {
    partyHtml += `<div class="combat-pm${pm.alive ? '' : ' dead'}">
      <div class="cpm-name">${pm.icon} ${pm.name}</div>
      <div class="cpm-hp">${pm.alive ? pm.hp + '/' + pm.maxHp + ' HP' : 'Dead'}</div>
    </div>`;
  }
  partyEl.innerHTML = partyHtml;
}

function showCombatActions() {
  combatWaitingForTurns = false;
  const acts = document.getElementById('combat-actions');
  acts.innerHTML = `
    <button class="btn-attack" onclick="combatAction('attack')">[1] &#x2694;&#xFE0F; Attack</button>
    <button class="btn-defend" onclick="combatAction('defend')">[2] &#x1F6E1;&#xFE0F; Defend</button>
    <button class="btn-spell" onclick="combatAction('spell')" ${player.mana < player.spellCost ? 'disabled title="Not enough mana"' : ''}>[3] &#x2728; ${player.spellName} (${player.spellCost} MP)</button>
    <button class="btn-flee" onclick="combatAction('flee')">[4] &#x1F3C3; Flee</button>`;
}

function combatAction(action) {
  if (combatWaitingForTurns) return; // Prevent actions during party/enemy turns
  const log = document.getElementById('combat-log');
  combatPlayerDefending = false;
  let turnOver = false;

  if (action === 'attack') {
    // Player attacks: d20 + ATK vs enemy AC
    const roll = d(20);
    const total = roll + player.atk;
    const crit = roll === 20;
    const hit = crit || total >= combatEnemy.ac;

    if (hit) {
      let dmg;
      if (crit) {
        dmg = rollDice(2, 6).total + player.atk;
        log.innerHTML += `<div class="roll">You rolled <b>NAT 20!</b> + ${player.atk} ATK = CRITICAL HIT!</div>`;
        log.innerHTML += `<div class="hit">&#x1F4A5; CRIT! You deal <b>${dmg}</b> damage!</div>`;
        playSound('crit');
      } else {
        dmg = rollDice(1, 8).total + Math.floor(player.atk / 2);
        log.innerHTML += `<div class="roll">You rolled ${roll} + ${player.atk} ATK = ${total} vs AC ${combatEnemy.ac} - HIT!</div>`;
        log.innerHTML += `<div class="hit">You deal <b>${dmg}</b> damage!</div>`;
        playSound('hit');
      }
      combatEnemy.hp -= dmg;
      totalDamageDealt += dmg;
    } else {
      log.innerHTML += `<div class="roll">You rolled ${roll} + ${player.atk} ATK = ${total} vs AC ${combatEnemy.ac} - MISS!</div>`;
      log.innerHTML += `<div class="miss">Your attack misses!</div>`;
      playSound('miss');
    }
    turnOver = true;
  } else if (action === 'defend') {
    combatPlayerDefending = true;
    log.innerHTML += `<div class="info">&#x1F6E1;&#xFE0F; You raise your guard! (+5 AC this turn, heal 1d4)</div>`;
    const heal = d(4);
    player.hp = Math.min(player.maxHp, player.hp + heal);
    log.innerHTML += `<div class="heal">You recover ${heal} HP while defending.</div>`;
    playSound('defend');
    turnOver = true;
  } else if (action === 'spell') {
    if (player.mana < player.spellCost) {
      log.innerHTML += `<div class="miss">Not enough mana!</div>`;
      return;
    }
    player.mana -= player.spellCost;
    playSound('spell');

    if (player.classId === 'warrior') {
      // Shield Bash: 1d8 + DEF damage, stun (enemy skips turn)
      const dmg = rollDice(1, 8).total + player.def;
      combatEnemy.hp -= dmg;
      totalDamageDealt += dmg;
      log.innerHTML += `<div class="roll">&#x2728; Shield Bash! 1d8 + ${player.def} DEF = ${dmg} damage!</div>`;
      log.innerHTML += `<div class="info">The enemy is stunned and loses their turn!</div>`;
      // Check enemy death
      if (combatEnemy.hp <= 0) { endCombat(true); return; }
      // Party members still attack, but enemy turn is skipped
      const livingParty = party.filter(pm => pm.alive);
      if (livingParty.length > 0) {
        combatWaitingForTurns = true;
        const acts = document.getElementById('combat-actions');
        const buttons = acts.querySelectorAll('button');
        buttons.forEach(b => b.disabled = true);
        let delay = 400;
        for (let i = 0; i < livingParty.length; i++) {
          const pm = livingParty[i];
          setTimeout(() => {
            if (combatEnemy.hp <= 0) return;
            const roll2 = d(20);
            const total2 = roll2 + pm.atk;
            const crit2 = roll2 === 20;
            const hit2 = crit2 || total2 >= combatEnemy.ac;
            if (hit2) {
              let dmg2;
              if (crit2) {
                dmg2 = rollDice(2, 6).total + pm.atk;
                log.innerHTML += `<div class="roll">Companion ${pm.name} (${pm.className}) rolled <b>NAT 20!</b> + ${pm.atk} = CRITICAL HIT!</div>`;
                log.innerHTML += `<div class="hit">Companion ${pm.name} deals <b>${dmg2}</b> damage!</div>`;
                playSound('crit');
              } else {
                dmg2 = rollDice(1, 6).total + Math.floor(pm.atk / 2);
                log.innerHTML += `<div class="roll">Companion ${pm.name} (${pm.className}) rolled ${roll2} + ${pm.atk} = ${total2} vs AC ${combatEnemy.ac} - HIT! ${dmg2} damage</div>`;
                playSound('hit');
              }
              combatEnemy.hp -= dmg2;
              totalDamageDealt += dmg2;
            } else {
              log.innerHTML += `<div class="roll">Companion ${pm.name} (${pm.className}) rolled ${roll2} + ${pm.atk} = ${total2} vs AC ${combatEnemy.ac} - MISS!</div>`;
              playSound('miss');
            }
            updateCombatInfo();
            log.scrollTop = log.scrollHeight;
            if (i === livingParty.length - 1) {
              if (combatEnemy.hp <= 0) { endCombat(true); return; }
              // Enemy stunned, skip to player actions
              updateCombatInfo();
              showCombatActions();
            }
          }, delay);
          delay += 350;
        }
      } else {
        updateCombatInfo();
        showCombatActions();
      }
      log.scrollTop = log.scrollHeight;
      return;
    } else if (player.classId === 'mage') {
      // Fireball: 3d6 damage, auto-hit
      const roll = rollDice(3, 6);
      const dmg = roll.total;
      combatEnemy.hp -= dmg;
      totalDamageDealt += dmg;
      log.innerHTML += `<div class="roll">&#x1F525; Fireball! ${roll.str} = ${dmg} fire damage!</div>`;
    } else {
      // Backstab: 2d8 + DEX, 30% crit
      const crit = Math.random() < 0.3;
      const roll = rollDice(crit ? 4 : 2, 8);
      const dmg = roll.total + player.atk;
      combatEnemy.hp -= dmg;
      totalDamageDealt += dmg;
      if (crit) {
        log.innerHTML += `<div class="roll">&#x1F5E1;&#xFE0F; Backstab CRITICAL! ${roll.str} + ${player.atk} = ${dmg} damage!</div>`;
        playSound('crit');
      } else {
        log.innerHTML += `<div class="roll">&#x1F5E1;&#xFE0F; Backstab! ${roll.str} + ${player.atk} = ${dmg} damage!</div>`;
      }
    }
    turnOver = true;
  } else if (action === 'flee') {
    const roll = d(20);
    if (roll >= 10) {
      log.innerHTML += `<div class="roll">Flee roll: ${roll} - Success! You escape!</div>`;
      inCombat = false;
      document.getElementById('combat-overlay').style.display = 'none';
      // Move player back
      const dirs = [[-1,0],[1,0],[0,-1],[0,1]];
      for (const [dx, dy] of dirs) {
        const nx = player.x + dx, ny = player.y + dy;
        if (nx >= 0 && nx < MAP_W && ny >= 0 && ny < MAP_H && map[ny][nx] !== T.WALL && !monsters.some(m => m.x === nx && m.y === ny)) {
          player.x = nx; player.y = ny; break;
        }
      }
      addMessage('You fled from battle!');
      updateHUD();
      render();
      return;
    } else {
      log.innerHTML += `<div class="roll">Flee roll: ${roll} - Failed! You can\'t escape!</div>`;
      turnOver = true;
    }
  }

  // Check enemy death
  if (combatEnemy.hp <= 0) {
    endCombat(true);
    return;
  }

  // Party members attack, then enemy turn
  if (turnOver) {
    // Disable actions during party/enemy turns
    combatWaitingForTurns = true;
    const acts = document.getElementById('combat-actions');
    const buttons = acts.querySelectorAll('button');
    buttons.forEach(b => b.disabled = true);

    setTimeout(() => partyMembersTurn(), 400);
  }

  updateCombatInfo();
  log.scrollTop = log.scrollHeight;
}

function partyMembersTurn() {
  const log = document.getElementById('combat-log');
  const livingParty = party.filter(pm => pm.alive);
  let delay = 0;

  for (let i = 0; i < livingParty.length; i++) {
    const pm = livingParty[i];
    setTimeout(() => {
      if (combatEnemy.hp <= 0) return; // Already dead

      const roll = d(20);
      const total = roll + pm.atk;
      const crit = roll === 20;
      const hit = crit || total >= combatEnemy.ac;

      if (hit) {
        let dmg;
        if (crit) {
          dmg = rollDice(2, 6).total + pm.atk;
          log.innerHTML += `<div class="roll">Companion ${pm.name} (${pm.className}) rolled <b>NAT 20!</b> + ${pm.atk} = CRITICAL HIT!</div>`;
          log.innerHTML += `<div class="hit">Companion ${pm.name} deals <b>${dmg}</b> damage!</div>`;
          playSound('crit');
        } else {
          dmg = rollDice(1, 6).total + Math.floor(pm.atk / 2);
          log.innerHTML += `<div class="roll">Companion ${pm.name} (${pm.className}) rolled ${roll} + ${pm.atk} = ${total} vs AC ${combatEnemy.ac} - HIT! ${dmg} damage</div>`;
          playSound('hit');
        }
        combatEnemy.hp -= dmg;
        totalDamageDealt += dmg;
      } else {
        log.innerHTML += `<div class="roll">Companion ${pm.name} (${pm.className}) rolled ${roll} + ${pm.atk} = ${total} vs AC ${combatEnemy.ac} - MISS!</div>`;
        playSound('miss');
      }

      updateCombatInfo();
      log.scrollTop = log.scrollHeight;

      // If this is the last party member, check enemy death then do enemy turn
      if (i === livingParty.length - 1) {
        if (combatEnemy.hp <= 0) {
          endCombat(true);
        } else {
          setTimeout(() => enemyTurn(), 400);
        }
      }
    }, delay);
    delay += 350;
  }

  // If no living party members, go straight to enemy turn
  if (livingParty.length === 0) {
    setTimeout(() => enemyTurn(), 400);
  }
}

function enemyTurn() {
  const log = document.getElementById('combat-log');

  // Choose random target: player or living party member
  const livingParty = party.filter(pm => pm.alive);
  const targets = [{ isPlayer: true, name: 'You', obj: player }];
  for (const pm of livingParty) {
    targets.push({ isPlayer: false, name: pm.name, obj: pm });
  }
  const target = targets[Math.floor(Math.random() * targets.length)];

  const roll = d(20);
  const targetAC = target.isPlayer ? (player.ac + (combatPlayerDefending ? 5 : 0)) : target.obj.ac;
  const total = roll + combatEnemy.atk;
  const crit = roll === 20;
  const hit = crit || total >= targetAC;

  const targetLabel = target.isPlayer ? 'you' : target.name;
  const targetLabelCap = target.isPlayer ? 'You' : target.name;

  if (hit) {
    let dmg;
    const defReduction = target.isPlayer ? Math.floor(player.def / 3) : Math.floor(target.obj.def / 3);
    if (crit) {
      dmg = rollDice(2, 6).total + combatEnemy.atk;
      log.innerHTML += `<div class="roll">${combatEnemy.name} targets ${targetLabel} - rolled <b>NAT 20!</b> CRITICAL HIT!</div>`;
      log.innerHTML += `<div class="hit">${combatEnemy.name} deals <b>${dmg}</b> damage to ${targetLabel}!</div>`;
      playSound('crit');
    } else {
      dmg = Math.max(1, rollDice(1, 6).total + Math.floor(combatEnemy.atk / 2) - defReduction);
      log.innerHTML += `<div class="roll">${combatEnemy.name} targets ${targetLabel} - rolled ${roll} + ${combatEnemy.atk} ATK = ${total} vs AC ${targetAC} - HIT!</div>`;
      log.innerHTML += `<div class="hit">${combatEnemy.name} deals <b>${dmg}</b> damage to ${targetLabel}!</div>`;
      playSound('hit');
    }

    if (target.isPlayer) {
      player.hp -= dmg;
    } else {
      target.obj.hp -= dmg;
      // Check companion death
      if (target.obj.hp <= 0) {
        target.obj.hp = 0;
        target.obj.alive = false;
        log.innerHTML += `<div class="hit"><b>${target.obj.icon} ${target.name} has fallen!</b></div>`;
        playSound('death');
      }
    }
  } else {
    log.innerHTML += `<div class="roll">${combatEnemy.name} targets ${targetLabel} - rolled ${roll} + ${combatEnemy.atk} ATK = ${total} vs AC ${targetAC} - MISS!</div>`;
    log.innerHTML += `<div class="miss">${combatEnemy.name}'s attack misses ${targetLabel}!</div>`;
    playSound('miss');
  }

  // Check player death
  if (player.hp <= 0) {
    player.hp = 0;
    updateCombatInfo();
    log.innerHTML += `<div class="hit"><b>You have been slain!</b></div>`;
    log.scrollTop = log.scrollHeight;
    const acts = document.getElementById('combat-actions');
    acts.innerHTML = '';
    setTimeout(() => {
      document.getElementById('combat-overlay').style.display = 'none';
      gameOver();
    }, 1500);
    return;
  }

  updateCombatInfo();
  showCombatActions();
  log.scrollTop = log.scrollHeight;
}

function endCombat(victory) {
  combatWaitingForTurns = false;
  const log = document.getElementById('combat-log');
  if (victory) {
    const xpGain = combatEnemy.xp;
    const goldGain = combatEnemy.gold[0] + Math.floor(Math.random() * (combatEnemy.gold[1] - combatEnemy.gold[0] + 1));
    player.xp += xpGain;
    player.gold += goldGain;
    totalGoldEarned += goldGain;
    totalKills++;

    log.innerHTML += `<div class="info"><b>${combatEnemy.name} defeated!</b></div>`;
    log.innerHTML += `<div class="info">+${xpGain} XP | +${goldGain} Gold</div>`;

    // Loot drop chance
    const lootRoll = Math.random();
    if (lootRoll < 0.25) {
      // Drop a random item
      const r = Math.random();
      let droppedItem;
      if (r < 0.35) {
        const amt = 15 + floor * 5;
        droppedItem = { type: 'potion', healType: 'hp', amount: amt, name: 'Health Potion', rarity: 'common' };
      } else if (r < 0.5) {
        const amt = 10 + floor * 3;
        droppedItem = { type: 'potion', healType: 'mana', amount: amt, name: 'Mana Potion', rarity: 'common' };
      } else if (r < 0.75) {
        const eligible = WEAPONS.filter(w => w.minFloor <= floor + 1);
        const w = eligible[Math.floor(Math.random() * eligible.length)];
        const bonus = Math.floor(Math.random() * Math.ceil(floor / 2));
        droppedItem = { type: 'weapon', atk: w.atk + bonus, name: bonus > 0 ? `${w.name} +${bonus}` : w.name, rarity: w.rarity };
      } else {
        const eligible = ARMORS.filter(a => a.minFloor <= floor + 1);
        const a = eligible[Math.floor(Math.random() * eligible.length)];
        const bonus = Math.floor(Math.random() * Math.ceil(floor / 2));
        droppedItem = { type: 'armor', def: a.def + bonus, name: bonus > 0 ? `${a.name} +${bonus}` : a.name, rarity: a.rarity };
      }
      player.inventory.push(droppedItem);
      const color = RARITY_COLORS[droppedItem.rarity] || '#aaa';
      log.innerHTML += `<div class="info" style="color:${color}">&#x1F381; Dropped: ${droppedItem.name}!</div>`;
      playSound('pickup');
    }

    // Check level up
    while (player.xp >= player.xpNext) {
      player.xp -= player.xpNext;
      player.level++;
      player.xpNext = Math.floor(player.xpNext * 1.5);
      // Stat increases
      const hpGain = player.classId === 'warrior' ? 12 : player.classId === 'mage' ? 6 : 8;
      const manaGain = player.classId === 'mage' ? 12 : player.classId === 'rogue' ? 6 : 4;
      player.maxHp += hpGain;
      player.hp = player.maxHp; // Full heal on level up
      player.maxMana += manaGain;
      player.mana = player.maxMana;
      player.baseAtk += (player.classId === 'mage' ? 1 : 2);
      player.baseDef += 1;
      log.innerHTML += `<div class="heal"><b>&#x2B50; LEVEL UP! Now level ${player.level}!</b> +${hpGain} HP, +${manaGain} MP, +ATK, +DEF</div>`;
      playSound('levelup');
    }

    // Remove monster from map
    monsters.splice(monsters.indexOf(combatEnemy), 1);

    const acts = document.getElementById('combat-actions');
    acts.innerHTML = `<button class="btn-continue" onclick="closeCombat()">Continue</button>`;
    log.scrollTop = log.scrollHeight;
    updateCombatInfo();
  }
}

function closeCombat() {
  inCombat = false;
  combatEnemy = null;
  combatWaitingForTurns = false;
  document.getElementById('combat-overlay').style.display = 'none';
  updateHUD();
  render();
}

// ==================== GAME OVER ====================
function gameOver() {
  gameActive = false;
  inCombat = false;
  playSound('death');
  document.getElementById('gameover-overlay').style.display = 'flex';
  const survivingParty = party.filter(pm => pm.alive).length;
  document.getElementById('gameover-stats').innerHTML = `
    <div>Class: <span class="gold-color">${player.className}</span></div>
    <div>Level: <span class="gold-color">${player.level}</span></div>
    <div>Floor Reached: <span class="gold-color">${maxFloorReached}</span></div>
    <div>Monsters Slain: <span class="gold-color">${totalKills}</span></div>
    <div>Gold Earned: <span class="gold-color">${totalGoldEarned}</span></div>
    <div>Damage Dealt: <span class="gold-color">${totalDamageDealt}</span></div>
    <div>Steps Taken: <span class="gold-color">${moveCount}</span></div>
    <div>Companions Survived: <span class="gold-color">${survivingParty} / ${party.length}</span></div>
  `;
}

// ==================== CHARACTER SHEET ====================
function toggleCharSheet() {
  charSheetOpen = !charSheetOpen;
  const overlay = document.getElementById('charsheet-overlay');
  if (charSheetOpen) {
    overlay.style.display = 'flex';
    renderCharSheet();
  } else {
    overlay.style.display = 'none';
  }
}

function renderCharSheet() {
  const title = document.getElementById('cs-title');
  title.innerHTML = `${player.icon} ${player.className} - Character Sheet`;

  const subtitle = document.getElementById('cs-subtitle');
  subtitle.textContent = `Level ${player.level} ${player.className} | Floor ${floor}`;

  const content = document.getElementById('cs-content');
  let html = '';

  // Core Stats
  html += `<div class="cs-section">
    <h3>Attributes</h3>
    <div class="cs-grid">
      <span class="cs-label">Hit Points</span><span class="cs-value">${player.hp} / ${player.maxHp}</span>
      <span class="cs-label">Mana</span><span class="cs-value">${player.mana} / ${player.maxMana}</span>
      <span class="cs-label">Experience</span><span class="cs-value">${player.xp} / ${player.xpNext}</span>
      <span class="cs-label">Level</span><span class="cs-value">${player.level}</span>
      <span class="cs-label">Base Attack</span><span class="cs-value">${player.baseAtk}</span>
      <span class="cs-label">Base Defense</span><span class="cs-value">${player.baseDef}</span>
      <span class="cs-label">Total Attack</span><span class="cs-value" style="color:#e74c3c">${player.atk}</span>
      <span class="cs-label">Total Defense</span><span class="cs-value" style="color:#3498db">${player.def}</span>
      <span class="cs-label">Armor Class</span><span class="cs-value" style="color:#f1c40f">${player.ac}</span>
      <span class="cs-label">Gold</span><span class="cs-value" style="color:#f1c40f">${player.gold}</span>
    </div>
  </div>`;

  // Equipment
  html += `<div class="cs-section">
    <h3>Equipment</h3>
    <div class="cs-grid">
      <span class="cs-label">Weapon</span><span class="cs-value">${player.weapon ? player.weapon.name + ' (+' + player.weapon.atk + ' ATK)' : 'Fists'}</span>
      <span class="cs-label">Armor</span><span class="cs-value">${player.armor ? player.armor.name + ' (+' + player.armor.def + ' DEF)' : 'None'}</span>
    </div>
  </div>`;

  // Spell
  html += `<div class="cs-section">
    <h3>Spell</h3>
    <div class="cs-grid">
      <span class="cs-label">${player.spellName}</span><span class="cs-value">${player.spellCost} Mana</span>
      <span class="cs-label">Effect</span><span class="cs-value">${player.spellDesc}</span>
    </div>
  </div>`;

  // Party Members
  html += `<div class="cs-section">
    <h3>Party Members</h3>`;
  if (party.length === 0) {
    html += `<div style="color:#555;font-size:11px;text-align:center;padding:4px">No companions</div>`;
  } else {
    for (const pm of party) {
      const hpPct = pm.alive ? Math.max(0, (pm.hp / pm.maxHp) * 100) : 0;
      const statusColor = pm.alive ? '#2ecc71' : '#e74c3c';
      const statusText = pm.alive ? 'Alive' : 'Dead';
      html += `<div class="cs-party-member${pm.alive ? '' : ' dead'}">
        <div class="cspm-header">
          <span class="cspm-name">${pm.icon} ${pm.name} - ${pm.className}</span>
          <span class="cspm-status" style="color:${statusColor}">${statusText}</span>
        </div>
        <div class="cs-grid">
          <span class="cs-label">HP</span><span class="cs-value">${pm.alive ? pm.hp + '/' + pm.maxHp : '0/' + pm.maxHp}</span>
          <span class="cs-label">Attack</span><span class="cs-value">${pm.atk}</span>
          <span class="cs-label">Defense</span><span class="cs-value">${pm.def}</span>
          <span class="cs-label">AC</span><span class="cs-value">${pm.ac}</span>
        </div>
      </div>`;
    }
  }
  html += `</div>`;

  // Adventure Statistics
  html += `<div class="cs-section">
    <h3>Adventure Statistics</h3>
    <div class="cs-grid">
      <span class="cs-label">Monsters Slain</span><span class="cs-value">${totalKills}</span>
      <span class="cs-label">Total Gold Earned</span><span class="cs-value" style="color:#f1c40f">${totalGoldEarned}</span>
      <span class="cs-label">Floors Explored</span><span class="cs-value">${maxFloorReached}</span>
      <span class="cs-label">Current Floor</span><span class="cs-value">${floor}</span>
      <span class="cs-label">Total Damage Dealt</span><span class="cs-value" style="color:#e74c3c">${totalDamageDealt}</span>
      <span class="cs-label">Steps Taken</span><span class="cs-value">${moveCount}</span>
    </div>
  </div>`;

  content.innerHTML = html;
}

// ==================== INPUT ====================
document.addEventListener('keydown', (e) => {
  // Handle character sheet toggle (even when in combat)
  if (gameActive && (e.key === 'c' || e.key === 'C') && !inCombat) {
    toggleCharSheet();
    return;
  }
  if (charSheetOpen && (e.key === 'Escape' || e.key === 'c' || e.key === 'C')) {
    charSheetOpen = false;
    document.getElementById('charsheet-overlay').style.display = 'none';
    return;
  }
  if (charSheetOpen) return; // Block other input while char sheet is open

  if (!gameActive) return;

  if (inCombat) {
    if (combatWaitingForTurns) return; // Block input during party/enemy turns
    // Combat hotkeys (number keys only to avoid WASD confusion)
    if (e.key === '1') combatAction('attack');
    else if (e.key === '2') combatAction('defend');
    else if (e.key === '3') combatAction('spell');
    else if (e.key === '4') combatAction('flee');
    else if (e.key === 'Enter' || e.key === ' ') {
      const contBtn = document.querySelector('.btn-continue');
      if (contBtn) contBtn.click();
    }
    return;
  }

  switch (e.key) {
    case 'ArrowUp':    case 'w': case 'W': tryMove(0, -1); e.preventDefault(); break;
    case 'ArrowDown':  case 's': case 'S': tryMove(0, 1);  e.preventDefault(); break;
    case 'ArrowLeft':  case 'a': case 'A': tryMove(-1, 0); e.preventDefault(); break;
    case 'ArrowRight': case 'd': case 'D': tryMove(1, 0);  e.preventDefault(); break;
    case 'i': case 'I': usePotion('hp'); break;
    case 'm': case 'M': usePotion('mana'); break;
    case 'e': case 'E': autoEquipBest(); break;
    case ' ': // Wait turn
      moveCount++;
      if (player.mana < player.maxMana) player.mana = Math.min(player.maxMana, player.mana + 1);
      moveMonsters();
      updateHUD();
      render();
      e.preventDefault();
      break;
  }
});

// ==================== TOOLTIP ====================
canvas.addEventListener('mousemove', (e) => {
  if (!gameActive || inCombat) { document.getElementById('tooltip').style.display = 'none'; return; }
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left, my = e.clientY - rect.top;
  const camX = player.x - Math.floor(VIEW_TILES / 2);
  const camY = player.y - Math.floor(VIEW_TILES / 2);
  const tx = Math.floor(mx / TILE) + camX, ty = Math.floor(my / TILE) + camY;

  if (tx < 0 || tx >= MAP_W || ty < 0 || ty >= MAP_H || !explored[ty][tx]) {
    document.getElementById('tooltip').style.display = 'none';
    return;
  }

  let tipName = '', tipStat = '', tipDesc = '';
  const mon = monsters.find(m => m.x === tx && m.y === ty && isVisible(tx, ty));
  const item = items.find(i => i.x === tx && i.y === ty && isVisible(tx, ty));

  const comp = party.find(pm => pm.alive && pm.x === tx && pm.y === ty && isVisible(tx, ty));

  if (mon) {
    tipName = `${mon.icon} ${mon.name}`;
    tipStat = `HP: ${mon.hp}/${mon.maxHp} | AC: ${mon.ac} | ATK: ${mon.atk}`;
    tipDesc = `XP: ${mon.xp}`;
  } else if (comp) {
    tipName = `${comp.icon} ${comp.name} (${comp.className})`;
    tipStat = `HP: ${comp.hp}/${comp.maxHp} | ATK: ${comp.atk} | AC: ${comp.ac}`;
    tipDesc = 'Party companion';
  } else if (item) {
    tipName = `${item.icon} ${item.name}`;
    if (item.type === 'weapon') tipStat = `+${item.atk} Attack`;
    else if (item.type === 'armor') tipStat = `+${item.def} Defense`;
    else if (item.type === 'potion') tipStat = item.healType === 'hp' ? `+${item.amount} HP` : `+${item.amount} Mana`;
  } else if (tx === player.x && ty === player.y) {
    tipName = `${player.icon} ${player.className}`;
    tipStat = `Lv${player.level} | HP: ${player.hp}/${player.maxHp}`;
  } else if (map[ty][tx] === T.STAIRS) {
    tipName = '\u{1FA9C} Stairs Down';
    tipDesc = 'Descend to the next floor';
  } else {
    document.getElementById('tooltip').style.display = 'none';
    return;
  }

  const tt = document.getElementById('tooltip');
  tt.style.display = 'block';
  tt.style.left = (e.clientX + 12) + 'px';
  tt.style.top = (e.clientY + 12) + 'px';
  tt.querySelector('.tt-name').textContent = tipName;
  tt.querySelector('.tt-stat').textContent = tipStat;
  tt.querySelector('.tt-desc').textContent = tipDesc;
});

canvas.addEventListener('mouseleave', () => {
  document.getElementById('tooltip').style.display = 'none';
});

// ==================== INITIAL RENDER ====================
// Game starts when class is selected
</script>
</body>
</html>
