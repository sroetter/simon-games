<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Island Paradise - City Builder</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700;900&display=swap">
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{background:#0a0a1a;color:#e0d5c1;font-family:'Cinzel',serif;overflow:hidden;height:100vh;width:100vw}
#particleBg{position:fixed;top:0;left:0;width:100%;height:100%;z-index:0;pointer-events:none}
.back-btn{position:fixed;top:18px;left:18px;z-index:100;color:#f0c060;text-decoration:none;font-size:.95rem;opacity:.7;transition:opacity .3s}
.back-btn:hover{opacity:1}
#app{position:relative;z-index:1;display:flex;height:100vh;width:100vw}
#sidebar{width:260px;min-width:260px;background:rgba(15,15,35,.85);backdrop-filter:blur(18px);border-right:1px solid rgba(240,192,96,.12);display:flex;flex-direction:column;overflow-y:auto;padding:0}
#sidebar::-webkit-scrollbar{width:4px}
#sidebar::-webkit-scrollbar-thumb{background:rgba(240,192,96,.25);border-radius:2px}
.sidebar-header{padding:18px 16px 10px;text-align:center;border-bottom:1px solid rgba(240,192,96,.1)}
.sidebar-header h1{font-size:1.3rem;font-weight:900;background:linear-gradient(135deg,#f0c060,#e07830,#f0c060);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text;line-height:1.3}
.sidebar-header .sub{font-size:.65rem;color:rgba(224,213,193,.5);letter-spacing:2px;margin-top:2px}
#statsBar{display:flex;flex-direction:column;gap:6px;padding:12px 14px;border-bottom:1px solid rgba(240,192,96,.1)}
.stat{display:flex;align-items:center;justify-content:space-between;font-size:.75rem;padding:4px 8px;border-radius:6px;background:rgba(255,255,255,.03)}
.stat .label{opacity:.6;display:flex;align-items:center;gap:5px}
.stat .value{font-weight:700;color:#f0c060}
.stat .value.pop{color:#60d0f0}
.stat .value.happy{color:#60f080}
.stat .icon{font-size:1rem}
.shop-title{font-size:.7rem;letter-spacing:2px;text-transform:uppercase;padding:10px 14px 4px;opacity:.4}
#shopList{flex:1;padding:4px 10px 10px;display:flex;flex-direction:column;gap:5px}
.shop-item{display:flex;align-items:center;gap:10px;padding:8px 10px;border-radius:8px;cursor:pointer;border:1px solid rgba(240,192,96,.06);transition:all .2s;background:rgba(255,255,255,.02)}
.shop-item:hover{background:rgba(240,192,96,.08);border-color:rgba(240,192,96,.2)}
.shop-item.selected{background:rgba(240,192,96,.12);border-color:rgba(240,192,96,.4);box-shadow:0 0 12px rgba(240,192,96,.1)}
.shop-item.disabled{opacity:.35;cursor:not-allowed}
.shop-icon{font-size:1.4rem;width:32px;text-align:center}
.shop-info{flex:1}
.shop-name{font-size:.72rem;font-weight:700}
.shop-cost{font-size:.6rem;opacity:.5}
.shop-income{font-size:.55rem;color:#60f080;opacity:.7}
#mainArea{flex:1;display:flex;flex-direction:column;position:relative}
#topBar{display:flex;align-items:center;justify-content:space-between;padding:8px 16px;background:rgba(15,15,35,.6);backdrop-filter:blur(10px);border-bottom:1px solid rgba(240,192,96,.08);min-height:44px}
#topBar .info{font-size:.65rem;opacity:.5}
#topBar .actions{display:flex;gap:6px}
#topBar button{background:rgba(240,192,96,.1);border:1px solid rgba(240,192,96,.2);color:#f0c060;padding:4px 12px;border-radius:6px;cursor:pointer;font-family:'Cinzel',serif;font-size:.65rem;transition:all .2s}
#topBar button:hover{background:rgba(240,192,96,.2)}
#canvasWrap{flex:1;display:flex;align-items:center;justify-content:center;position:relative;overflow:hidden}
#gameCanvas{cursor:crosshair;image-rendering:pixelated}
#tooltip{position:absolute;pointer-events:none;background:rgba(10,10,30,.92);backdrop-filter:blur(12px);border:1px solid rgba(240,192,96,.2);border-radius:8px;padding:8px 12px;font-size:.65rem;display:none;z-index:50;min-width:120px;box-shadow:0 4px 20px rgba(0,0,0,.5)}
#tooltip .tt-name{font-weight:700;color:#f0c060;margin-bottom:2px}
#tooltip .tt-info{opacity:.6;font-size:.6rem;line-height:1.4}
#upgradePanel{position:absolute;pointer-events:auto;background:rgba(10,10,30,.95);backdrop-filter:blur(16px);border:1px solid rgba(240,192,96,.25);border-radius:10px;padding:14px 18px;display:none;z-index:60;min-width:180px;box-shadow:0 6px 30px rgba(0,0,0,.6)}
#upgradePanel .up-name{font-weight:700;color:#f0c060;font-size:.85rem;margin-bottom:4px}
#upgradePanel .up-info{font-size:.62rem;opacity:.6;line-height:1.5;margin-bottom:8px}
#upgradePanel button{width:100%;background:rgba(240,192,96,.15);border:1px solid rgba(240,192,96,.3);color:#f0c060;padding:6px;border-radius:6px;cursor:pointer;font-family:'Cinzel',serif;font-size:.68rem;transition:all .2s;margin-bottom:4px}
#upgradePanel button:hover{background:rgba(240,192,96,.25)}
#upgradePanel .close-btn{background:rgba(255,60,60,.1);border-color:rgba(255,60,60,.2);color:#ff6060}
#upgradePanel .close-btn:hover{background:rgba(255,60,60,.2)}
.floating-text{position:absolute;pointer-events:none;font-size:.75rem;font-weight:700;color:#f0c060;text-shadow:0 1px 4px rgba(0,0,0,.7);animation:floatUp 1.5s ease-out forwards;z-index:40}
@keyframes floatUp{0%{opacity:1;transform:translateY(0)}100%{opacity:0;transform:translateY(-40px)}}
#nightOverlay{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:30;transition:background .5s}
#notification{position:fixed;top:60px;left:50%;transform:translateX(-50%);background:rgba(10,10,30,.9);backdrop-filter:blur(12px);border:1px solid rgba(240,192,96,.3);border-radius:10px;padding:10px 24px;font-size:.75rem;color:#f0c060;z-index:200;opacity:0;transition:opacity .3s;pointer-events:none}
#notification.show{opacity:1}
</style>
</head>
<body>
<canvas id="particleBg"></canvas>
<a href="index.html" class="back-btn">&larr; Back to Gallery</a>
<div id="app">
  <div id="sidebar">
    <div class="sidebar-header">
      <h1>&#127965; Island Paradise</h1>
      <div class="sub">TROPICAL CITY BUILDER</div>
    </div>
    <div id="statsBar">
      <div class="stat"><span class="label"><span class="icon">&#129689;</span> Gold</span><span class="value" id="goldVal">100</span></div>
      <div class="stat"><span class="label"><span class="icon">&#128101;</span> Population</span><span class="value pop" id="popVal">0</span></div>
      <div class="stat"><span class="label"><span class="icon">&#128154;</span> Happiness</span><span class="value happy" id="happyVal">100%</span></div>
      <div class="stat"><span class="label"><span class="icon">&#128200;</span> Income/tick</span><span class="value" id="incomeVal">+0</span></div>
    </div>
    <div class="shop-title">&#9660; Buildings</div>
    <div id="shopList"></div>
  </div>
  <div id="mainArea">
    <div id="topBar">
      <div class="info" id="timeInfo">Day 1 - Morning</div>
      <div class="actions">
        <button onclick="saveGame()">&#128190; Save</button>
        <button onclick="loadGame()">&#128194; Load</button>
        <button onclick="clearSelection()">&#10006; Cancel</button>
      </div>
    </div>
    <div id="canvasWrap">
      <canvas id="gameCanvas"></canvas>
      <div id="nightOverlay"></div>
      <div id="tooltip"><div class="tt-name"></div><div class="tt-info"></div></div>
      <div id="upgradePanel"></div>
    </div>
  </div>
</div>
<div id="notification"></div>
<script>
// ============ CONFIGURATION ============
const GRID_COLS = 28;
const GRID_ROWS = 20;
const TILE = 25;
const CW = GRID_COLS * TILE;
const CH = GRID_ROWS * TILE;
const TICK_MS = 3000;

const BUILDINGS = [
  {id:'beach_hut',   name:'Beach Hut',      icon:'\u{1F3D6}', cost:10,  income:2,  pop:3,  happy:1,  color:'#d4a050', desc:'Simple shelter for islanders'},
  {id:'palm_garden', name:'Palm Garden',     icon:'\u{1F334}', cost:15,  income:1,  pop:0,  happy:5,  color:'#30a040', desc:'Lush tropical garden'},
  {id:'tiki_bar',    name:'Tiki Bar',        icon:'\u{1F379}', cost:25,  income:5,  pop:2,  happy:8,  color:'#c06020', desc:'Serves exotic cocktails'},
  {id:'surf_shop',   name:'Surf Shop',       icon:'\u{1F3C4}', cost:30,  income:6,  pop:4,  happy:4,  color:'#2090d0', desc:'Boards and beach gear'},
  {id:'fishing_dock',name:'Fishing Dock',    icon:'\u{1F3A3}', cost:40,  income:8,  pop:6,  happy:3,  color:'#607090', desc:'Fresh seafood daily'},
  {id:'lighthouse',  name:'Lighthouse',      icon:'\u{1F56F}', cost:50,  income:4,  pop:2,  happy:10, color:'#f0f0e0', desc:'Guides ships, boosts morale'},
  {id:'resort_hotel',name:'Resort Hotel',    icon:'\u{1F3E8}', cost:60,  income:12, pop:15, happy:6,  color:'#e0b0c0', desc:'Luxury island accommodation'},
  {id:'water_slide', name:'Water Slide',     icon:'\u{1F30A}', cost:80,  income:10, pop:5,  happy:15, color:'#40b0e0', desc:'Thrilling water fun'},
  {id:'volcano_lounge',name:'Volcano Lounge',icon:'\u{1F30B}', cost:100, income:18, pop:10, happy:12, color:'#d04020', desc:'Exclusive volcanic dining'},
];

// ============ STATE ============
let gold = 100;
let population = 0;
let happiness = 100;
let totalIncome = 0;
let selectedBuilding = null;
let hoveredTile = null;
let dayTime = 0; // 0-1 cycle
let dayCount = 1;
let tickTimer = 0;
let grid = []; // [row][col] = {type:'ocean'|'beach'|'grass'|'jungle', building:null}
let placedBuildings = []; // {row,col,def,level,age}
let floatingTexts = [];
let waveOffset = 0;
let palmSwayAngle = 0;
let particles = [];
let audioCtx = null;
let ambientGain = null;
let ambientRunning = false;

// Canvas refs
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const bgCanvas = document.getElementById('particleBg');
const bgCtx = bgCanvas.getContext('2d');

canvas.width = CW;
canvas.height = CH;

// ============ ISLAND MAP GENERATION ============
function generateIsland() {
  grid = [];
  const cx = GRID_COLS / 2;
  const cy = GRID_ROWS / 2;
  const rx = GRID_COLS * 0.38;
  const ry = GRID_ROWS * 0.38;

  // Simple noise for organic shape
  const offsets = [];
  for (let a = 0; a < 64; a++) {
    offsets.push((Math.random() - 0.5) * 0.35);
  }

  for (let r = 0; r < GRID_ROWS; r++) {
    grid[r] = [];
    for (let c = 0; c < GRID_COLS; c++) {
      const dx = (c - cx) / rx;
      const dy = (r - cy) / ry;
      const angle = Math.atan2(dy, dx);
      const idx = ((angle / Math.PI + 1) / 2 * 64) | 0;
      const noise = offsets[idx % 64];
      const dist = Math.sqrt(dx * dx + dy * dy) + noise;

      let type;
      if (dist > 1.1) type = 'ocean';
      else if (dist > 0.92) type = 'beach';
      else if (dist > 0.65) type = 'grass';
      else type = 'jungle';

      grid[r][c] = { type, building: null };
    }
  }
}

function isBuildable(r, c) {
  if (r < 0 || r >= GRID_ROWS || c < 0 || c >= GRID_COLS) return false;
  const t = grid[r][c].type;
  return (t === 'grass' || t === 'jungle' || t === 'beach') && !grid[r][c].building;
}

// ============ DRAWING ============
const oceanColors = ['#0a3a6b', '#0d4480', '#104e95', '#1358a0'];
const waterHighlight = '#2080d0';

function drawTile(r, c) {
  const x = c * TILE;
  const y = r * TILE;
  const tile = grid[r][c];

  if (tile.type === 'ocean') {
    // Animated ocean
    const wave = Math.sin(waveOffset + c * 0.4 + r * 0.3) * 0.5 + 0.5;
    const wave2 = Math.sin(waveOffset * 0.7 + c * 0.6 - r * 0.2) * 0.5 + 0.5;
    const ci = (wave * 3) | 0;
    ctx.fillStyle = oceanColors[ci];
    ctx.fillRect(x, y, TILE, TILE);

    // Wave sparkle
    if (wave2 > 0.7) {
      ctx.fillStyle = `rgba(100,200,255,${(wave2 - 0.7) * 0.5})`;
      ctx.fillRect(x + 2, y + wave * 6, TILE - 4, 2);
    }
    // Foam lines
    const foam = Math.sin(waveOffset * 1.2 + c * 0.8 + r * 0.5);
    if (foam > 0.6) {
      ctx.fillStyle = `rgba(200,240,255,${(foam - 0.6) * 0.4})`;
      ctx.fillRect(x, y + 10 + foam * 4, TILE, 1);
    }
  } else if (tile.type === 'beach') {
    const v = Math.sin(c * 0.5 + r * 0.3) * 10;
    ctx.fillStyle = `rgb(${220 + v},${195 + v},${140 + v})`;
    ctx.fillRect(x, y, TILE, TILE);
    // Sand texture dots
    ctx.fillStyle = 'rgba(180,160,110,0.3)';
    if ((r + c) % 3 === 0) ctx.fillRect(x + 5, y + 5, 2, 2);
    if ((r * 7 + c * 3) % 5 === 0) ctx.fillRect(x + 15, y + 12, 1, 1);
  } else if (tile.type === 'grass') {
    const v = Math.sin(c * 0.7 + r * 0.4) * 15;
    ctx.fillStyle = `rgb(${60 + v},${140 + v},${50 + v})`;
    ctx.fillRect(x, y, TILE, TILE);
    // Grass blades
    ctx.fillStyle = 'rgba(40,110,30,0.3)';
    if ((r + c) % 2 === 0) {
      ctx.fillRect(x + 8, y + 3, 1, 4);
      ctx.fillRect(x + 18, y + 14, 1, 3);
    }
  } else if (tile.type === 'jungle') {
    const v = Math.sin(c * 0.5 + r * 0.6) * 12;
    ctx.fillStyle = `rgb(${35 + v},${100 + v},${35 + v})`;
    ctx.fillRect(x, y, TILE, TILE);
    ctx.fillStyle = 'rgba(25,80,25,0.4)';
    ctx.fillRect(x + 4, y + 2, 2, 5);
    ctx.fillRect(x + 14, y + 10, 2, 4);
    ctx.fillRect(x + 20, y + 5, 1, 6);
  }
}

function drawBuilding(b) {
  const x = b.col * TILE;
  const y = b.row * TILE;
  const def = b.def;
  const lvl = b.level || 1;

  // Shadow
  ctx.fillStyle = 'rgba(0,0,0,0.25)';
  ctx.beginPath();
  ctx.ellipse(x + TILE / 2, y + TILE - 2, TILE / 2 - 2, 4, 0, 0, Math.PI * 2);
  ctx.fill();

  // Building base
  const sway = (def.id === 'palm_garden') ? Math.sin(palmSwayAngle + b.col) * 2 : 0;

  ctx.save();
  ctx.translate(x + TILE / 2, y + TILE / 2);

  // Placement animation
  const age = (performance.now() - (b.placeTime || 0)) / 300;
  if (age < 1) {
    const scale = 0.3 + 0.7 * Math.min(age, 1);
    const bounce = age < 0.7 ? scale : 1 + Math.sin((age - 0.7) * 10) * 0.05;
    ctx.scale(bounce, bounce);
  }

  // Draw pixel art building
  drawBuildingArt(def.id, lvl, sway);

  // Level badge
  if (lvl > 1) {
    ctx.fillStyle = '#f0c060';
    ctx.font = 'bold 8px sans-serif';
    ctx.textAlign = 'right';
    ctx.fillText('â˜…' + lvl, TILE / 2 - 1, -TILE / 2 + 8);
  }

  ctx.restore();
}

function drawBuildingArt(id, lvl, sway) {
  const s = TILE;
  const hs = s / 2;

  switch(id) {
    case 'beach_hut':
      // Stilts
      ctx.fillStyle = '#8B6914';
      ctx.fillRect(-5, 2, 2, hs - 2);
      ctx.fillRect(3, 2, 2, hs - 2);
      // Floor
      ctx.fillStyle = '#A0782C';
      ctx.fillRect(-hs + 2, 0, s - 4, 3);
      // Walls
      ctx.fillStyle = '#D4A050';
      ctx.fillRect(-hs + 3, -5, s - 6, 6);
      // Door
      ctx.fillStyle = '#6B4010';
      ctx.fillRect(-2, -4, 4, 5);
      // Roof (thatched)
      ctx.fillStyle = '#8B7040';
      ctx.beginPath();
      ctx.moveTo(-hs + 1, -5);
      ctx.lineTo(0, -hs + 2);
      ctx.lineTo(hs - 1, -5);
      ctx.fill();
      // Roof stripes
      ctx.strokeStyle = '#706030';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(-4, -7); ctx.lineTo(0, -10); ctx.lineTo(4, -7);
      ctx.stroke();
      break;

    case 'palm_garden':
      ctx.save();
      ctx.translate(sway, 0);
      // Trunk
      ctx.fillStyle = '#8B6C40';
      ctx.fillRect(-1, -2, 3, hs + 2);
      // Coconuts
      ctx.fillStyle = '#6B4C20';
      ctx.beginPath(); ctx.arc(-2, -3, 2, 0, Math.PI * 2); ctx.fill();
      ctx.beginPath(); ctx.arc(3, -2, 2, 0, Math.PI * 2); ctx.fill();
      // Fronds
      ctx.fillStyle = '#30A040';
      const frondAngles = [-2.2, -1.5, -0.8, -0.2, 0.4, 1.0];
      for (const fa of frondAngles) {
        ctx.save();
        ctx.translate(0, -4);
        ctx.rotate(fa + Math.sin(palmSwayAngle * 2 + fa) * 0.1);
        ctx.beginPath();
        ctx.ellipse(0, -5, 2, 6, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
      // Grass at base
      ctx.fillStyle = '#40B050';
      ctx.fillRect(-4, hs - 4, 9, 3);
      ctx.restore();
      break;

    case 'tiki_bar':
      // Bar counter
      ctx.fillStyle = '#704020';
      ctx.fillRect(-hs + 2, 0, s - 4, 4);
      // Stools
      ctx.fillStyle = '#805030';
      ctx.fillRect(-8, 4, 3, 5);
      ctx.fillRect(5, 4, 3, 5);
      // Roof posts
      ctx.fillStyle = '#8B6C40';
      ctx.fillRect(-hs + 3, -6, 2, 7);
      ctx.fillRect(hs - 5, -6, 2, 7);
      // Tiki roof
      ctx.fillStyle = '#A08040';
      ctx.fillRect(-hs + 1, -8, s - 2, 3);
      ctx.fillStyle = '#8B7030';
      ctx.fillRect(-hs, -9, s, 2);
      // Tiki face
      ctx.fillStyle = '#F0C060';
      ctx.fillRect(-2, -6, 1, 2);
      ctx.fillRect(1, -6, 1, 2);
      ctx.fillRect(-1, -4, 2, 1);
      // Drink
      ctx.fillStyle = '#FF6090';
      ctx.fillRect(-6, -2, 3, 3);
      break;

    case 'surf_shop':
      // Building
      ctx.fillStyle = '#2090D0';
      ctx.fillRect(-hs + 2, -4, s - 4, hs + 4);
      // Roof
      ctx.fillStyle = '#1870A0';
      ctx.fillRect(-hs + 1, -6, s - 2, 3);
      // Door
      ctx.fillStyle = '#105880';
      ctx.fillRect(-2, 2, 5, 6);
      // Window
      ctx.fillStyle = '#60D0F0';
      ctx.fillRect(-7, -2, 4, 3);
      // Surfboard
      ctx.fillStyle = '#F0E040';
      ctx.fillRect(hs - 5, -8, 2, 10);
      ctx.fillStyle = '#F06040';
      ctx.fillRect(hs - 5, -8, 2, 3);
      // Sign
      ctx.fillStyle = '#F0F0F0';
      ctx.font = '5px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('SURF', 0, -1);
      break;

    case 'fishing_dock':
      // Water under dock
      ctx.fillStyle = 'rgba(16,78,149,0.4)';
      ctx.fillRect(-hs + 1, 2, s - 2, hs - 2);
      // Dock planks
      ctx.fillStyle = '#808898';
      ctx.fillRect(-hs + 2, 0, s - 4, 2);
      ctx.fillRect(-hs + 2, 4, s - 4, 2);
      // Posts
      ctx.fillStyle = '#606878';
      ctx.fillRect(-hs + 3, -2, 2, hs + 2);
      ctx.fillRect(hs - 5, -2, 2, hs + 2);
      // Fishing rod
      ctx.strokeStyle = '#A0A0A0';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(hs - 4, -2);
      ctx.lineTo(hs + 2, -8);
      ctx.stroke();
      // Line
      ctx.strokeStyle = '#C0C0C0';
      ctx.lineWidth = 0.5;
      ctx.beginPath();
      ctx.moveTo(hs + 2, -8);
      ctx.lineTo(hs + 2, 4);
      ctx.stroke();
      // Fish
      ctx.fillStyle = '#F09040';
      ctx.beginPath();
      ctx.ellipse(-3, 7, 3, 2, 0, 0, Math.PI * 2);
      ctx.fill();
      break;

    case 'lighthouse':
      // Base
      ctx.fillStyle = '#D0D0C0';
      ctx.fillRect(-4, 2, 8, 6);
      // Tower
      ctx.fillStyle = '#F0F0E0';
      ctx.fillRect(-3, -8, 6, 11);
      // Red stripes
      ctx.fillStyle = '#D04030';
      ctx.fillRect(-3, -6, 6, 2);
      ctx.fillRect(-3, -1, 6, 2);
      // Light
      ctx.fillStyle = '#FFFF80';
      ctx.fillRect(-2, -10, 4, 3);
      // Beam
      const beamAngle = waveOffset * 2;
      ctx.save();
      ctx.translate(0, -9);
      ctx.rotate(beamAngle);
      ctx.fillStyle = `rgba(255,255,128,${0.15 + Math.sin(waveOffset * 3) * 0.05})`;
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(-8, -20);
      ctx.lineTo(8, -20);
      ctx.fill();
      ctx.restore();
      // Cap
      ctx.fillStyle = '#404040';
      ctx.fillRect(-3, -11, 6, 1);
      break;

    case 'resort_hotel':
      // Main building
      ctx.fillStyle = '#E0B0C0';
      ctx.fillRect(-hs + 2, -6, s - 4, hs + 6);
      // Floors
      ctx.fillStyle = '#C09AAA';
      for (let i = 0; i < 3; i++) {
        ctx.fillRect(-hs + 2, -5 + i * 4, s - 4, 1);
      }
      // Windows
      ctx.fillStyle = '#80D0F0';
      for (let i = 0; i < 3; i++) {
        ctx.fillRect(-7, -4 + i * 4, 3, 2);
        ctx.fillRect(-1, -4 + i * 4, 3, 2);
        ctx.fillRect(5, -4 + i * 4, 3, 2);
      }
      // Roof
      ctx.fillStyle = '#B08898';
      ctx.fillRect(-hs + 1, -8, s - 2, 2);
      // Entrance
      ctx.fillStyle = '#F0D090';
      ctx.fillRect(-2, 4, 5, 5);
      // Pool on top
      ctx.fillStyle = '#40B0E0';
      ctx.fillRect(-4, -7, 3, 1);
      break;

    case 'water_slide':
      // Pool base
      ctx.fillStyle = '#40B0E0';
      ctx.beginPath();
      ctx.ellipse(0, 6, hs - 2, 4, 0, 0, Math.PI * 2);
      ctx.fill();
      // Slide structure
      ctx.fillStyle = '#E04060';
      ctx.fillRect(-2, -hs + 2, 4, hs);
      // Slide curve
      ctx.strokeStyle = '#F06080';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(0, -hs + 3);
      ctx.quadraticCurveTo(8, -4, 6, 4);
      ctx.stroke();
      // Slide tube
      ctx.strokeStyle = '#40B0E0';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, -hs + 5);
      ctx.quadraticCurveTo(-8, -2, -4, 5);
      ctx.stroke();
      // Splash
      const splash = Math.sin(waveOffset * 3) * 0.5 + 0.5;
      ctx.fillStyle = `rgba(100,200,255,${splash * 0.4})`;
      ctx.beginPath();
      ctx.arc(4, 5, 3 + splash * 2, 0, Math.PI * 2);
      ctx.fill();
      // Ladder
      ctx.strokeStyle = '#808080';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(-4, -hs + 3); ctx.lineTo(-4, 2);
      ctx.moveTo(-2, -hs + 3); ctx.lineTo(-2, 2);
      ctx.stroke();
      for (let i = 0; i < 4; i++) {
        ctx.beginPath();
        ctx.moveTo(-4, -6 + i * 4); ctx.lineTo(-2, -6 + i * 4);
        ctx.stroke();
      }
      break;

    case 'volcano_lounge':
      // Mountain
      ctx.fillStyle = '#705040';
      ctx.beginPath();
      ctx.moveTo(-hs + 1, hs - 2);
      ctx.lineTo(-3, -hs + 4);
      ctx.lineTo(3, -hs + 4);
      ctx.lineTo(hs - 1, hs - 2);
      ctx.fill();
      // Crater
      ctx.fillStyle = '#503020';
      ctx.fillRect(-3, -hs + 3, 6, 2);
      // Lava glow
      const glow = Math.sin(waveOffset * 2) * 0.3 + 0.7;
      ctx.fillStyle = `rgba(255,80,20,${glow * 0.8})`;
      ctx.fillRect(-2, -hs + 3, 4, 2);
      // Lava particles
      ctx.fillStyle = `rgba(255,160,40,${glow * 0.6})`;
      const ly = Math.sin(waveOffset * 4) * 3;
      ctx.beginPath();
      ctx.arc(-1, -hs + 1 + ly, 1.5, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(1, -hs - 1 + Math.sin(waveOffset * 3 + 1) * 2, 1, 0, Math.PI * 2);
      ctx.fill();
      // Windows in mountain
      ctx.fillStyle = '#F0D080';
      ctx.fillRect(-6, 2, 2, 2);
      ctx.fillRect(4, 2, 2, 2);
      ctx.fillRect(-1, 4, 2, 2);
      // Door
      ctx.fillStyle = '#F0A040';
      ctx.fillRect(-2, 6, 4, 4);
      // Smoke
      ctx.fillStyle = `rgba(150,150,150,${0.15 + Math.sin(waveOffset) * 0.1})`;
      ctx.beginPath();
      ctx.arc(Math.sin(waveOffset) * 2, -hs - 1, 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(Math.sin(waveOffset + 1) * 3, -hs - 4, 2, 0, Math.PI * 2);
      ctx.fill();
      break;
  }

  // Level glow
  if (lvl >= 3) {
    ctx.strokeStyle = `rgba(240,192,96,${0.2 + Math.sin(waveOffset * 3) * 0.1})`;
    ctx.lineWidth = 1;
    ctx.strokeRect(-hs + 1, -hs + 1, s - 2, s - 2);
  }
}

// ============ RENDER LOOP ============
function render() {
  ctx.clearRect(0, 0, CW, CH);

  // Draw terrain
  for (let r = 0; r < GRID_ROWS; r++) {
    for (let c = 0; c < GRID_COLS; c++) {
      drawTile(r, c);
    }
  }

  // Grid lines (subtle)
  ctx.strokeStyle = 'rgba(0,0,0,0.06)';
  ctx.lineWidth = 0.5;
  for (let r = 0; r <= GRID_ROWS; r++) {
    ctx.beginPath(); ctx.moveTo(0, r * TILE); ctx.lineTo(CW, r * TILE); ctx.stroke();
  }
  for (let c = 0; c <= GRID_COLS; c++) {
    ctx.beginPath(); ctx.moveTo(c * TILE, 0); ctx.lineTo(c * TILE, CH); ctx.stroke();
  }

  // Draw buildings
  for (const b of placedBuildings) {
    drawBuilding(b);
  }

  // Hover preview
  if (selectedBuilding && hoveredTile) {
    const {row, col} = hoveredTile;
    const canPlace = isBuildable(row, col);
    ctx.fillStyle = canPlace ? 'rgba(96,240,128,0.25)' : 'rgba(255,60,60,0.25)';
    ctx.fillRect(col * TILE, row * TILE, TILE, TILE);
    ctx.strokeStyle = canPlace ? 'rgba(96,240,128,0.6)' : 'rgba(255,60,60,0.6)';
    ctx.lineWidth = 1.5;
    ctx.strokeRect(col * TILE + 0.5, row * TILE + 0.5, TILE - 1, TILE - 1);

    if (canPlace) {
      // Ghost building
      ctx.globalAlpha = 0.45;
      const ghost = {row, col, def: selectedBuilding, level: 1, placeTime: 0};
      drawBuilding(ghost);
      ctx.globalAlpha = 1;
    }
  }

  // Day/night overlay
  updateDayNight();
}

function updateDayNight() {
  dayTime += 0.00008;
  if (dayTime >= 1) { dayTime = 0; dayCount++; }

  let overlayColor;
  // 0-0.25 morning, 0.25-0.5 day, 0.5-0.75 evening, 0.75-1 night
  if (dayTime < 0.2) {
    // Dawn
    const t = dayTime / 0.2;
    overlayColor = `rgba(10,10,40,${0.3 * (1 - t)})`;
  } else if (dayTime < 0.5) {
    overlayColor = 'rgba(0,0,0,0)';
  } else if (dayTime < 0.65) {
    // Sunset
    const t = (dayTime - 0.5) / 0.15;
    const r = Math.floor(40 * t);
    const g = Math.floor(20 * t);
    overlayColor = `rgba(${r},${g},60,${0.15 * t})`;
  } else if (dayTime < 0.8) {
    const t = (dayTime - 0.65) / 0.15;
    overlayColor = `rgba(10,10,50,${0.15 + 0.2 * t})`;
  } else {
    // Night
    overlayColor = 'rgba(10,10,50,0.35)';
  }

  document.getElementById('nightOverlay').style.background = overlayColor;

  // Time label
  let timeLabel;
  if (dayTime < 0.2) timeLabel = 'Dawn';
  else if (dayTime < 0.4) timeLabel = 'Morning';
  else if (dayTime < 0.55) timeLabel = 'Afternoon';
  else if (dayTime < 0.7) timeLabel = 'Evening';
  else timeLabel = 'Night';
  document.getElementById('timeInfo').textContent = `Day ${dayCount} - ${timeLabel}`;
}

// ============ MAIN LOOP ============
let lastTick = 0;
function gameLoop(ts) {
  waveOffset += 0.02;
  palmSwayAngle += 0.015;

  // Income tick
  if (ts - lastTick > TICK_MS) {
    lastTick = ts;
    processTick();
  }

  render();
  updateFloatingTexts();
  requestAnimationFrame(gameLoop);
}

function processTick() {
  if (totalIncome > 0) {
    gold += totalIncome;
    spawnFloatingText(`+${totalIncome}g`, CW / 2, CH / 2 - 20, '#f0c060');
    playSound('coin');
  }
  updateStats();
  updateShopList();
}

function recalcStats() {
  totalIncome = 0;
  population = 0;
  let totalHappy = 0;
  let happyBuildings = 0;

  const typeSet = new Set();
  for (const b of placedBuildings) {
    const lvl = b.level || 1;
    const mult = 1 + (lvl - 1) * 0.6;
    totalIncome += Math.floor(b.def.income * mult);
    population += Math.floor(b.def.pop * lvl);
    totalHappy += b.def.happy * lvl;
    happyBuildings++;
    typeSet.add(b.def.id);
  }

  // Variety bonus
  const varietyBonus = typeSet.size * 3;
  totalHappy += varietyBonus;

  if (happyBuildings > 0) {
    happiness = Math.min(100, Math.floor(50 + totalHappy / happyBuildings * 2 + varietyBonus));
  } else {
    happiness = 100;
  }
}

function updateStats() {
  recalcStats();
  document.getElementById('goldVal').textContent = gold;
  document.getElementById('popVal').textContent = population;
  document.getElementById('happyVal').textContent = happiness + '%';
  document.getElementById('incomeVal').textContent = '+' + totalIncome;
}

// ============ SHOP ============
function buildShopList() {
  const list = document.getElementById('shopList');
  list.innerHTML = '';
  for (const def of BUILDINGS) {
    const item = document.createElement('div');
    item.className = 'shop-item' + (gold < def.cost ? ' disabled' : '') + (selectedBuilding === def ? ' selected' : '');
    item.innerHTML = `
      <div class="shop-icon">${def.icon}</div>
      <div class="shop-info">
        <div class="shop-name">${def.name}</div>
        <div class="shop-cost">${def.cost}g | +${def.pop} pop</div>
        <div class="shop-income">+${def.income}g/tick | +${def.happy} &#128154;</div>
      </div>`;
    item.onclick = () => selectBuilding(def);
    list.appendChild(item);
  }
}

function updateShopList() {
  const items = document.querySelectorAll('.shop-item');
  BUILDINGS.forEach((def, i) => {
    if (items[i]) {
      items[i].className = 'shop-item' + (gold < def.cost ? ' disabled' : '') + (selectedBuilding === def ? ' selected' : '');
    }
  });
}

function selectBuilding(def) {
  if (gold < def.cost) {
    showNotification('Not enough gold!');
    return;
  }
  selectedBuilding = (selectedBuilding === def) ? null : def;
  hideUpgradePanel();
  updateShopList();
}

function clearSelection() {
  selectedBuilding = null;
  hideUpgradePanel();
  updateShopList();
}

// ============ PLACEMENT ============
canvas.addEventListener('mousemove', (e) => {
  const rect = canvas.getBoundingClientRect();
  const scaleX = CW / rect.width;
  const scaleY = CH / rect.height;
  const mx = (e.clientX - rect.left) * scaleX;
  const my = (e.clientY - rect.top) * scaleY;
  const col = (mx / TILE) | 0;
  const row = (my / TILE) | 0;
  hoveredTile = { row, col };

  // Tooltip
  if (!selectedBuilding && row >= 0 && row < GRID_ROWS && col >= 0 && col < GRID_COLS) {
    const tile = grid[row][col];
    if (tile.building) {
      const tt = document.getElementById('tooltip');
      const b = tile.building;
      const lvl = b.level || 1;
      const mult = 1 + (lvl - 1) * 0.6;
      tt.querySelector('.tt-name').textContent = `${b.def.icon} ${b.def.name} Lv.${lvl}`;
      tt.querySelector('.tt-info').innerHTML = `Income: +${Math.floor(b.def.income * mult)}g/tick<br>Pop: +${Math.floor(b.def.pop * lvl)}<br>Click to upgrade`;
      tt.style.display = 'block';
      tt.style.left = (e.clientX - canvas.getBoundingClientRect().left + 15) + 'px';
      tt.style.top = (e.clientY - canvas.getBoundingClientRect().top - 10) + 'px';
    } else {
      document.getElementById('tooltip').style.display = 'none';
    }
  } else {
    document.getElementById('tooltip').style.display = 'none';
  }
});

canvas.addEventListener('mouseleave', () => {
  hoveredTile = null;
  document.getElementById('tooltip').style.display = 'none';
});

canvas.addEventListener('click', (e) => {
  if (!hoveredTile) return;
  const { row, col } = hoveredTile;
  if (row < 0 || row >= GRID_ROWS || col < 0 || col >= GRID_COLS) return;

  if (selectedBuilding) {
    // Place building
    if (!isBuildable(row, col)) {
      showNotification('Cannot build here!');
      return;
    }
    if (gold < selectedBuilding.cost) {
      showNotification('Not enough gold!');
      return;
    }

    gold -= selectedBuilding.cost;
    const b = {
      row, col,
      def: selectedBuilding,
      level: 1,
      placeTime: performance.now()
    };
    placedBuildings.push(b);
    grid[row][col].building = b;

    spawnFloatingText(`-${selectedBuilding.cost}g`, col * TILE + TILE / 2, row * TILE, '#ff8080');
    playSound('place');
    recalcStats();
    updateStats();
    updateShopList();

    // Keep building selected for fast placement
    if (gold < selectedBuilding.cost) {
      selectedBuilding = null;
      updateShopList();
    }
  } else {
    // Click existing building to upgrade
    const tile = grid[row][col];
    if (tile.building) {
      showUpgradePanel(tile.building, e);
    }
  }
});

// ============ UPGRADE PANEL ============
function showUpgradePanel(b, e) {
  const panel = document.getElementById('upgradePanel');
  const lvl = b.level || 1;
  const upgradeCost = Math.floor(b.def.cost * lvl * 1.5);
  const nextMult = 1 + lvl * 0.6;
  const nextIncome = Math.floor(b.def.income * nextMult);

  panel.innerHTML = `
    <div class="up-name">${b.def.icon} ${b.def.name} Lv.${lvl}</div>
    <div class="up-info">
      Current income: +${Math.floor(b.def.income * (1 + (lvl - 1) * 0.6))}g/tick<br>
      Next level: +${nextIncome}g/tick<br>
      Population: +${Math.floor(b.def.pop * (lvl + 1))}
    </div>
    <button onclick="upgradeBuilding(${b.row},${b.col})">Upgrade (${upgradeCost}g)</button>
    <button onclick="sellBuilding(${b.row},${b.col})" class="close-btn">Sell (+${Math.floor(b.def.cost * lvl * 0.5)}g)</button>
    <button onclick="hideUpgradePanel()" class="close-btn" style="margin-top:2px">Close</button>
  `;

  panel.style.display = 'block';
  const rect = canvas.getBoundingClientRect();
  let px = e.clientX - rect.left + 15;
  let py = e.clientY - rect.top - 10;
  if (px + 200 > rect.width) px = rect.width - 210;
  if (py + 160 > rect.height) py = rect.height - 170;
  panel.style.left = px + 'px';
  panel.style.top = py + 'px';
}

function hideUpgradePanel() {
  document.getElementById('upgradePanel').style.display = 'none';
}

window.upgradeBuilding = function(row, col) {
  const tile = grid[row][col];
  if (!tile.building) return;
  const b = tile.building;
  const lvl = b.level || 1;
  const cost = Math.floor(b.def.cost * lvl * 1.5);
  if (gold < cost) {
    showNotification('Not enough gold!');
    return;
  }
  gold -= cost;
  b.level = lvl + 1;
  b.placeTime = performance.now();
  spawnFloatingText(`Lv.${b.level}!`, col * TILE + TILE / 2, row * TILE - 10, '#60f080');
  playSound('upgrade');
  recalcStats();
  updateStats();
  updateShopList();
  hideUpgradePanel();
};

window.sellBuilding = function(row, col) {
  const tile = grid[row][col];
  if (!tile.building) return;
  const b = tile.building;
  const lvl = b.level || 1;
  const refund = Math.floor(b.def.cost * lvl * 0.5);
  gold += refund;
  spawnFloatingText(`+${refund}g`, col * TILE + TILE / 2, row * TILE, '#f0c060');
  placedBuildings = placedBuildings.filter(pb => pb !== b);
  tile.building = null;
  playSound('sell');
  recalcStats();
  updateStats();
  updateShopList();
  hideUpgradePanel();
};

// ============ FLOATING TEXT ============
function spawnFloatingText(text, x, y, color) {
  const el = document.createElement('div');
  el.className = 'floating-text';
  el.textContent = text;
  el.style.color = color;

  const wrap = document.getElementById('canvasWrap');
  const rect = canvas.getBoundingClientRect();
  const wrapRect = wrap.getBoundingClientRect();

  const scaleX = rect.width / CW;
  const scaleY = rect.height / CH;

  el.style.left = (rect.left - wrapRect.left + x * scaleX) + 'px';
  el.style.top = (rect.top - wrapRect.top + y * scaleY) + 'px';
  wrap.appendChild(el);

  floatingTexts.push({ el, time: performance.now() });
}

function updateFloatingTexts() {
  const now = performance.now();
  floatingTexts = floatingTexts.filter(ft => {
    if (now - ft.time > 1500) {
      ft.el.remove();
      return false;
    }
    return true;
  });
}

// ============ NOTIFICATIONS ============
function showNotification(msg) {
  const el = document.getElementById('notification');
  el.textContent = msg;
  el.classList.add('show');
  setTimeout(() => el.classList.remove('show'), 1500);
}

// ============ AUDIO ============
function initAudio() {
  if (audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
}

function playSound(type) {
  try {
    initAudio();
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);

    switch(type) {
      case 'place':
        osc.type = 'sine';
        osc.frequency.setValueAtTime(523, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(784, audioCtx.currentTime + 0.1);
        gain.gain.setValueAtTime(0.08, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.2);
        osc.start(); osc.stop(audioCtx.currentTime + 0.2);
        break;
      case 'coin':
        osc.type = 'sine';
        osc.frequency.setValueAtTime(880, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(1320, audioCtx.currentTime + 0.08);
        gain.gain.setValueAtTime(0.05, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.15);
        osc.start(); osc.stop(audioCtx.currentTime + 0.15);
        break;
      case 'upgrade':
        osc.type = 'sine';
        osc.frequency.setValueAtTime(440, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(880, audioCtx.currentTime + 0.15);
        osc.frequency.exponentialRampToValueAtTime(1320, audioCtx.currentTime + 0.25);
        gain.gain.setValueAtTime(0.07, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.35);
        osc.start(); osc.stop(audioCtx.currentTime + 0.35);
        break;
      case 'sell':
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(600, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(300, audioCtx.currentTime + 0.15);
        gain.gain.setValueAtTime(0.06, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.2);
        osc.start(); osc.stop(audioCtx.currentTime + 0.2);
        break;
    }
  } catch(e) {}
}

function startAmbient() {
  if (ambientRunning) return;
  try {
    initAudio();
    ambientRunning = true;

    // Ocean ambient - filtered noise
    const bufferSize = audioCtx.sampleRate * 2;
    const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) {
      data[i] = (Math.random() * 2 - 1);
    }

    const noise = audioCtx.createBufferSource();
    noise.buffer = buffer;
    noise.loop = true;

    const filter = audioCtx.createBiquadFilter();
    filter.type = 'lowpass';
    filter.frequency.setValueAtTime(250, audioCtx.currentTime);

    ambientGain = audioCtx.createGain();
    ambientGain.gain.setValueAtTime(0, audioCtx.currentTime);
    ambientGain.gain.linearRampToValueAtTime(0.03, audioCtx.currentTime + 2);

    noise.connect(filter);
    filter.connect(ambientGain);
    ambientGain.connect(audioCtx.destination);
    noise.start();

    // Modulate filter for wave effect
    const lfo = audioCtx.createOscillator();
    lfo.frequency.setValueAtTime(0.1, audioCtx.currentTime);
    const lfoGain = audioCtx.createGain();
    lfoGain.gain.setValueAtTime(100, audioCtx.currentTime);
    lfo.connect(lfoGain);
    lfoGain.connect(filter.frequency);
    lfo.start();
  } catch(e) {}
}

// Start ambient on first interaction
document.addEventListener('click', () => startAmbient(), { once: true });

// ============ PARTICLE BACKGROUND ============
function initParticles() {
  bgCanvas.width = window.innerWidth;
  bgCanvas.height = window.innerHeight;
  for (let i = 0; i < 50; i++) {
    particles.push({
      x: Math.random() * bgCanvas.width,
      y: Math.random() * bgCanvas.height,
      r: Math.random() * 2 + 0.5,
      vx: (Math.random() - 0.5) * 0.3,
      vy: (Math.random() - 0.5) * 0.3,
      alpha: Math.random() * 0.3 + 0.05
    });
  }
}

function drawParticles() {
  bgCtx.clearRect(0, 0, bgCanvas.width, bgCanvas.height);
  for (const p of particles) {
    p.x += p.vx;
    p.y += p.vy;
    if (p.x < 0) p.x = bgCanvas.width;
    if (p.x > bgCanvas.width) p.x = 0;
    if (p.y < 0) p.y = bgCanvas.height;
    if (p.y > bgCanvas.height) p.y = 0;

    bgCtx.fillStyle = `rgba(240,192,96,${p.alpha})`;
    bgCtx.beginPath();
    bgCtx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
    bgCtx.fill();
  }
  requestAnimationFrame(drawParticles);
}

// ============ SAVE / LOAD ============
function saveGame() {
  const data = {
    gold, dayTime, dayCount,
    buildings: placedBuildings.map(b => ({
      row: b.row, col: b.col,
      id: b.def.id,
      level: b.level
    })),
    gridSeed: grid.map(row => row.map(cell => cell.type))
  };
  localStorage.setItem('islandParadise', JSON.stringify(data));
  showNotification('Game saved!');
}

function loadGame() {
  const raw = localStorage.getItem('islandParadise');
  if (!raw) {
    showNotification('No save found!');
    return;
  }
  try {
    const data = JSON.parse(raw);
    gold = data.gold || 100;
    dayTime = data.dayTime || 0;
    dayCount = data.dayCount || 1;

    // Restore grid
    if (data.gridSeed) {
      for (let r = 0; r < GRID_ROWS; r++) {
        for (let c = 0; c < GRID_COLS; c++) {
          if (data.gridSeed[r] && data.gridSeed[r][c]) {
            grid[r][c] = { type: data.gridSeed[r][c], building: null };
          }
        }
      }
    }

    // Restore buildings
    placedBuildings = [];
    if (data.buildings) {
      for (const bd of data.buildings) {
        const def = BUILDINGS.find(b => b.id === bd.id);
        if (def && bd.row < GRID_ROWS && bd.col < GRID_COLS) {
          const b = { row: bd.row, col: bd.col, def, level: bd.level || 1, placeTime: 0 };
          placedBuildings.push(b);
          grid[bd.row][bd.col].building = b;
        }
      }
    }

    recalcStats();
    updateStats();
    updateShopList();
    showNotification('Game loaded!');
  } catch(e) {
    showNotification('Failed to load save!');
  }
}

// ============ RESIZE ============
function resizeCanvas() {
  const wrap = document.getElementById('canvasWrap');
  const maxW = wrap.clientWidth - 20;
  const maxH = wrap.clientHeight - 20;
  const scale = Math.min(maxW / CW, maxH / CH, 1.5);
  canvas.style.width = (CW * scale) + 'px';
  canvas.style.height = (CH * scale) + 'px';

  bgCanvas.width = window.innerWidth;
  bgCanvas.height = window.innerHeight;
}

window.addEventListener('resize', resizeCanvas);

// ============ INIT ============
function init() {
  generateIsland();
  buildShopList();
  updateStats();
  resizeCanvas();
  initParticles();
  drawParticles();

  // Try auto-load
  if (localStorage.getItem('islandParadise')) {
    loadGame();
  }

  requestAnimationFrame(gameLoop);
}

init();
</script>
</body>
</html>
